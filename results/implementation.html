<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Fishing Upgrade Game</title>
<script src="https://cdn.jsdelivr.net/npm/three-js@79.0.0/three.min.js"></script>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #02101f;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    color: #fff;
    touch-action: none;
  }
  #game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: radial-gradient(circle at top, #2f6cff 0, #02101f 60%, #01060f 100%);
  }
  canvas {
    display: block;
  }
  .ui-layer {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
  }

  /* Top HUD */
  #top-hud {
    position: absolute;
    top: 1.5vh;
    left: 3vw;
    right: 3vw;
    display: flex;
    justify-content: space-between;
    align-items: center;
    pointer-events: none;
    font-size: clamp(12px, 2.4vw, 20px);
  }
  .counter {
    display: inline-flex;
    align-items: center;
    gap: 0.4em;
    padding: 0.3em 0.6em;
    border-radius: 999px;
    background: rgba(0, 0, 0, 0.45);
    box-shadow: 0 0 10px rgba(0,0,0,0.6);
  }
  .counter-icon {
    width: 1.2em;
    height: 1.2em;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #fff9c4 0, #ffd54f 40%, #f9a825 70%, #ff6f00 100%);
    box-shadow: 0 0 6px rgba(0,0,0,0.7);
  }
  .counter-label {
    opacity: 0.8;
  }
  #fish-counter { display: none; }

  /* Center tutorial text */
  #tutorial-text {
    position: absolute;
    top: 18vh;
    left: 50%;
    transform: translateX(-50%);
    max-width: 80vw;
    text-align: center;
    font-size: clamp(14px, 2.8vw, 22px);
    padding: 0.8em 1em;
    border-radius: 14px;
    background: rgba(0,0,0,0.6);
    box-shadow: 0 10px 25px rgba(0,0,0,0.7);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  /* Bottom controls: upgrades + gauge + play */
  #bottom-ui {
    position: absolute;
    bottom: 2.5vh;
    left: 0;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1vh;
    pointer-events: none;
  }
  #upgrades {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 1vh;
    width: 100%;
    max-width: 600px;
    pointer-events: auto;
  }
  .upgrade-btn {
    flex: 1 1 42%;
    min-width: 120px;
    max-width: 240px;
    padding: 0.5em 0.6em;
    font-size: clamp(12px, 2.2vw, 18px);
    border-radius: 12px;
    border: none;
    outline: none;
    background: linear-gradient(135deg, #1e88e5, #42a5f5);
    color: #fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.7);
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.1em;
  }
  .upgrade-btn.disabled {
    background: linear-gradient(135deg, #555, #777);
    opacity: 0.5;
  }
  .upgrade-title {
    font-weight: 600;
  }
  .upgrade-detail {
    font-size: 0.85em;
    opacity: 0.9;
  }
  .upgrade-cost {
    font-size: 0.85em;
    margin-top: 0.2em;
    color: #ffe082;
  }

  #gauge-container {
    width: 75vw;
    max-width: 520px;
    height: 46px;
    background: rgba(0,0,0,0.5);
    border-radius: 24px;
    padding: 8px 14px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.85);
    display: flex;
    align-items: center;
    justify-content: space-between;
    pointer-events: auto;
  }
  #gauge {
    position: relative;
    flex: 1;
    height: 10px;
    margin-right: 12px;
    border-radius: 999px;
    background: linear-gradient(90deg, #4caf50 0, #fff176 40%, #ffb300 70%, #e53935 100%);
    overflow: hidden;
  }
  #gauge-pointer {
    position: absolute;
    top: 50%;
    width: 3px;
    height: 18px;
    transform: translate(-50%, -50%);
    background: #fff;
    box-shadow: 0 0 6px rgba(0,0,0,0.8);
    border-radius: 999px;
  }
  #play-button {
    min-width: 96px;
    padding: 8px 14px;
    border-radius: 18px;
    border: none;
    outline: none;
    font-size: clamp(13px, 2.4vw, 18px);
    font-weight: 600;
    background: linear-gradient(135deg, #ffb300, #ff7043);
    color: #111;
    box-shadow: 0 4px 10px rgba(0,0,0,0.7);
  }
  #play-button:active {
    transform: scale(0.96);
  }

  /* Fish fill bar in top hud */
  #fish-fill-bar {
    width: 80px;
    height: 8px;
    border-radius: 999px;
    background: rgba(255,255,255,0.15);
    overflow: hidden;
  }
  #fish-fill-inner {
    width: 0%;
    height: 100%;
    border-radius: inherit;
    background: linear-gradient(90deg, #4caf50, #8bc34a);
    transition: width 0.15s linear;
  }

  /* Endcard */
  #endcard {
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at top, rgba(12, 35, 90, 0.96), rgba(1, 6, 20, 0.98));
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 0 8vw;
    pointer-events: auto;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.4s ease;
  }
  #endcard.visible {
    opacity: 1;
    visibility: visible;
  }
  #endcard h1 {
    font-size: clamp(24px, 5vw, 34px);
    margin-bottom: 0.4em;
  }
  #endcard p {
    max-width: 480px;
    margin-bottom: 1em;
    font-size: clamp(14px, 3vw, 18px);
    opacity: 0.9;
  }
  #endcard-summary {
    margin-bottom: 1.3em;
    font-size: clamp(14px, 2.8vw, 18px);
  }
  #install-button {
    padding: 0.7em 2.4em;
    border-radius: 999px;
    border: none;
    outline: none;
    font-size: clamp(16px, 3.3vw, 22px);
    font-weight: 700;
    color: #04100a;
    background: linear-gradient(135deg, #00e676, #1de9b6);
    box-shadow: 0 10px 28px rgba(0,0,0,0.9);
  }
  #install-button:active {
    transform: scale(0.96);
  }

  .popup {
    position: absolute;
    pointer-events: none;
    font-size: clamp(10px, 2.4vw, 16px);
    text-shadow: 0 0 4px rgba(0,0,0,0.8);
    white-space: nowrap;
  }

  @media (orientation: landscape) {
    #bottom-ui {
      bottom: 2vh;
    }
    #gauge-container {
      max-width: 480px;
    }
    #upgrades {
      max-width: 540px;
    }
  }
</style>
</head>
<body>
<div id="game-container">
  <canvas id="game-canvas"></canvas>
  <div class="ui-layer">
    <div id="top-hud">
      <div id="coin-counter" class="counter">
        <div class="counter-icon"></div>
        <div>
          <div class="counter-label">Coins</div>
          <div id="coin-value">100</div>
        </div>
      </div>
      <div id="fish-counter" class="counter">
        <div class="counter-icon" style="background: radial-gradient(circle at 30% 30%, #bbdefb 0, #64b5f6 40%, #1e88e5 70%, #0d47a1 100%);"></div>
        <div>
          <div class="counter-label">Fish</div>
          <div><span id="fish-count">0</span>/<span id="fish-cap">6</span></div>
        </div>
        <div id="fish-fill-bar">
          <div id="fish-fill-inner"></div>
        </div>
      </div>
    </div>

    <div id="tutorial-text"></div>

    <div id="bottom-ui">
      <div id="upgrades">
        <button id="upgrade-fish" class="upgrade-btn">
          <div class="upgrade-title">More Fish</div>
          <div class="upgrade-detail" id="upgrade-fish-detail">Max fish: 6 → 7</div>
          <div class="upgrade-cost" id="upgrade-fish-cost">Cost: 50</div>
        </button>
        <button id="upgrade-depth" class="upgrade-btn">
          <div class="upgrade-title">Deeper Line</div>
          <div class="upgrade-detail" id="upgrade-depth-detail">Max depth: 5m → 10m</div>
          <div class="upgrade-cost" id="upgrade-depth-cost">Cost: 50</div>
        </button>
      </div>
      <div id="gauge-container">
        <div id="gauge">
          <div id="gauge-pointer"></div>
        </div>
        <button id="play-button">Cast!</button>
      </div>
    </div>

    <div id="endcard">
      <h1>Huge Catch!</h1>
      <div id="endcard-summary"></div>
      <p>Upgrade your gear, dive deeper, and catch legendary fish in the full game.</p>
      <button id="install-button">Install</button>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script>
(function() {
  // --- Constants & Data ---
  const GameState = {
    LOADING: 'loading',
    TUTORIAL: 'tutorial',
    GAMEPLAY: 'gameplay',
    ENDCARD: 'endcard'
  };
  const MAX_ROUNDS = 3;

  const FishRarity = {
    COMMON: 'common',
    RARE: 'rare',
    AMAZING: 'amazing',
    LEGENDARY: 'legendary'
  };

  const fishRarityConfig = {
    common:   { label: null,           baseValue: 10, color: 0x77ccff },
    rare:     { label: 'RARE!',        baseValue: 20, color: 0x44ff88 },
    amazing:  { label: 'AMAZING!',     baseValue: 30, color: 0xffcc00 },
    legendary:{ label: 'LEGENDARY!',   baseValue: 50, color: 0xff4444 }
  };

  const maxFishUpgradeSteps = [
    { fishCap: 7, cost: 50 },
    { fishCap: 8, cost: 100 },
    { fishCap: 9, cost: 200 },
    { fishCap: 10, cost: 400 }
  ];
  const maxDepthUpgradeSteps = [
    { depth: 10, cost: 50 },
    { depth: 15, cost: 75 },
    { depth: 20, cost: 150 },
    { depth: 30, cost: 300 }
  ];

  const player = {
    coins: 100,
    round: 1,
    maxFish: 6,
    maxDepth: 5,
    ownedUpgrades: {
      maxFishLevel: 0,
      maxDepthLevel: 0
    }
  };

  const roundData = {
    currentDepthChoice: 5,
    actualDepthMeters: 5,
    hookPhase: 'idle', // 'idle','gauge','descending','pause','ascending','summary'
    fishCaught: [],
    fishCap: player.maxFish,
    coinsGainedThisRound: 0,
    pauseTimer: 0
  };

  let currentState = GameState.LOADING;
  let lastTime = 0;
  let globalTime = 0;

  // --- Three.js Scene ---
  let renderer, scene, camera;
  let boatGroup, hookGroup, ropeMesh;
  const fishPool = [];
  const activeFish = [];

  const world = {
    surfaceY: 0,
    meterToWorld: 0.8, // 1m = 0.8 world units
    maxHorizontal: 6
  };

  let hookTargetX = 0;
  let pointerActive = false;
  let pointerLastX = 0;

  // Gauge
  let gaugeTime = 0;
  let inGauge = false;
  const gaugeSpeed = 2.5;

  // Tutorial
  let tutorialShownOnce = false;

  // DOM elements
  const canvas = document.getElementById('game-canvas');
  const coinValueEl = document.getElementById('coin-value');
  const fishCounterEl = document.getElementById('fish-counter');
  const fishCountEl = document.getElementById('fish-count');
  const fishCapEl = document.getElementById('fish-cap');
  const fishFillInnerEl = document.getElementById('fish-fill-inner');
  const gaugePointerEl = document.getElementById('gauge-pointer');
  const tutorialTextEl = document.getElementById('tutorial-text');
  const playButtonEl = document.getElementById('play-button');
  const upgradeFishBtn = document.getElementById('upgrade-fish');
  const upgradeDepthBtn = document.getElementById('upgrade-depth');
  const upgradeFishDetail = document.getElementById('upgrade-fish-detail');
  const upgradeFishCost = document.getElementById('upgrade-fish-cost');
  const upgradeDepthDetail = document.getElementById('upgrade-depth-detail');
  const upgradeDepthCost = document.getElementById('upgrade-depth-cost');
  const endcardEl = document.getElementById('endcard');
  const endcardSummaryEl = document.getElementById('endcard-summary');
  const installButtonEl = document.getElementById('install-button');
  const coinCounterEl = document.getElementById('coin-counter');

  // --- Utility ---
  function clamp(v, min, max) { return v < min ? min : (v > max ? max : v); }
  function lerp(a,b,t) { return a + (b-a)*t; }

  function worldToScreen(pos) {
    const vector = pos.clone().project(camera);
    const x = (vector.x + 1) / 2 * window.innerWidth;
    const y = (-vector.y + 1) / 2 * window.innerHeight;
    return { x, y };
  }

  function spawnPopup(text, color, x, y) {
    const div = document.createElement('div');
    div.className = 'popup';
    div.textContent = text;
    div.style.left = (x - 20) + 'px';
    div.style.top = (y - 10) + 'px';
    div.style.color = color || '#ffffff';
    div.style.opacity = '1';
    document.body.appendChild(div);
    const duration = 800;
    const start = performance.now();
    function anim(t) {
      const dt = t - start;
      const k = dt / duration;
      if (k >= 1) {
        document.body.removeChild(div);
        return;
      }
      const e = 1 - (1-k)*(1-k);
      div.style.transform = 'translateY(' + (-20*e) + 'px)';
      div.style.opacity = String(1-k);
      requestAnimationFrame(anim);
    }
    requestAnimationFrame(anim);
  }

  // --- Scene Setup ---
  function setupThree() {
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x02101f, 1);

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 3, 14);
    camera.lookAt(0, 0, 0);

    const ambient = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambient);

    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 10, 8);
    scene.add(dir);

    // Water background
    const waterGeo = new THREE.PlaneGeometry(40, 80);
    const waterMat = new THREE.MeshLambertMaterial({ color: 0x033c77, side: THREE.DoubleSide });
    const water = new THREE.Mesh(waterGeo, waterMat);
    water.position.set(0, -20, -5);
    scene.add(water);

    // Boat + fisherman
    boatGroup = new THREE.Group();
    scene.add(boatGroup);

    const boatHullGeo = new THREE.BoxGeometry(5, 0.6, 2);
    const boatHullMat = new THREE.MeshLambertMaterial({ color: 0x5d4037 });
    const boatHull = new THREE.Mesh(boatHullGeo, boatHullMat);
    boatHull.position.set(0, world.surfaceY + 0.25, 0);
    boatGroup.add(boatHull);

    const boatDeckGeo = new THREE.BoxGeometry(3, 0.2, 1.8);
    const boatDeckMat = new THREE.MeshLambertMaterial({ color: 0x8d6e63 });
    const boatDeck = new THREE.Mesh(boatDeckGeo, boatDeckMat);
    boatDeck.position.set(0, world.surfaceY + 0.7, 0);
    boatGroup.add(boatDeck);

    const bodyGeo = new THREE.CylinderGeometry(0.35, 0.4, 1.2, 8);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0x1565c0 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.set(-0.4, world.surfaceY + 1.5, 0);
    boatGroup.add(body);

    const headGeo = new THREE.SphereGeometry(0.32, 12, 12);
    const headMat = new THREE.MeshLambertMaterial({ color: 0xffe0b2 });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.set(-0.4, world.surfaceY + 2.2, 0);
    boatGroup.add(head);

    // Hook + rope
    hookGroup = new THREE.Group();
    scene.add(hookGroup);

    const ropeGeo = new THREE.CylinderGeometry(0.04, 0.04, 10, 6);
    const ropeMat = new THREE.MeshLambertMaterial({ color: 0xf5f5f5 });
    ropeMesh = new THREE.Mesh(ropeGeo, ropeMat);
    ropeMesh.position.set(1.3, world.surfaceY - 5, 0);
    hookGroup.add(ropeMesh);

    const hookBarGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.4, 8);
    const hookBarMat = new THREE.MeshLambertMaterial({ color: 0xb0bec5 });
    const hookBar = new THREE.Mesh(hookBarGeo, hookBarMat);
    hookBar.rotation.z = Math.PI / 2;
    hookBar.position.set(1.3, world.surfaceY - 10, 0);
    hookGroup.add(hookBar);

    const hookTipGeo = new THREE.TorusGeometry(0.18, 0.05, 6, 10, Math.PI);
    const hookTipMat = new THREE.MeshLambertMaterial({ color: 0xb0bec5 });
    const hookTip = new THREE.Mesh(hookTipGeo, hookTipMat);
    hookTip.rotation.y = Math.PI / 2;
    hookTip.position.set(1.5, world.surfaceY - 10, 0.1);
    hookGroup.add(hookTip);

    hookGroup.userData.hookY = world.surfaceY - 10;
    hookGroup.userData.hookX = 1.3;
    hookTargetX = hookGroup.userData.hookX;

    // Pre-create fish pool
    createFishPool();
  }

  function createFishPool() {
    const bodyGeo = new THREE.SphereGeometry(0.35, 12, 10);
    const tailGeo = new THREE.ConeGeometry(0.2, 0.4, 6);
    for (let i = 0; i < 40; i++) {
      const fishGroup = new THREE.Group();
      const rarity = pickRarityByDepth(0);
      const mat = new THREE.MeshLambertMaterial({ color: fishRarityConfig[rarity].color });
      const body = new THREE.Mesh(bodyGeo, mat);
      const tail = new THREE.Mesh(tailGeo, mat);
      body.scale.set(1.4, 0.9, 0.9);
      tail.rotation.z = Math.PI;
      tail.position.set(-0.6, 0, 0);
      fishGroup.add(body);
      fishGroup.add(tail);
      fishGroup.visible = false;
      fishGroup.userData = {
        active: false,
        rarity,
        value: fishRarityConfig[rarity].baseValue,
        baseColor: fishRarityConfig[rarity].color,
        speed: 0.8 + Math.random()*0.6,
        dir: Math.random() < 0.5 ? -1 : 1,
        phase: Math.random() * Math.PI * 2,
        caught: false,
        depth: 0
      };
      scene.add(fishGroup);
      fishPool.push(fishGroup);
    }
  }

  // --- Fish Spawning & Rarity ---
  function pickRarityByDepth(depthMeters) {
    const t = clamp(depthMeters / player.maxDepth, 0, 1);
    let roll = Math.random();
    if (roll < 0.6 - 0.3*t) return FishRarity.COMMON;
    roll -= (0.6 - 0.3*t);
    if (roll < 0.25 + 0.15*t) return FishRarity.RARE;
    roll -= (0.25 + 0.15*t);
    if (roll < 0.12 + 0.1*t) return FishRarity.AMAZING;
    return FishRarity.LEGENDARY;
  }

  function resetFishForRound(maxDepthMeters) {
    activeFish.length = 0;
    for (const f of fishPool) {
      f.visible = false;
      f.userData.active = false;
      f.userData.caught = false;
    }
    const count = 18;
    for (let i = 0; i < count; i++) {
      const f = fishPool[i];
      const depthM = 1 + Math.random() * (maxDepthMeters - 1);
      const rarity = pickRarityByDepth(depthM);
      f.userData.rarity = rarity;
      f.userData.value = fishRarityConfig[rarity].baseValue;
      f.userData.speed = 0.6 + Math.random() * 0.8;
      f.userData.dir = Math.random() < 0.5 ? -1 : 1;
      f.userData.phase = Math.random() * Math.PI * 2;
      f.userData.caught = false;
      f.userData.depth = depthM;
      f.visible = true;
      f.userData.active = true;
      const y = world.surfaceY - depthM * world.meterToWorld;
      const x = (Math.random() * 2 - 1) * (world.maxHorizontal - 1);
      f.position.set(x, y, 0);
      f.rotation.y = f.userData.dir > 0 ? Math.PI : 0;
      activeFish.push(f);
    }
  }

  // --- State Handling ---
  function changeState(newState) {
    currentState = newState;
    if (newState === GameState.TUTORIAL) enterTutorial();
    else if (newState === GameState.GAMEPLAY) enterGameplay();
    else if (newState === GameState.ENDCARD) enterEndcard();
  }

  function enterTutorial() {
    player.round = 1;
    startRound();
  }

  function enterGameplay() {
    startRound();
  }

  function enterEndcard() {
    document.getElementById('bottom-ui').style.opacity = '0';
    document.getElementById('bottom-ui').style.pointerEvents = 'none';
    document.getElementById('top-hud').style.opacity = '0';
    const totalCoins = player.coins;
    endcardSummaryEl.textContent = 'You finished with ' + totalCoins + ' coins after ' + MAX_ROUNDS + ' rounds.';
    endcardEl.classList.add('visible');
  }

  function startRound() {
    roundData.hookPhase = 'idle';
    roundData.fishCaught = [];
    roundData.fishCap = player.maxFish;
    roundData.coinsGainedThisRound = 0;
    roundData.pauseTimer = 0;

    fishCountEl.textContent = '0';
    fishCapEl.textContent = String(roundData.fishCap);
    fishFillInnerEl.style.width = '0%';

    coinCounterEl.style.display = 'inline-flex';
    fishCounterEl.style.display = 'none';

    tutorialTextEl.style.opacity = '0';

    resetFishForRound(player.maxDepth);

    inGauge = false;
    playButtonEl.textContent = 'Cast!';
  }

  // --- Gauge & Depth ---
  function startGauge() {
    inGauge = true;
    roundData.hookPhase = 'gauge';
    gaugeTime = 0;
    playButtonEl.textContent = 'Stop';
  }

  function stopGaugeAndDescend() {
    inGauge = false;
    const rect = document.getElementById('gauge').getBoundingClientRect();
    const pointerRect = gaugePointerEl.getBoundingClientRect();
    const t = clamp((pointerRect.left + pointerRect.width/2 - rect.left) / rect.width, 0, 1);
    const minDepth = Math.max(1, player.maxDepth - 2);
    const chosenDepth = minDepth + t * (player.maxDepth - minDepth);
    roundData.currentDepthChoice = chosenDepth;
    roundData.actualDepthMeters = chosenDepth;
    startDescending();
  }

  function startDescending() {
    roundData.hookPhase = 'descending';
    coinCounterEl.style.display = 'none';
    fishCounterEl.style.display = 'inline-flex';
    playButtonEl.textContent = '...';
    playButtonEl.disabled = true;
  }

  function startAscending() {
    roundData.hookPhase = 'ascending';
    playButtonEl.textContent = 'Reeling...';
    playButtonEl.disabled = true;
  }

  function startSummary() {
    roundData.hookPhase = 'summary';
    playButtonEl.textContent = 'Next';
    playButtonEl.disabled = false;
    coinCounterEl.style.display = 'inline-flex';
    fishCounterEl.style.display = 'none';

    let total = 0;
    for (const f of roundData.fishCaught) total += f.userData.value;
    roundData.coinsGainedThisRound = total;

    let displayed = player.coins;
    const target = player.coins + total;
    const duration = 700;
    const start = performance.now();
    function animateCount(t) {
      const k = clamp((t - start) / duration, 0, 1);
      const val = Math.round(lerp(displayed, target, k));
      coinValueEl.textContent = String(val);
      if (k < 1) requestAnimationFrame(animateCount);
      else {
        player.coins = target;
        updateUpgradeButtons();
      }
    }
    requestAnimationFrame(animateCount);
  }

  // --- Upgrade UI ---
  function updateUpgradeButtons() {
    const fishLevel = player.ownedUpgrades.maxFishLevel;
    if (fishLevel < maxFishUpgradeSteps.length) {
      const step = maxFishUpgradeSteps[fishLevel];
      upgradeFishDetail.textContent = 'Max fish: ' + player.maxFish + ' → ' + step.fishCap;
      upgradeFishCost.textContent = 'Cost: ' + step.cost;
      if (player.coins >= step.cost) {
        upgradeFishBtn.classList.remove('disabled');
      } else {
        upgradeFishBtn.classList.add('disabled');
      }
    } else {
      upgradeFishDetail.textContent = 'Max fish: ' + player.maxFish;
      upgradeFishCost.textContent = 'Maxed';
      upgradeFishBtn.classList.add('disabled');
    }

    const depthLevel = player.ownedUpgrades.maxDepthLevel;
    if (depthLevel < maxDepthUpgradeSteps.length) {
      const step = maxDepthUpgradeSteps[depthLevel];
      upgradeDepthDetail.textContent = 'Max depth: ' + player.maxDepth + 'm → ' + step.depth + 'm';
      upgradeDepthCost.textContent = 'Cost: ' + step.cost;
      if (player.coins >= step.cost) {
        upgradeDepthBtn.classList.remove('disabled');
      } else {
        upgradeDepthBtn.classList.add('disabled');
      }
    } else {
      upgradeDepthDetail.textContent = 'Max depth: ' + player.maxDepth + 'm';
      upgradeDepthCost.textContent = 'Maxed';
      upgradeDepthBtn.classList.add('disabled');
    }
  }

  function applyUpgrade(type) {
    if (type === 'fish') {
      const level = player.ownedUpgrades.maxFishLevel;
      if (level >= maxFishUpgradeSteps.length) return;
      const step = maxFishUpgradeSteps[level];
      if (player.coins < step.cost) return;
      player.coins -= step.cost;
      player.maxFish = step.fishCap;
      player.ownedUpgrades.maxFishLevel++;
      coinValueEl.textContent = String(player.coins);
      updateUpgradeButtons();
    } else if (type === 'depth') {
      const level = player.ownedUpgrades.maxDepthLevel;
      if (level >= maxDepthUpgradeSteps.length) return;
      const step = maxDepthUpgradeSteps[level];
      if (player.coins < step.cost) return;
      player.coins -= step.cost;
      player.maxDepth = step.depth;
      player.ownedUpgrades.maxDepthLevel++;
      coinValueEl.textContent = String(player.coins);
      updateUpgradeButtons();
    }
  }

  // --- Input ---
  function setupInput() {
    playButtonEl.addEventListener('click', function() {
      if (currentState === GameState.ENDCARD) return;
      if (roundData.hookPhase === 'idle') {
        startGauge();
      } else if (roundData.hookPhase === 'gauge' && inGauge) {
        stopGaugeAndDescend();
      } else if (roundData.hookPhase === 'summary') {
        if (player.round < MAX_ROUNDS) {
          player.round++;
          if (player.round === 2 && currentState === GameState.TUTORIAL) {
            changeState(GameState.GAMEPLAY);
          } else {
            startRound();
          }
        } else {
          changeState(GameState.ENDCARD);
        }
      }
    });

    upgradeFishBtn.addEventListener('click', function() {
      applyUpgrade('fish');
    });
    upgradeDepthBtn.addEventListener('click', function() {
      applyUpgrade('depth');
    });

    function onPointerDown(e) {
      pointerActive = true;
      pointerLastX = e.clientX;
    }
    function onPointerMove(e) {
      if (!pointerActive) return;
      const dx = (e.clientX - pointerLastX) / window.innerWidth;
      pointerLastX = e.clientX;
      const factor = world.maxHorizontal * 2;
      hookTargetX = clamp(hookTargetX + dx * factor, -world.maxHorizontal, world.maxHorizontal);
    }
    function onPointerUp() {
      pointerActive = false;
    }
    window.addEventListener('pointerdown', onPointerDown, { passive: true });
    window.addEventListener('pointermove', onPointerMove, { passive: true });
    window.addEventListener('pointerup', onPointerUp, { passive: true });

    installButtonEl.addEventListener('click', function() {
      spawnPopup('Opening store...', '#00e676', window.innerWidth/2, window.innerHeight*0.7);
    });
  }

  // --- Update Loop ---
  function update(dt) {
    globalTime += dt;

    // Boat bobbing
    boatGroup.position.y = Math.sin(globalTime * 1.2) * 0.1;

    // Hook position & rope
    let hookY = hookGroup.userData.hookY;
    let hookX = hookGroup.userData.hookX;

    if (currentState === GameState.TUTORIAL || currentState === GameState.GAMEPLAY) {
      // Gauge pointer
      if (roundData.hookPhase === 'gauge' && inGauge) {
        gaugeTime += dt * gaugeSpeed;
        const t = 0.5 + 0.5 * Math.sin(gaugeTime);
        const gaugeRect = document.getElementById('gauge').getBoundingClientRect();
        const x = gaugeRect.left + t * gaugeRect.width;
        gaugePointerEl.style.left = (t * 100) + '%';
      }

      if (roundData.hookPhase === 'descending') {
        const targetY = world.surfaceY - roundData.actualDepthMeters * world.meterToWorld;
        const speed = 4;
        if (hookY > targetY) {
          hookY -= speed * dt;
          if (hookY < targetY) hookY = targetY;
        }
        if (Math.abs(hookY - targetY) < 0.02) {
          roundData.hookPhase = 'pause';
          roundData.pauseTimer = currentState === GameState.TUTORIAL ? 1.5 : 0.7;
          if (!tutorialShownOnce && currentState === GameState.TUTORIAL) {
            tutorialShownOnce = true;
            tutorialTextEl.textContent = 'Drag left and right to move the hook and catch fish!';
            tutorialTextEl.style.opacity = '1';
          }
        }
      } else if (roundData.hookPhase === 'pause') {
        roundData.pauseTimer -= dt;
        if (roundData.pauseTimer <= 0) {
          tutorialTextEl.style.opacity = '0';
          startAscending();
        }
      } else if (roundData.hookPhase === 'ascending') {
        const filled = roundData.fishCaught.length >= roundData.fishCap;
        const speed = filled ? 6 : 3.8;
        const targetY = world.surfaceY - 8; // keep some rope above surface
        if (hookY < targetY) {
          hookY += speed * dt;
          if (hookY > targetY) hookY = targetY;
        } else {
          startSummary();
        }
      }

      // Horizontal smoothing
      hookX = lerp(hookX, hookTargetX, 0.15);
      hookX = clamp(hookX, -world.maxHorizontal, world.maxHorizontal);

      // Collision with fish
      if (roundData.hookPhase === 'ascending') {
        const canCatch = roundData.fishCaught.length < roundData.fishCap;
        if (canCatch) {
          for (const f of activeFish) {
            if (!f.userData.active || f.userData.caught) continue;
            const dx = f.position.x - hookX;
            const dy = f.position.y - hookY;
            const dist2 = dx*dx + dy*dy;
            if (dist2 < 0.5*0.5) {
              f.userData.caught = true;
              roundData.fishCaught.push(f);
              const depthBonus = 1 + (f.userData.depth / player.maxDepth);
              const multi = (f.userData.rarity === FishRarity.COMMON) ? 1 :
                            (f.userData.rarity === FishRarity.RARE) ? 1.5 :
                            (f.userData.rarity === FishRarity.AMAZING) ? 2.2 : 3;
              f.userData.value = Math.round(fishRarityConfig[f.userData.rarity].baseValue * depthBonus * multi);
              const idx = roundData.fishCaught.length - 1;
              f.userData.hookOffsetX = (idx % 2 === 0 ? -0.4 : 0.4);
              f.userData.hookOffsetY = -0.4 - 0.3 * Math.floor(idx / 2);

              const screen = worldToScreen(f.position);
              spawnPopup('+' + f.userData.value, '#ffe082', screen.x, screen.y - 8);
              const rarCfg = fishRarityConfig[f.userData.rarity];
              if (rarCfg.label) {
                spawnPopup(rarCfg.label, '#ffeb3b', screen.x, screen.y - 26);
              }

              const count = roundData.fishCaught.length;
              fishCountEl.textContent = String(count);
              const frac = clamp(count / roundData.fishCap, 0, 1);
              fishFillInnerEl.style.width = (frac * 100) + '%';

              if (roundData.fishCaught.length >= roundData.fishCap) {
                break;
              }
            }
          }
        }
      }

      hookGroup.userData.hookY = hookY;
      hookGroup.userData.hookX = hookX;

      ropeMesh.position.set(hookX, (world.surfaceY + hookY)/2, 0);
      const ropeLength = (world.surfaceY - hookY);
      ropeMesh.scale.set(1, ropeLength / 10, 1);
      ropeMesh.geometry.computeBoundingBox();

      for (const obj of hookGroup.children) {
        if (obj !== ropeMesh) {
          obj.position.x = hookX;
          obj.position.y = hookY;
        }
      }

      const targetCamY = hookY + 6;
      camera.position.y = lerp(camera.position.y, targetCamY, 0.08);
      camera.position.y = clamp(camera.position.y, -25, 15);
      camera.lookAt(0, camera.position.y - 2, 0);
    }

    // Fish swim
    for (const f of activeFish) {
      if (!f.userData.active || f.userData.caught) continue;
      f.position.x += f.userData.dir * f.userData.speed * dt;
      f.position.y += Math.sin(globalTime*1.8 + f.userData.phase) * 0.02;
      if (f.position.x > world.maxHorizontal) {
        f.position.x = world.maxHorizontal;
        f.userData.dir *= -1;
        f.rotation.y = f.userData.dir > 0 ? Math.PI : 0;
      }
      if (f.position.x < -world.maxHorizontal) {
        f.position.x = -world.maxHorizontal;
        f.userData.dir *= -1;
        f.rotation.y = f.userData.dir > 0 ? Math.PI : 0;
      }
    }

    // Attach caught fish to hook
    if (roundData.fishCaught.length > 0 && (roundData.hookPhase === 'ascending' || roundData.hookPhase === 'summary')) {
      for (let i=0; i<roundData.fishCaught.length; i++) {
        const f = roundData.fishCaught[i];
        const ox = f.userData.hookOffsetX || 0;
        const oy = f.userData.hookOffsetY || 0;
        const bob = Math.sin(globalTime*6 + i) * 0.05;
        f.position.set(hookX + ox, hookY + oy + bob, 0);
        f.rotation.y = 0;
      }
    }
  }

  function render() {
    renderer.render(scene, camera);
  }

  function gameLoop(timestamp) {
    const dt = Math.min((timestamp - lastTime)/1000, 0.033);
    lastTime = timestamp;

    if (currentState !== GameState.LOADING) {
      update(dt);
    }

    render();
    requestAnimationFrame(gameLoop);
  }

  // --- Resize ---
  function onResize() {
    if (!renderer || !camera) return;
    const w = window.innerWidth;
    const h = window.innerHeight;
    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize);

  // --- Init ---
  function init() {
    setupThree();
    setupInput();
    updateUpgradeButtons();
    coinValueEl.textContent = String(player.coins);
    changeState(GameState.TUTORIAL);
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  }

  init();
})();
</script>
</body>
</html>