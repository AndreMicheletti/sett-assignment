<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Fishing Mini Game</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #021018;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      touch-action: none;
    }
    #gameRoot {
      position: fixed;
      inset: 0;
      overflow: hidden;
      background: radial-gradient(circle at 50% -10%, #4fd5ff 0, #003457 40%, #010812 100%);
    }
    canvas {
      position: absolute;
      inset: 0;
      display: block;
    }
    #threeContainer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
<div id="gameRoot">
  <div id="threeContainer"></div>
  <canvas id="uiCanvas"></canvas>
</div>

  <script src="https://cdn.jsdelivr.net/npm/three-js@79.0.0/three.min.js"></script>

<script>
/* ---------- Constants ---------- */
const GameStates = {
  LOADING: 'loading',
  GAMEPLAY: 'gameplay',
  ENDCARD: 'endcard',
};

const GameplaySubStates = {
  UPGRADE_MENU: 'upgrade_menu',
  GAUGE_SELECT: 'gauge_select',
  DESCENT: 'descent',
  PAUSE_AT_DEPTH: 'pause_at_depth',
  ASCENT: 'ascent',
  SURFACE_SUMMARY: 'surface_summary',
  ROUND_TRANSITION: 'round_transition'
};

const VIRTUAL_WIDTH = 720;
const VIRTUAL_HEIGHT = 1280;

/* ---------- Global Game Data ---------- */
const game = {
  state: GameStates.LOADING,
  subState: null,
  round: 1,
  maxRounds: 3,
  time: 0,
  deltaTime: 0,
  lastTimestamp: 0,
  coins: 100,
  coinsDisplay: 100,
  maxFishCapacity: 6,
  maxDepthLevelIndex: 0,
  maxFishLevelIndex: 0,
  selectedDepth: 0,
  currentCatch: [],
  caughtCount: 0,
  tutorialShown: false,
  pauseTimer: 0,
  surfaceSummaryTimer: 0,
  roundTotalCoins: 0,
  layout: {
    scale: 1,
    offsetX: 0,
    offsetY: 0
  }
};

const maxFishLevels = [
  { capacity: 6, cost: null },
  { capacity: 7, cost: 50 },
  { capacity: 8, cost: 100 },
  { capacity: 9, cost: 200 },
  { capacity: 10, cost: 400 }
];

const depthLevels = [
  { depth: 5, cost: null },
  { depth: 10, cost: 50 },
  { depth: 15, cost: 75 },
  { depth: 20, cost: 150 },
  { depth: 30, cost: 300 }
];

const fishTypes = [
  { type: 'common', value: 10, color: 0x4caf50 },
  { type: 'uncommon', value: 20, color: 0x03a9f4 },
  { type: 'rare', value: 40, color: 0xffc107 },
  { type: 'epic', value: 80, color: 0xe91e63 }
];

const gauge = {
  active: false,
  pointerPos: 0,
  direction: 1,
  speed: 0.8
};

const hook = {
  mesh: null,
  group: null,
  worldY: 0,
  worldX: 0,
  speedY: 0,
  targetDepth: 0,
  direction: 1,
  maxSpeedUp: 0.25,
  normalSpeed: 5,
  fastSpeed: 10,
  line: null,
};

const uiButtons = {
  upgradeMaxFish: { x:0, y:0, w:0, h:0 },
  upgradeMaxDepth: { x:0, y:0, w:0, h:0 },
  playGaugeButton: { x:0, y:0, w:0, h:0 },
  installCTA: { x:0, y:0, w:0, h:0 },
};

let fishList = [];
const floatingTexts = [];

/* ---------- Three.js Setup ---------- */
let scene, camera, renderer;
let threeContainer, uiCanvas, uiCtx;

let worldMinX = -6;
let worldMaxX = 6;
let worldMinY = -1;
let worldMaxY = 35;

function initThree() {
  threeContainer = document.getElementById('threeContainer');
  const w = window.innerWidth;
  const h = window.innerHeight;

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x001019, 0.03);

  camera = new THREE.PerspectiveCamera(55, w / h, 0.1, 200);
  camera.position.set(0, 5, 20);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(w, h);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setClearColor(0x001018, 1);
  threeContainer.appendChild(renderer.domElement);

  const hemiLight = new THREE.HemisphereLight(0x66ccff, 0x00334d, 0.9);
  hemiLight.position.set(0, 20, 0);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
  dirLight.position.set(10, 20, 10);
  scene.add(dirLight);

  createBoatAndFisherman();
  createHook();
}

/* ---------- Scene Creation ---------- */
function createBoatAndFisherman() {
  const boatGroup = new THREE.Group();

  const boatGeom = new THREE.BoxGeometry(8, 1, 3);
  const boatMat = new THREE.MeshStandardMaterial({ color: 0x4e342e, metalness: 0.0, roughness: 0.9 });
  const boat = new THREE.Mesh(boatGeom, boatMat);
  boat.castShadow = true;
  boat.receiveShadow = true;
  boatGroup.add(boat);

  const hullGeom = new THREE.CylinderGeometry(0.1, 3.5, 1.5, 5, 1);
  const hull = new THREE.Mesh(hullGeom, boatMat);
  hull.position.y = -1;
  hull.rotation.z = Math.PI;
  boatGroup.add(hull);

  const bodyGeom = new THREE.BoxGeometry(1, 1.6, 1);
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1565c0 });
  const body = new THREE.Mesh(bodyGeom, bodyMat);
  body.position.set(-1, 1.3, 0);
  boatGroup.add(body);

  const headGeom = new THREE.BoxGeometry(0.9, 0.9, 0.9);
  const headMat = new THREE.MeshStandardMaterial({ color: 0xffcc80 });
  const head = new THREE.Mesh(headGeom, headMat);
  head.position.set(-1, 2.3, 0);
  boatGroup.add(head);

  const rodGeom = new THREE.CylinderGeometry(0.05, 0.05, 5, 6);
  const rodMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
  const rod = new THREE.Mesh(rodGeom, rodMat);
  rod.position.set(-2.5, 2.5, 0);
  rod.rotation.z = -Math.PI / 4;
  boatGroup.add(rod);

  boatGroup.position.set(0, 0, 0);
  scene.add(boatGroup);
}

function createHook() {
  const hookGroup = new THREE.Group();

  const hookGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.9, 8);
  const hookMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.7, roughness: 0.3 });
  const hookMesh = new THREE.Mesh(hookGeom, hookMat);
  hookMesh.position.set(0, -0.5, 0);
  hookGroup.add(hookMesh);

  const curveRadius = 0.35;
  const curveGeom = new THREE.TorusGeometry(curveRadius, 0.06, 8, 16, Math.PI * 0.8);
  const curve = new THREE.Mesh(curveGeom, hookMat);
  curve.rotation.z = Math.PI / 2;
  curve.position.set(0, -1, 0);
  hookGroup.add(curve);

  const lineGeom = new THREE.CylinderGeometry(0.02, 0.02, 40, 6);
  const lineMat = new THREE.MeshStandardMaterial({ color: 0xbbdefb });
  const line = new THREE.Mesh(lineGeom, lineMat);
  line.position.set(0, 20, 0);
  hookGroup.add(line);

  hookGroup.position.set(0, -2, 0);
  scene.add(hookGroup);

  hook.group = hookGroup;
  hook.mesh = hookMesh;
  hook.line = line;
  hook.worldX = 0;
  hook.worldY = 2;
}

/* ---------- Fish Creation ---------- */
function createFishForRound() {
  fishList.forEach(f => {
    if (f.mesh && f.mesh.parent) f.mesh.parent.remove(f.mesh);
  });
  fishList = [];

  const depthLevel = depthLevels[game.maxDepthLevelIndex];
  const maxDepth = depthLevel.depth;
  const fishCount = 12 + game.round * 3;

  for (let i = 0; i < fishCount; i++) {
    const depth = 2 + Math.random() * (maxDepth - 1);
    const typeRoll = Math.random();
    let typeDef;
    if (typeRoll < 0.6) typeDef = fishTypes[0];
    else if (typeRoll < 0.85) typeDef = fishTypes[1];
    else if (typeRoll < 0.97) typeDef = fishTypes[2];
    else typeDef = fishTypes[3];

    const fish = createSingleFish(typeDef, depth);
    fishList.push(fish);
  }
}

function createSingleFish(typeDef, depth) {
  const length = 1.1;
  const height = 0.5;
  const width = 0.4;

  const bodyGeom = new THREE.BoxGeometry(length, height, width);
  const bodyMat = new THREE.MeshStandardMaterial({ color: typeDef.color, metalness: 0.1, roughness: 0.6 });
  const body = new THREE.Mesh(bodyGeom, bodyMat);

  const tailGeom = new THREE.ConeGeometry(0.35, 0.6, 4);
  const tailMat = new THREE.MeshStandardMaterial({ color: typeDef.color });
  const tail = new THREE.Mesh(tailGeom, tailMat);
  tail.rotation.z = Math.PI;
  tail.position.set(-length / 2 - 0.25, 0, 0);

  const fishGroup = new THREE.Group();
  fishGroup.add(body);
  fishGroup.add(tail);

  const x = worldMinX + 1 + Math.random() * (worldMaxX - worldMinX - 2);
  const y = depth;
  const z = -4 + Math.random() * 2;

  fishGroup.position.set(x, -y, z);
  scene.add(fishGroup);

  return {
    id: Math.random().toString(36).slice(2),
    type: typeDef.type,
    value: typeDef.value,
    depth: depth,
    position: { x, y, z },
    mesh: fishGroup,
    caught: false,
    offset: Math.random() * Math.PI * 2
  };
}

/* ---------- UI / Canvas Setup ---------- */
function initCanvas() {
  uiCanvas = document.getElementById('uiCanvas');
  uiCtx = uiCanvas.getContext('2d');
  resize();
}

/* ---------- Resize Handling ---------- */
function resize() {
  const w = window.innerWidth;
  const h = window.innerHeight;

  if (renderer && camera) {
    renderer.setSize(w, h);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }

  uiCanvas.width = w * (window.devicePixelRatio || 1);
  uiCanvas.height = h * (window.devicePixelRatio || 1);
  uiCtx.setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);

  const scale = Math.min(w / VIRTUAL_WIDTH, h / VIRTUAL_HEIGHT);
  const offsetX = (w - VIRTUAL_WIDTH * scale) / 2;
  const offsetY = (h - VIRTUAL_HEIGHT * scale) / 2;
  game.layout.scale = scale;
  game.layout.offsetX = offsetX;
  game.layout.offsetY = offsetY;

  const bottomY = VIRTUAL_HEIGHT * 0.78;
  const btnW = 260;
  const btnH = 80;
  const gap = 20;

  uiButtons.upgradeMaxFish = {
    x: VIRTUAL_WIDTH * 0.5 - btnW - gap * 0.5,
    y: bottomY,
    w: btnW,
    h: btnH
  };
  uiButtons.upgradeMaxDepth = {
    x: VIRTUAL_WIDTH * 0.5 + gap * 0.5,
    y: bottomY,
    w: btnW,
    h: btnH
  };

  uiButtons.playGaugeButton = {
    x: VIRTUAL_WIDTH * 0.5 - 180,
    y: bottomY + btnH + 40,
    w: 360,
    h: 90
  };

  uiButtons.installCTA = {
    x: VIRTUAL_WIDTH * 0.5 - 180,
    y: VIRTUAL_HEIGHT * 0.78,
    w: 360,
    h: 100
  };
}

/* ---------- Utility ---------- */
function toVirtual(x, y) {
  const s = game.layout.scale;
  const ox = game.layout.offsetX;
  const oy = game.layout.offsetY;
  return {
    x: (x - ox) / s,
    y: (y - oy) / s
  };
}

function isInsideButton(vx, vy, btn) {
  return vx >= btn.x && vx <= btn.x + btn.w && vy >= btn.y && vy <= btn.y + btn.h;
}

function clamp(v, min, max) {
  return v < min ? min : v > max ? max : v;
}

/* ---------- Input Handling ---------- */
let pointerDown = false;

function onPointerDown(e) {
  if (e.cancelable) e.preventDefault();
  pointerDown = true;
  const p = getEventPos(e);
  handlePointerDown(p.x, p.y);
}

function onPointerMove(e) {
  if (e.cancelable) e.preventDefault();
  const p = getEventPos(e);
  handlePointerMove(p.x, p.y);
}

function onPointerUp(e) {
  if (e.cancelable) e.preventDefault();
  pointerDown = false;
  const p = getEventPos(e);
  handlePointerUp(p.x, p.y);
}

function getEventPos(e) {
  if (e.touches && e.touches.length > 0) {
    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
  if (e.changedTouches && e.changedTouches.length > 0) {
    return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
  }
  return { x: e.clientX, y: e.clientY };
}

/* ---------- Game-specific Input ---------- */
function handlePointerDown(x, y) {
  const v = toVirtual(x, y);

  if (game.state === GameStates.GAMEPLAY) {
    switch (game.subState) {
      case GameplaySubStates.UPGRADE_MENU:
        if (isInsideButton(v.x, v.y, uiButtons.upgradeMaxFish)) {
          buyMaxFishUpgrade();
        } else if (isInsideButton(v.x, v.y, uiButtons.upgradeMaxDepth)) {
          buyDepthUpgrade();
        } else if (isInsideButton(v.x, v.y, uiButtons.playGaugeButton)) {
          startGauge();
        }
        break;
      case GameplaySubStates.GAUGE_SELECT:
        finishGaugeAndStartDescent();
        break;
      case GameplaySubStates.SURFACE_SUMMARY:
        game.surfaceSummaryTimer = 9999;
        break;
      case GameplaySubStates.ROUND_TRANSITION:
        if (game.round <= game.maxRounds) {
          startUpgradeMenuForRound();
        }
        break;
      case GameplaySubStates.ASCENT:
        handleHookHorizontalControl(v.x);
        break;
    }
  } else if (game.state === GameStates.ENDCARD) {
    if (isInsideButton(v.x, v.y, uiButtons.installCTA)) {
      window.open('https://example.com', '_blank');
    }
  }
}

function handlePointerMove(x, y) {
  const v = toVirtual(x, y);
  if (game.state === GameStates.GAMEPLAY && game.subState === GameplaySubStates.ASCENT && pointerDown) {
    handleHookHorizontalControl(v.x);
  }
}

function handlePointerUp(x, y) {
  const v = toVirtual(x, y);
  if (game.state === GameStates.GAMEPLAY && game.subState === GameplaySubStates.GAUGE_SELECT) {
    finishGaugeAndStartDescent();
  }
}

/* ---------- Upgrade & Gauge Logic ---------- */
function buyMaxFishUpgrade() {
  const nextIndex = game.maxFishLevelIndex + 1;
  if (nextIndex >= maxFishLevels.length) return;
  const level = maxFishLevels[nextIndex];
  if (level.cost != null && game.coins >= level.cost) {
    game.coins -= level.cost;
    game.maxFishLevelIndex = nextIndex;
    game.maxFishCapacity = level.capacity;
  }
}

function buyDepthUpgrade() {
  const nextIndex = game.maxDepthLevelIndex + 1;
  if (nextIndex >= depthLevels.length) return;
  const level = depthLevels[nextIndex];
  if (level.cost != null && game.coins >= level.cost) {
    game.coins -= level.cost;
    game.maxDepthLevelIndex = nextIndex;
  }
}

function startGauge() {
  game.subState = GameplaySubStates.GAUGE_SELECT;
  gauge.active = true;
  gauge.pointerPos = 0;
  gauge.direction = 1;
}

function finishGaugeAndStartDescent() {
  if (!gauge.active) return;
  gauge.active = false;
  const depthLevel = depthLevels[game.maxDepthLevelIndex];
  const maxDepth = depthLevel.depth;
  const minDepth = Math.max(1, maxDepth - 3);
  const t = gauge.pointerPos;
  game.selectedDepth = minDepth + t * (maxDepth - minDepth);
  hook.targetDepth = game.selectedDepth;
  hook.worldY = 0;
  hook.direction = 1;
  game.caughtCount = 0;
  game.currentCatch = [];
  game.subState = GameplaySubStates.DESCENT;
}

function handleHookHorizontalControl(vx) {
  const marginLeft = 60;
  const marginRight = VIRTUAL_WIDTH - 60;
  const norm = clamp((vx - marginLeft) / (marginRight - marginLeft), 0, 1);
  hook.worldX = worldMinX + norm * (worldMaxX - worldMinX);
}

/* ---------- Hook & Fish Collision ---------- */
function checkHookFishCollision(hookObj, fish) {
  const hx = hookObj.group.position.x;
  const hy = hookObj.group.position.y;
  const fx = fish.mesh.position.x;
  const fy = fish.mesh.position.y;
  const dz = fish.mesh.position.z;
  if (Math.abs(dz) > 1.5) return false;
  const dx = hx - fx;
  const dy = hy - fy;
  const distSq = dx*dx + dy*dy;
  const radius = 0.7;
  return distSq < radius * radius;
}

function catchFish(fish) {
  fish.caught = true;
  game.caughtCount++;
  game.currentCatch.push(fish);

  const localPos = fish.mesh.position.clone().sub(hook.group.position);
  hook.group.add(fish.mesh);
  fish.mesh.position.copy(localPos);

  const screenPos = worldToVirtualScreen(hook.group.position.x, hook.group.position.y);
  floatingTexts.push({
    text: `+${fish.value}`,
    x: screenPos.x,
    y: screenPos.y,
    life: 0,
    maxLife: 1,
    color: '#ffd54f'
  });

  game.roundTotalCoins += fish.value;

  if (game.caughtCount >= game.maxFishCapacity) {
    hook.speedY = hook.fastSpeed;
  }
}

function worldToVirtualScreen(wx, wy) {
  const w = window.innerWidth;
  const h = window.innerHeight;
  const v = new THREE.Vector3(wx, wy, 0);
  v.project(camera);
  const sx = (v.x * 0.5 + 0.5) * w;
  const sy = ( -v.y * 0.5 + 0.5) * h;
  const vv = toVirtual(sx, sy);
  return vv;
}

/* ---------- Update Loop ---------- */
function update(dt) {
  game.time += dt;
  if (game.state === GameStates.GAMEPLAY) {
    updateGameplay(dt);
  } else if (game.state === GameStates.ENDCARD) {
    // idle
  }

  game.coinsDisplay += (game.coins - game.coinsDisplay) * Math.min(dt * 5, 1);

  updateFishIdle(dt);
  updateFloatingTexts(dt);
  updateCamera(dt);
}

function updateGameplay(dt) {
  switch (game.subState) {
    case GameplaySubStates.UPGRADE_MENU:
      break;
    case GameplaySubStates.GAUGE_SELECT:
      updateGauge(dt);
      break;
    case GameplaySubStates.DESCENT:
      updateDescent(dt);
      break;
    case GameplaySubStates.PAUSE_AT_DEPTH:
      updatePauseAtDepth(dt);
      break;
    case GameplaySubStates.ASCENT:
      updateAscent(dt);
      break;
    case GameplaySubStates.SURFACE_SUMMARY:
      updateSurfaceSummary(dt);
      break;
    case GameplaySubStates.ROUND_TRANSITION:
      break;
  }
}

function updateGauge(dt) {
  if (!gauge.active) return;
  let p = gauge.pointerPos;
  p += gauge.direction * gauge.speed * dt;
  if (p > 1) { p = 1; gauge.direction = -1; }
  if (p < 0) { p = 0; gauge.direction = 1; }
  gauge.pointerPos = p;
}

function updateDescent(dt) {
  hook.speedY = hook.normalSpeed;
  hook.worldY += hook.speedY * dt;
  if (hook.worldY >= hook.targetDepth) {
    hook.worldY = hook.targetDepth;
    game.subState = GameplaySubStates.PAUSE_AT_DEPTH;
    game.pauseTimer = 0;
  }
  syncHookPosition();
}

function updatePauseAtDepth(dt) {
  game.pauseTimer += dt;
  const tutorialDuration = game.tutorialShown ? 0.8 : 2.3;
  if (game.pauseTimer > tutorialDuration) {
    game.tutorialShown = true;
    game.subState = GameplaySubStates.ASCENT;
    hook.direction = -1;
  }
  syncHookPosition();
}

function updateAscent(dt) {
  const speed = (game.caughtCount >= game.maxFishCapacity) ? hook.fastSpeed : hook.normalSpeed;
  hook.speedY = speed;
  hook.worldY -= speed * dt;
  if (hook.worldY <= 0) {
    hook.worldY = 0;
    syncHookPosition();
    prepareSurfaceSummary();
    game.subState = GameplaySubStates.SURFACE_SUMMARY;
    return;
  }

  syncHookPosition();

  if (game.caughtCount < game.maxFishCapacity) {
    for (const fish of fishList) {
      if (fish.caught) continue;
      if (checkHookFishCollision(hook, fish)) {
        catchFish(fish);
        if (game.caughtCount >= game.maxFishCapacity) break;
      }
    }
  }
}

function updateSurfaceSummary(dt) {
  game.surfaceSummaryTimer += dt;
  if (game.surfaceSummaryTimer > 2) {
    endRoundAndTransition();
  }
}

function updateFishIdle(dt) {
  for (const fish of fishList) {
    if (!fish.mesh || fish.caught) continue;
    const t = game.time * 1.2 + fish.offset;
    fish.mesh.position.x += Math.sin(t) * 0.02;
  }
}

function updateFloatingTexts(dt) {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const f = floatingTexts[i];
    f.life += dt;
    f.y -= 40 * dt;
    if (f.life >= f.maxLife) {
      floatingTexts.splice(i, 1);
    }
  }
}

function updateCamera(dt) {
  const targetY = -hook.worldY + 6;
  camera.position.y += (targetY - camera.position.y) * 0.15;
  camera.position.y = clamp(camera.position.y, -worldMaxY, 8);
  camera.lookAt(new THREE.Vector3(0, camera.position.y - 4, 0));
}

function syncHookPosition() {
  hook.group.position.x = hook.worldX;
  hook.group.position.y = -hook.worldY;
}

/* ---------- Round & Summary ---------- */
function prepareSurfaceSummary() {
  game.surfaceSummaryTimer = 0;
}

function endRoundAndTransition() {
  game.coins += game.roundTotalCoins;
  game.roundTotalCoins = 0;
  game.round++;
  if (game.round > game.maxRounds) {
    game.state = GameStates.ENDCARD;
  } else {
    game.subState = GameplaySubStates.ROUND_TRANSITION;
    startUpgradeMenuForRound();
  }
}

function startUpgradeMenuForRound() {
  createFishForRound();
  hook.worldY = 2;
  hook.worldX = 0;
  syncHookPosition();
  game.currentCatch = [];
  game.caughtCount = 0;
  game.roundTotalCoins = 0;
  game.subState = GameplaySubStates.UPGRADE_MENU;
}

/* ---------- Rendering ---------- */
function render() {
  renderer.render(scene, camera);
  drawUI();
}

function drawUI() {
  const ctx = uiCtx;
  const w = window.innerWidth;
  const h = window.innerHeight;
  ctx.clearRect(0, 0, w, h);

  ctx.save();
  const s = game.layout.scale;
  const ox = game.layout.offsetX;
  const oy = game.layout.offsetY;
  ctx.translate(ox, oy);
  ctx.scale(s, s);

  drawTopHUD(ctx);

  if (game.state === GameStates.GAMEPLAY) {
    if (game.subState === GameplaySubStates.UPGRADE_MENU) {
      drawUpgradeMenu(ctx);
    } else if (game.subState === GameplaySubStates.GAUGE_SELECT) {
      drawGaugeUI(ctx);
    } else if (game.subState === GameplaySubStates.PAUSE_AT_DEPTH && !game.tutorialShown) {
      drawTutorialOverlay(ctx);
    } else if (game.subState === GameplaySubStates.SURFACE_SUMMARY) {
      drawSurfaceSummary(ctx);
    }
  } else if (game.state === GameStates.ENDCARD) {
    drawEndcard(ctx);
  }

  drawFloatingTextsUI(ctx);
  drawSoftCTA(ctx);

  ctx.restore();
}

function drawTopHUD(ctx) {
  const pad = 20;
  const barH = 70;
  const x = pad;
  const y = pad;

  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  roundRect(ctx, x, y, 220, barH, 18, true, false);

  ctx.fillStyle = '#ffd54f';
  ctx.beginPath();
  ctx.arc(x + 30, y + barH / 2, 16, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#f57f17';
  ctx.font = 'bold 20px system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('C', x + 30, y + barH / 2 + 1);

  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 24px system-ui';
  ctx.textAlign = 'left';
  ctx.fillText(Math.floor(game.coinsDisplay).toString(), x + 60, y + barH / 2 + 2);

  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  const rx = VIRTUAL_WIDTH - pad - 180;
  roundRect(ctx, rx, y, 180, barH, 18, true, false);
  ctx.fillStyle = '#80deea';
  ctx.font = 'bold 20px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText(`Round ${Math.min(game.round, game.maxRounds)}/${game.maxRounds}`, rx + 90, y + barH / 2 + 2);

  ctx.restore();
}

function drawUpgradeMenu(ctx) {
  ctx.save();

  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  roundRect(ctx, 40, 160, VIRTUAL_WIDTH - 80, 140, 24, true, false);

  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 32px system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Upgrade your gear', VIRTUAL_WIDTH / 2, 200);

  ctx.font = '20px system-ui';
  ctx.fillStyle = '#b0bec5';
  ctx.fillText('Spend coins to catch more fish & go deeper', VIRTUAL_WIDTH / 2, 238);

  drawButton(ctx, uiButtons.upgradeMaxFish, {
    label: `Max Fish: ${maxFishLevels[game.maxFishLevelIndex].capacity}` +
      (game.maxFishLevelIndex + 1 < maxFishLevels.length ? ` → ${maxFishLevels[game.maxFishLevelIndex + 1].capacity}` : ' (MAX)'),
    cost: maxFishLevels[game.maxFishLevelIndex + 1]?.cost ?? null
  });

  const depthLevel = depthLevels[game.maxDepthLevelIndex];
  drawButton(ctx, uiButtons.upgradeMaxDepth, {
    label: `Max Depth: ${depthLevel.depth}m` +
      (game.maxDepthLevelIndex + 1 < depthLevels.length ? ` → ${depthLevels[game.maxDepthLevelIndex + 1].depth}m` : ' (MAX)'),
    cost: depthLevels[game.maxDepthLevelIndex + 1]?.cost ?? null
  });

  drawButton(ctx, uiButtons.playGaugeButton, {
    label: 'Cast Line',
    primary: true
  });

  ctx.restore();
}

function drawGaugeUI(ctx) {
  const barW = VIRTUAL_WIDTH * 0.7;
  const barH = 22;
  const x = (VIRTUAL_WIDTH - barW) / 2;
  const y = VIRTUAL_HEIGHT * 0.78;

  ctx.save();

  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  roundRect(ctx, x - 20, y - 60, barW + 40, 140, 20, true, false);

  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 26px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('Tap to set depth', VIRTUAL_WIDTH / 2, y - 25);

  ctx.fillStyle = '#263238';
  roundRect(ctx, x, y, barW, barH, 12, true, false);

  const depthLevel = depthLevels[game.maxDepthLevelIndex];
  const maxDepth = depthLevel.depth;
  const minDepth = Math.max(1, maxDepth - 3);
  const t = gauge.pointerPos;
  const currentDepth = minDepth + t * (maxDepth - minDepth);
  const normPos = t;
  const px = x + normPos * barW;

  const grd = ctx.createLinearGradient(x, 0, x + barW, 0);
  grd.addColorStop(0, '#4fc3f7');
  grd.addColorStop(0.5, '#ffeb3b');
  grd.addColorStop(1, '#ff7043');
  ctx.fillStyle = grd;
  roundRect(ctx, x + 2, y + 4, barW - 4, barH - 8, 10, true, false);

  ctx.beginPath();
  ctx.moveTo(px, y + barH + 5);
  ctx.lineTo(px - 12, y + barH + 35);
  ctx.lineTo(px + 12, y + barH + 35);
  ctx.closePath();
  ctx.fillStyle = '#ffffff';
  ctx.fill();

  ctx.fillStyle = '#ffffff';
  ctx.font = '20px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText(`~${currentDepth.toFixed(1)}m`, VIRTUAL_WIDTH / 2, y + barH + 60);

  ctx.restore();
}

function drawTutorialOverlay(ctx) {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  roundRect(ctx, 80, VIRTUAL_HEIGHT * 0.58, VIRTUAL_WIDTH - 160, 140, 24, true, false);

  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 26px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('Drag to move the hook', VIRTUAL_WIDTH / 2, VIRTUAL_HEIGHT * 0.62);

  ctx.font = '20px system-ui';
  ctx.fillStyle = '#cfd8dc';
  ctx.fillText('Weave through fish as you rise to the surface', VIRTUAL_WIDTH / 2, VIRTUAL_HEIGHT * 0.66);

  ctx.restore();
}

function drawSurfaceSummary(ctx) {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  roundRect(ctx, 80, VIRTUAL_HEIGHT * 0.2, VIRTUAL_WIDTH - 160, 260, 24, true, false);

  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 30px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('Catch Summary', VIRTUAL_WIDTH / 2, VIRTUAL_HEIGHT * 0.24);

  ctx.font = '22px system-ui';
  ctx.fillStyle = '#b0bec5';
  ctx.fillText(`${game.caughtCount} fish caught`, VIRTUAL_WIDTH / 2, VIRTUAL_HEIGHT * 0.29);

  ctx.font = '24px system-ui';
  ctx.fillStyle = '#ffd54f';
  ctx.fillText(`+${game.roundTotalCoins} coins`, VIRTUAL_WIDTH / 2, VIRTUAL_HEIGHT * 0.35);

  ctx.font = '18px system-ui';
  ctx.fillStyle = '#90a4ae';
  ctx.fillText('Tap to skip', VIRTUAL_WIDTH / 2, VIRTUAL_HEIGHT * 0.41);

  ctx.restore();
}

function drawEndcard(ctx) {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  roundRect(ctx, 60, 200, VIRTUAL_WIDTH - 120, 260, 30, true, false);

  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 34px system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Nice haul!', VIRTUAL_WIDTH / 2, 240);

  ctx.font = '22px system-ui';
  ctx.fillStyle = '#cfd8dc';
  ctx.fillText(`You earned ${Math.floor(game.coins)} coins`, VIRTUAL_WIDTH / 2, 280);

  ctx.font = '18px system-ui';
  ctx.fillStyle = '#90a4ae';
  ctx.fillText('Upgrade, cast, and catch even rarer fish in the full game.', VIRTUAL_WIDTH / 2, 320);

  drawButton(ctx, uiButtons.installCTA, {
    label: 'Install',
    primary: true,
    big: true
  });

  ctx.restore();
}

function drawSoftCTA(ctx) {
  ctx.save();
  const size = 54;
  const pad = 20;
  const x = VIRTUAL_WIDTH - size - pad;
  const y = VIRTUAL_HEIGHT - size - pad;

  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  roundRect(ctx, x, y, size, size, 18, true, false);

  ctx.strokeStyle = '#80deea';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(x + size/2, y + size/2, 16, 0, Math.PI * 2);
  ctx.stroke();

  ctx.fillStyle = '#80deea';
  ctx.font = 'bold 14px system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('Ad', x + size/2, y + size/2);
  ctx.restore();
}

function drawFloatingTextsUI(ctx) {
  ctx.save();
  for (const f of floatingTexts) {
    const alpha = 1 - (f.life / f.maxLife);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = f.color;
    ctx.font = 'bold 22px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(f.text, f.x, f.y);
  }
  ctx.restore();
}

function drawButton(ctx, btn, opts) {
  const primary = !!opts.primary;
  const big = !!opts.big;
  ctx.save();
  const radius = 22;
  if (primary) {
    const grd = ctx.createLinearGradient(btn.x, btn.y, btn.x, btn.y + btn.h);
    grd.addColorStop(0, '#ffb74d');
    grd.addColorStop(1, '#f57c00');
    ctx.fillStyle = grd;
  } else {
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
  }
  roundRect(ctx, btn.x, btn.y, btn.w, btn.h, radius, true, false);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#ffffff';
  ctx.font = (big ? 'bold 30px system-ui' : 'bold 22px system-ui');

  const centerY = btn.y + btn.h / 3;
  ctx.fillText(opts.label, btn.x + btn.w / 2, centerY + 2);

  if (opts.cost != null) {
    ctx.font = '18px system-ui';
    ctx.fillStyle = '#ffd54f';
    ctx.fillText(`${opts.cost} coins`, btn.x + btn.w / 2, btn.y + btn.h * 0.7);
  }

  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

/* ---------- Main Loop ---------- */
function gameLoop(timestamp) {
  if (!game.lastTimestamp) game.lastTimestamp = timestamp;
  const dt = (timestamp - game.lastTimestamp) / 1000;
  game.lastTimestamp = timestamp;

  update(dt);
  render();

  requestAnimationFrame(gameLoop);
}

/* ---------- Init ---------- */
function init() {
  initThree();
  initCanvas();
  window.addEventListener('resize', resize);
  uiCanvas.addEventListener('mousedown', onPointerDown);
  uiCanvas.addEventListener('mousemove', onPointerMove);
  window.addEventListener('mouseup', onPointerUp);
  uiCanvas.addEventListener('touchstart', onPointerDown, { passive: false });
  uiCanvas.addEventListener('touchmove', onPointerMove, { passive: false });
  uiCanvas.addEventListener('touchend', onPointerUp, { passive: false });

  game.state = GameStates.GAMEPLAY;
  game.subState = GameplaySubStates.UPGRADE_MENU;
  createFishForRound();
  hook.worldY = 2;
  hook.worldX = 0;
  syncHookPosition();

  requestAnimationFrame(gameLoop);
}

window.addEventListener('load', init);
</script>
</body>
</html>