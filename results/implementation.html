<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Deep Sea Fortune - Fishing Mini Game</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #02101f;
    touch-action: none;
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    background: #02101f;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
(function () {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // --------- CONSTANTS ----------
  const REF_W = 720;
  const REF_H = 1280;

  const MaxFishUpgradeSteps = [
    { cap: 6,  cost: 0 },
    { cap: 7,  cost: 50 },
    { cap: 8,  cost: 100 },
    { cap: 9,  cost: 200 },
    { cap: 10, cost: 400 },
  ];

  const MaxDepthUpgradeSteps = [
    { depth: 5,  cost: 0 },
    { depth: 10, cost: 50 },
    { depth: 15, cost: 75 },
    { depth: 20, cost: 150 },
    { depth: 30, cost: 300 },
  ];

  const FishTypes = [
    { name: 'Common',    key:'common',    color:'#4fc3f7', value: 5,  label:'' },
    { name: 'Uncommon',  key:'uncommon',  color:'#81c784', value: 12, label:'Nice!' },
    { name: 'Rare',      key:'rare',      color:'#ffb74d', value: 25, label:'Rare!' },
    { name: 'Epic',      key:'epic',      color:'#ba68c8', value: 50, label:'Epic!' },
    { name: 'Legendary', key:'legendary', color:'#ff5252', value: 120,label:'Legendary!' },
  ];

  const GameState = {
    currentState: 'LOADING', // 'GAMEPLAY','ENDCARD'
    gameplayStage: null,
    roundIndex: 0, // 0..2
    totalRounds: 3,
    coins: 100,
    displayCoins: 100, // for smooth tween
    maxFishCapacity: 6,
    maxDepth: 5,
    purchasedMaxFishLevel: 0,
    purchasedMaxDepthLevel: 0,
    world: {
      width: 0,
      height: 0,
      scale: 1,
      surfaceY: 0,
      bottomY: 0,
      cameraY: 0
    },
    input: {
      isDown: false,
      lastX: 0,
      x: 0,
      justTapped: false,
      tapX: 0,
      tapY: 0,
    },
    hook: {
      x: 0,
      y: 0,
      radius: 12,
      depthM: 0,
      targetDepth: 5,
      vx: 0,
    },
    fish: [],
    caughtFish: [],
    floatingTexts: [],
    coinsFlying: [],
    ui: {
      coinCounter: { x:0,y:0,w:0,h:0,visible:true },
      fishCounter: { x:0,y:0,w:0,h:0,visible:false,value:0,maxValue:6 },
      playButton: { x:0,y:0,width:0,height:0,visible:true },
      gaugeBar: { x:0,y:0,width:0,height:0,visible:false },
      upgradeButtons: {
        maxFish: { x:0,y:0,width:0,height:0,enabled:true },
        maxDepth: { x:0,y:0,width:0,height:0,enabled:true },
      },
      ctaButton: { x:0,y:0,width:0,height:0,visible:false },
      tutorialLabel: { visible:false, text:'Drag to move the hook and catch fish!' },
    },
    gauge: {
      t: 0,
      period: 2000,
      value: 0,
      isRunning: false,
    },
    pendingGaugeStop: false,
    hookPauseTimer: 0,
    hookAscentSpeed: 18,
    isTutorialShown: false,
    roundSummary: {
      stage: 0, // 0 idle,1 anim fish,2 count coins,3 done
      index: 0,
      timer: 0,
      perFishTime: 600,
      totalCoinsThisRound: 0,
      coinsCounted: 0
    }
  };

  // ---------- RESIZE & LAYOUT ----------
  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const rectW = window.innerWidth;
    const rectH = window.innerHeight;
    canvas.width = rectW * dpr;
    canvas.height = rectH * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    GameState.world.width = rectW;
    GameState.world.height = rectH;
    layoutUI();
    resetHookToSurface();
  }

  function layoutUI() {
    const w = GameState.world.width;
    const h = GameState.world.height;
    const scale = Math.min(w / REF_W, h / REF_H);
    GameState.world.scale = scale;

    GameState.world.surfaceY = h * 0.25;
    GameState.world.bottomY = h * 0.9;
    GameState.world.cameraY = 0;

    const ui = GameState.ui;

    ui.coinCounter.w = 160 * scale;
    ui.coinCounter.h = 40 * scale;
    ui.coinCounter.x = w * 0.5 - ui.coinCounter.w/2;
    ui.coinCounter.y = h * 0.05;

    ui.fishCounter.w = 160 * scale;
    ui.fishCounter.h = 40 * scale;
    ui.fishCounter.x = w * 0.5 - ui.fishCounter.w/2;
    ui.fishCounter.y = h * 0.05;

    ui.playButton.width = 220 * scale;
    ui.playButton.height = 80 * scale;
    ui.playButton.x = (w - ui.playButton.width)/2;
    ui.playButton.y = h * 0.75;

    ui.gaugeBar.width = w * 0.6;
    ui.gaugeBar.height = 22 * scale;
    ui.gaugeBar.x = (w - ui.gaugeBar.width)/2;
    ui.gaugeBar.y = ui.playButton.y - 70 * scale;

    const btnW = 190 * scale;
    const btnH = 60 * scale;
    ui.upgradeButtons.maxFish.width = btnW;
    ui.upgradeButtons.maxFish.height = btnH;
    ui.upgradeButtons.maxFish.x = w * 0.08;
    ui.upgradeButtons.maxFish.y = h * 0.85;

    ui.upgradeButtons.maxDepth.width = btnW;
    ui.upgradeButtons.maxDepth.height = btnH;
    ui.upgradeButtons.maxDepth.x = w - w * 0.08 - btnW;
    ui.upgradeButtons.maxDepth.y = h * 0.85;

    ui.ctaButton.width = 260 * scale;
    ui.ctaButton.height = 80 * scale;
    ui.ctaButton.x = (w - ui.ctaButton.width)/2;
    ui.ctaButton.y = h - ui.ctaButton.height - 24 * scale;
  }

  // ---------- HELPERS ----------
  function depthToY(depthM) {
    const maxM = GameState.maxDepth || 1;
    const sY = GameState.world.surfaceY;
    const bY = GameState.world.bottomY;
    const t = Math.max(0, Math.min(1, depthM / maxM));
    return sY + t * (bY - sY);
  }

  function resetHookToSurface() {
    const w = GameState.world.width;
    GameState.hook.x = w * 0.5;
    GameState.hook.depthM = 0;
    GameState.hook.y = depthToY(0);
  }

  function pointInRect(x, y, r) {
    return x >= r.x && x <= r.x + r.width && y >= r.y && y <= r.y + r.height;
  }

  function pickFishTypeForDepth(depthM) {
    const maxD = GameState.maxDepth;
    let probs;
    if (depthM < maxD * 0.3) {
      probs = [0.8, 0.18, 0.02, 0, 0];
    } else if (depthM < maxD * 0.6) {
      probs = [0.5, 0.3, 0.15, 0.05, 0];
    } else {
      probs = [0.25, 0.35, 0.25, 0.1, 0.05];
    }
    const r = Math.random();
    let acc = 0;
    for (let i = 0; i < FishTypes.length; i++) {
      acc += probs[i];
      if (r <= acc) return FishTypes[i];
    }
    return FishTypes[0];
  }

  function spawnFishForRound() {
    GameState.fish.length = 0;
    const w = GameState.world.width;
    const total = 48;
    const lanes = 6;
    for (let i = 0; i < total; i++) {
      const depthM = Math.random() * GameState.maxDepth;
      const type = pickFishTypeForDepth(depthM);
      const lane = (i % lanes) + 0.5;
      const x = (lane / lanes) * w * 0.9 + w * 0.05;
      const y = depthToY(depthM);
      GameState.fish.push({
        x,
        y,
        depthM,
        radius: 14,
        type: type.key,
        color: type.color,
        value: type.value,
        label: type.label,
        caught: false,
        attachOffsetX: 0,
        attachOffsetY: 0,
        wigglePhase: Math.random() * Math.PI * 2
      });
    }
  }

  // ---------- INPUT ----------
  function setupInput() {
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const t = e.changedTouches[0];
      handlePointerDown(t.clientX, t.clientY);
    }, {passive:false});
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      const t = e.changedTouches[0];
      handlePointerMove(t.clientX, t.clientY);
    }, {passive:false});
    canvas.addEventListener('touchend', e => {
      e.preventDefault();
      const t = e.changedTouches[0];
      handlePointerUp(t.clientX, t.clientY);
    });

    canvas.addEventListener('mousedown', e => {
      e.preventDefault();
      handlePointerDown(e.clientX, e.clientY);
    });
    canvas.addEventListener('mousemove', e => {
      e.preventDefault();
      handlePointerMove(e.clientX, e.clientY);
    });
    canvas.addEventListener('mouseup', e => {
      e.preventDefault();
      handlePointerUp(e.clientX, e.clientY);
    });
  }

  function handlePointerDown(x, y) {
    GameState.input.isDown = true;
    GameState.input.lastX = x;
    GameState.input.x = x;
    GameState.input.justTapped = true;
    GameState.input.tapX = x;
    GameState.input.tapY = y;
    handleTap(x, y);
  }

  function handlePointerMove(x, y) {
    if (!GameState.input.isDown) return;
    GameState.input.x = x;
  }

  function handlePointerUp(x, y) {
    GameState.input.isDown = false;
  }

  function handleTap(x, y) {
    if (GameState.currentState === 'GAMEPLAY') {
      const stage = GameState.gameplayStage;
      const ui = GameState.ui;

      if (stage === 'roundIdle') {
        if (pointInRect(x, y, ui.playButton)) {
          startGauge();
          return;
        }
        if (pointInRect(x, y, ui.upgradeButtons.maxFish)) {
          buyMaxFishUpgrade();
          return;
        }
        if (pointInRect(x, y, ui.upgradeButtons.maxDepth)) {
          buyMaxDepthUpgrade();
          return;
        }
      } else if (stage === 'gauge') {
        if (pointInRect(x, y, ui.playButton) || pointInRect(x, y, ui.gaugeBar)) {
          GameState.pendingGaugeStop = true;
          return;
        }
      }
    } else if (GameState.currentState === 'ENDCARD') {
      const ui = GameState.ui;
      if (pointInRect(x, y, ui.ctaButton)) {
        onInstallClick();
      }
    }
  }

  // ---------- UPGRADES ----------
  function buyMaxFishUpgrade() {
    const level = GameState.purchasedMaxFishLevel;
    if (level >= MaxFishUpgradeSteps.length - 1) return;
    const next = MaxFishUpgradeSteps[level + 1];
    if (GameState.coins >= next.cost) {
      GameState.coins -= next.cost;
      GameState.displayCoins = GameState.coins;
      GameState.purchasedMaxFishLevel++;
      GameState.maxFishCapacity = next.cap;
      GameState.ui.fishCounter.maxValue = next.cap;
    }
  }

  function buyMaxDepthUpgrade() {
    const level = GameState.purchasedMaxDepthLevel;
    if (level >= MaxDepthUpgradeSteps.length - 1) return;
    const next = MaxDepthUpgradeSteps[level + 1];
    if (GameState.coins >= next.cost) {
      GameState.coins -= next.cost;
      GameState.displayCoins = GameState.coins;
      GameState.purchasedMaxDepthLevel++;
      GameState.maxDepth = next.depth;
      spawnFishForRound();
    }
  }

  // ---------- GAUGE / ROUND FLOW ----------
  function startGauge() {
    GameState.gameplayStage = 'gauge';
    GameState.gauge.isRunning = true;
    GameState.gauge.t = 0;
    GameState.ui.gaugeBar.visible = true;
    GameState.ui.playButton.visible = true;
  }

  function startDescentFromGauge() {
    const g = GameState.gauge.value;
    const minDepth = Math.max(1, GameState.maxDepth - 2);
    const depthRange = GameState.maxDepth - minDepth;
    const targetDepth = minDepth + g * depthRange;
    GameState.hook.targetDepth = targetDepth;
    GameState.gameplayStage = 'hookDescent';
    GameState.ui.gaugeBar.visible = false;
  }

  function prepareSurfaceSummary() {
    const rs = GameState.roundSummary;
    rs.stage = 1;
    rs.index = 0;
    rs.timer = 0;
    rs.totalCoinsThisRound = 0;
    rs.coinsCounted = 0;
    for (const f of GameState.caughtFish) {
      rs.totalCoinsThisRound += f.value;
    }
  }

  // ---------- UPDATE ----------
  let lastTime = 0;
  function gameLoop(ts) {
    if (!lastTime) lastTime = ts;
    let dt = ts - lastTime;
    if (dt > 50) dt = 50;
    lastTime = ts;

    update(dt);
    render();

    GameState.input.justTapped = false;

    requestAnimationFrame(gameLoop);
  }

  function update(dt) {
    if (GameState.currentState === 'GAMEPLAY') {
      updateGameplay(dt);
    } else if (GameState.currentState === 'ENDCARD') {
      updateEndcard(dt);
    }
  }

  function updateGameplay(dt) {
    switch (GameState.gameplayStage) {
      case 'roundIdle':
        updateRoundIdle(dt);
        break;
      case 'gauge':
        updateGauge(dt);
        break;
      case 'hookDescent':
        updateHookDescent(dt);
        break;
      case 'hookPause':
        updateHookPause(dt);
        break;
      case 'hookAscent':
        updateHookAscent(dt);
        break;
      case 'surfaceSummary':
        updateSurfaceSummary(dt);
        break;
      case 'roundTransition':
        updateRoundTransition(dt);
        break;
    }

    updateFloatingTexts(dt);
    updateCoinsFlying(dt);

    // smooth coin display
    if (GameState.displayCoins < GameState.coins) {
      GameState.displayCoins += Math.max(1, (GameState.coins - GameState.displayCoins) * 0.1);
      if (GameState.displayCoins > GameState.coins) GameState.displayCoins = GameState.coins;
    }
  }

  function updateRoundIdle(dt) {
    GameState.ui.playButton.visible = true;
    GameState.ui.coinCounter.visible = true;
    GameState.ui.fishCounter.visible = false;

    // enable / disable upgrade buttons based on affordability
    const mfLvl = GameState.purchasedMaxFishLevel;
    const mdLvl = GameState.purchasedMaxDepthLevel;
    const mfBtn = GameState.ui.upgradeButtons.maxFish;
    const mdBtn = GameState.ui.upgradeButtons.maxDepth;

    if (mfLvl >= MaxFishUpgradeSteps.length - 1) {
      mfBtn.enabled = false;
    } else {
      mfBtn.enabled = GameState.coins >= MaxFishUpgradeSteps[mfLvl + 1].cost;
    }
    if (mdLvl >= MaxDepthUpgradeSteps.length - 1) {
      mdBtn.enabled = false;
    } else {
      mdBtn.enabled = GameState.coins >= MaxDepthUpgradeSteps[mdLvl + 1].cost;
    }
  }

  function updateGauge(dt) {
    if (!GameState.gauge.isRunning) return;
    const g = GameState.gauge;
    g.t += dt;
    const phase = (g.t % g.period) / g.period;
    g.value = 0.5 - 0.5 * Math.cos(2 * Math.PI * phase);
    if (GameState.pendingGaugeStop) {
      GameState.pendingGaugeStop = false;
      g.isRunning = false;
      startDescentFromGauge();
    }
  }

  function updateHookDescent(dt) {
    const speedMps = 12;
    GameState.hook.depthM += speedMps * dt / 1000;
    if (GameState.hook.depthM >= GameState.hook.targetDepth) {
      GameState.hook.depthM = GameState.hook.targetDepth;
      GameState.gameplayStage = 'hookPause';
      GameState.hookPauseTimer = (GameState.roundIndex === 0 && !GameState.isTutorialShown) ? 1600 : 600;
      if (GameState.roundIndex === 0 && !GameState.isTutorialShown) {
        GameState.ui.tutorialLabel.visible = true;
        GameState.isTutorialShown = true;
      }
    }
    GameState.hook.y = depthToY(GameState.hook.depthM);
    updateCamera();
  }

  function updateHookPause(dt) {
    GameState.hookPauseTimer -= dt;
    if (GameState.hookPauseTimer <= 0) {
      GameState.ui.tutorialLabel.visible = false;
      GameState.gameplayStage = 'hookAscent';
      GameState.hookAscentSpeed = 18;
      GameState.caughtFish.length = 0;
      GameState.ui.fishCounter.visible = true;
      GameState.ui.coinCounter.visible = false;
      GameState.ui.playButton.visible = false;
      GameState.ui.fishCounter.value = 0;
      GameState.ui.fishCounter.maxValue = GameState.maxFishCapacity;
    }
  }

  function updateHookHorizontalFromInput(dt) {
    if (!GameState.input.isDown) return;
    const dx = GameState.input.x - GameState.input.lastX;
    GameState.input.lastX = GameState.input.x;
    const sensitivity = 1.1;
    GameState.hook.x += dx * sensitivity;
  }

  function clampHookX() {
    const margin = 32;
    const w = GameState.world.width;
    if (GameState.hook.x < margin) GameState.hook.x = margin;
    if (GameState.hook.x > w - margin) GameState.hook.x = w - margin;
  }

  function checkHookFishCollisions() {
    const hx = GameState.hook.x;
    const hy = GameState.hook.y;
    const hr = GameState.hook.radius * GameState.world.scale * 1.3;
    const maxCap = GameState.maxFishCapacity;

    for (const f of GameState.fish) {
      if (f.caught) continue;
      const dx = f.x - hx;
      const dy = f.y - hy;
      const dist2 = dx*dx + dy*dy;
      const r = hr + f.radius * GameState.world.scale;
      if (dist2 <= r*r) {
        f.caught = true;
        f.attachOffsetX = f.x - hx;
        f.attachOffsetY = f.y - hy;
        GameState.caughtFish.push(f);
        GameState.ui.fishCounter.value = GameState.caughtFish.length;
        GameState.floatingTexts.push({
          text: "+" + f.value,
          x: hx,
          y: hy,
          vy: -30,
          life: 800,
          age: 0,
          color: "#ffd54f"
        });
        if (f.label) {
          GameState.floatingTexts.push({
            text: f.label,
            x: hx,
            y: hy - 18,
            vy: -20,
            life: 800,
            age: 0,
            color: f.color
          });
        }
        if (GameState.caughtFish.length >= maxCap) {
          GameState.hookAscentSpeed = 26;
          break;
        }
      }
    }
  }

  function updateHookAscent(dt) {
    const atCapacity = GameState.caughtFish.length >= GameState.maxFishCapacity;
    const baseSpeed = atCapacity ? GameState.hookAscentSpeed : GameState.hookAscentSpeed;
    GameState.hook.depthM -= baseSpeed * dt / 1000;
    if (GameState.hook.depthM <= 0) {
      GameState.hook.depthM = 0;
      GameState.hook.y = depthToY(0);
      GameState.gameplayStage = 'surfaceSummary';
      GameState.ui.fishCounter.visible = false;
      GameState.ui.coinCounter.visible = true;
      prepareSurfaceSummary();
      return;
    }

    GameState.hook.y = depthToY(GameState.hook.depthM);

    updateHookHorizontalFromInput(dt);
    clampHookX();

    if (!atCapacity) {
      checkHookFishCollisions();
    }

    // move caught fish with hook
    for (const f of GameState.caughtFish) {
      f.x = GameState.hook.x + f.attachOffsetX;
      f.y = GameState.hook.y + f.attachOffsetY;
    }

    updateCamera();
  }

  function updateSurfaceSummary(dt) {
    const rs = GameState.roundSummary;
    if (rs.stage === 1) {
      if (GameState.caughtFish.length === 0) {
        rs.stage = 2;
        return;
      }
      rs.timer += dt;
      const currentFish = GameState.caughtFish[rs.index];
      if (currentFish) {
        // simple jump effect
        const t = Math.min(1, rs.timer / rs.perFishTime);
        const jumpHeight = 30;
        const eased = Math.sin(t * Math.PI);
        currentFish.jumpOffsetY = -eased * jumpHeight;

        if (rs.timer >= rs.perFishTime) {
          // spawn coin flying from fish to coin counter
          const ui = GameState.ui.coinCounter;
          GameState.coinsFlying.push({
            x: currentFish.x,
            y: currentFish.y + currentFish.jumpOffsetY,
            tx: ui.x + ui.w * 0.1,
            ty: ui.y + ui.h * 0.5,
            life: 600,
            age: 0
          });
          rs.index++;
          rs.timer = 0;
          if (rs.index >= GameState.caughtFish.length) {
            rs.stage = 2;
          }
        }
      } else {
        rs.stage = 2;
      }
    } else if (rs.stage === 2) {
      // count coins totalThisRound into GameState.coins
      if (rs.coinsCounted < rs.totalCoinsThisRound) {
        const step = Math.max(1, (rs.totalCoinsThisRound - rs.coinsCounted) * 0.2);
        rs.coinsCounted += step;
        if (rs.coinsCounted > rs.totalCoinsThisRound) rs.coinsCounted = rs.totalCoinsThisRound;
        GameState.coins = GameState.coins + step;
      } else {
        rs.stage = 3;
        GameState.roundIndex++;
        GameState.gameplayStage = 'roundTransition';
        rs.timer = 0;
      }
    }
  }

  function updateRoundTransition(dt) {
    const rs = GameState.roundSummary;
    rs.timer += dt;
    if (rs.timer > 700) {
      GameState.caughtFish.length = 0;
      for (const f of GameState.fish) {
        f.caught = false;
        f.jumpOffsetY = 0;
      }
      resetHookToSurface();
      GameState.world.cameraY = 0;
      if (GameState.roundIndex >= GameState.totalRounds) {
        GameState.currentState = 'ENDCARD';
        GameState.ui.ctaButton.visible = true;
      } else {
        spawnFishForRound();
        GameState.gameplayStage = 'roundIdle';
      }
    }
  }

  function updateEndcard(dt) {
    // small pulse for CTA button
  }

  function updateCamera() {
    const h = GameState.world.height;
    const centerTarget = GameState.hook.y - h * 0.5;
    GameState.world.cameraY += (centerTarget - GameState.world.cameraY) * 0.08;
    // clamp so surface never goes down
    if (GameState.world.cameraY < 0) GameState.world.cameraY = 0;
    const maxCam = GameState.world.bottomY - h * 0.7;
    if (GameState.world.cameraY > maxCam) GameState.world.cameraY = maxCam;
  }

  function updateFloatingTexts(dt) {
    const arr = GameState.floatingTexts;
    for (let i = arr.length - 1; i >= 0; i--) {
      const ft = arr[i];
      ft.age += dt;
      ft.y += ft.vy * dt / 1000;
      if (ft.age >= ft.life) arr.splice(i,1);
    }
  }

  function updateCoinsFlying(dt) {
    const arr = GameState.coinsFlying;
    for (let i = arr.length - 1; i >= 0; i--) {
      const c = arr[i];
      c.age += dt;
      const t = Math.min(1, c.age / c.life);
      const ease = t * t * (3 - 2 * t); // smoothstep
      c.x = c.x + (c.tx - c.x) * ease;
      c.y = c.y + (c.ty - c.y) * ease;
      if (c.age >= c.life) arr.splice(i,1);
    }
  }

  function onInstallClick() {
    // Stub for playable ad. In real use, call mraid.open or window.open.
    // For now we just log.
    console.log('Install button clicked');
  }

  // ---------- RENDER ----------
  function render() {
    const w = GameState.world.width;
    const h = GameState.world.height;
    ctx.clearRect(0, 0, w, h);

    if (GameState.currentState === 'GAMEPLAY') {
      renderGameplay();
    } else if (GameState.currentState === 'ENDCARD') {
      renderGameplay(true);
      renderEndcard();
    }
  }

  function renderGameplay(dimBackground) {
    renderBackground(dimBackground);
    renderBoatAndLine();
    renderFishAndHook();
    renderUI();
  }

  function renderBackground(dim) {
    const w = GameState.world.width;
    const h = GameState.world.height;
    const sY = GameState.world.surfaceY - GameState.world.cameraY;

    // sky
    const skyGrad = ctx.createLinearGradient(0, 0, 0, sY);
    skyGrad.addColorStop(0, '#0b1b34');
    skyGrad.addColorStop(1, '#1b3b6f');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, w, sY);

    // sea
    const seaGrad = ctx.createLinearGradient(0, sY, 0, h);
    seaGrad.addColorStop(0, '#0c2c4a');
    seaGrad.addColorStop(1, '#01101f');
    ctx.fillStyle = seaGrad;
    ctx.fillRect(0, sY, w, h - sY);

    // light rays
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = '#ffffff';
    for (let i = 0; i < 5; i++) {
      const x = (i / 5) * w;
      ctx.beginPath();
      ctx.moveTo(x, sY);
      ctx.lineTo(x + 80, h);
      ctx.lineTo(x + 30, h);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

    // seafloor hint
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#0a1c29';
    ctx.beginPath();
    ctx.ellipse(w/2, h * 0.98, w * 0.7, 40, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    if (dim) {
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(0, 0, w, h);
    }
  }

  function renderBoatAndLine() {
    const w = GameState.world.width;
    const sY = GameState.world.surfaceY - GameState.world.cameraY;

    // boat
    const boatW = 160 * GameState.world.scale;
    const boatH = 40 * GameState.world.scale;
    const bx = w * 0.5 - boatW/2;
    const by = sY - boatH - 10;
    ctx.save();
    ctx.fillStyle = '#4e342e';
    ctx.beginPath();
    ctx.moveTo(bx, by + boatH);
    ctx.lineTo(bx + boatW, by + boatH);
    ctx.lineTo(bx + boatW * 0.8, by);
    ctx.lineTo(bx + boatW * 0.2, by);
    ctx.closePath();
    ctx.fill();

    // fisherman
    ctx.fillStyle = '#eceff1';
    const px = bx + boatW * 0.25;
    const py = by - 8;
    ctx.beginPath();
    ctx.arc(px, py, 8 * GameState.world.scale, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(px - 5 * GameState.world.scale, py + 8 * GameState.world.scale,
                 10 * GameState.world.scale, 18 * GameState.world.scale);
    ctx.restore();

    // line
    ctx.save();
    ctx.strokeStyle = '#cfd8dc';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(w * 0.5, by + boatH * 0.3);
    ctx.lineTo(GameState.hook.x, GameState.hook.y - GameState.world.cameraY);
    ctx.stroke();
    ctx.restore();
  }

  function renderFishAndHook() {
    const camY = GameState.world.cameraY;
    const w = GameState.world.width;
    const h = GameState.world.height;

    // fish
    for (const f of GameState.fish) {
      const screenY = f.y - camY + (f.jumpOffsetY || 0);
      if (screenY < GameState.world.surfaceY - 40 || screenY > h + 40) continue;
      ctx.save();
      ctx.translate(f.x, screenY);
      ctx.scale(1, 1);
      const scale = 1;
      const r = f.radius * scale;
      ctx.fillStyle = f.color;
      ctx.beginPath();
      ctx.ellipse(0, 0, r * 1.3, r * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-r*1.3, 0);
      ctx.lineTo(-r*1.3 - r*0.6, -r*0.5);
      ctx.lineTo(-r*1.3 - r*0.6, r*0.5);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(r*0.8, -r*0.1, r*0.18, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(r*0.8, -r*0.1, r*0.09, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // hook
    const hx = GameState.hook.x;
    const hy = GameState.hook.y - camY;
    ctx.save();
    ctx.translate(hx, hy);
    const hr = 12 * GameState.world.scale;
    ctx.strokeStyle = '#eceff1';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, 0, hr, 0.2*Math.PI, 1.2*Math.PI, false);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(hr * Math.cos(1.2*Math.PI), hr * Math.sin(1.2*Math.PI));
    ctx.lineTo(hr * 1.2 * Math.cos(1.2*Math.PI), hr * 1.2 * Math.sin(1.2*Math.PI) - 4);
    ctx.stroke();
    ctx.restore();
  }

  function renderUI() {
    const w = GameState.world.width;
    const h = GameState.world.height;
    const ui = GameState.ui;

    ctx.save();
    ctx.font = `${16 * GameState.world.scale}px sans-serif`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';

    // coin counter
    if (ui.coinCounter.visible) {
      const r = ui.coinCounter;
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      roundRect(r.x, r.y, r.w, r.h, 20 * GameState.world.scale, true, false);
      // coin icon
      const cx = r.x + 18 * GameState.world.scale;
      const cy = r.y + r.h / 2;
      const cr = 10 * GameState.world.scale;
      const grad = ctx.createRadialGradient(cx - cr/3, cy - cr/3, cr*0.2, cx, cy, cr);
      grad.addColorStop(0, '#fff59d');
      grad.addColorStop(1, '#fbc02d');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(cx, cy, cr, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#f57f17';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, cr*0.6, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = '#eceff1';
      ctx.font = `${18 * GameState.world.scale}px sans-serif`;
      const coinsText = Math.floor(GameState.displayCoins).toString();
      ctx.fillText(coinsText, cx + 16 * GameState.world.scale, cy);
      ctx.restore();
    }

    // fish counter
    if (ui.fishCounter.visible) {
      const r = ui.fishCounter;
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      roundRect(r.x, r.y, r.w, r.h, 20 * GameState.world.scale, true, false);
      ctx.fillStyle = '#4fc3f7';
      ctx.beginPath();
      const fx = r.x + 18 * GameState.world.scale;
      const fy = r.y + r.h/2;
      const fr = 8 * GameState.world.scale;
      ctx.ellipse(fx, fy, fr*1.3, fr*0.8, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(fx - fr*1.3, fy);
      ctx.lineTo(fx - fr*1.3 - fr*0.6, fy - fr*0.5);
      ctx.lineTo(fx - fr*1.3 - fr*0.6, fy + fr*0.5);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#eceff1';
      ctx.font = `${18 * GameState.world.scale}px sans-serif`;
      const txt = `${ui.fishCounter.value}/${ui.fishCounter.maxValue}`;
      ctx.fillText(txt, fx + 16 * GameState.world.scale, fy);
      ctx.restore();
    }

    // play button
    if (ui.playButton.visible && GameState.gameplayStage !== 'hookAscent' && GameState.gameplayStage !== 'hookDescent') {
      const r = ui.playButton;
      ctx.save();
      const grad = ctx.createLinearGradient(0, r.y, 0, r.y + r.height);
      grad.addColorStop(0, '#ffb74d');
      grad.addColorStop(1, '#f57c00');
      ctx.fillStyle = grad;
      roundRect(r.x, r.y, r.width, r.height, 30 * GameState.world.scale, true, false);
      ctx.fillStyle = '#263238';
      ctx.font = `${26 * GameState.world.scale}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const label = (GameState.gameplayStage === 'gauge') ? 'STOP' : 'CAST';
      ctx.fillText(label, r.x + r.width/2, r.y + r.height/2);
      ctx.restore();
    }

    // gauge
    if (ui.gaugeBar.visible) {
      const r = ui.gaugeBar;
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      roundRect(r.x, r.y, r.width, r.height, r.height/2, true, false);
      const gx = r.x + 4;
      const gy = r.y + 4;
      const gh = r.height - 8;
      const gw = r.width - 8;
      ctx.fillStyle = '#263238';
      roundRect(gx, gy, gw, gh, gh/2, true, false);
      const v = GameState.gauge.value;
      const pw = gw * v;
      const grad = ctx.createLinearGradient(gx, gy, gx+pw, gy);
      grad.addColorStop(0, '#4caf50');
      grad.addColorStop(0.5, '#ffeb3b');
      grad.addColorStop(1, '#f44336');
      ctx.fillStyle = grad;
      roundRect(gx, gy, pw, gh, gh/2, true, false);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      roundRect(r.x, r.y, r.width, r.height, r.height/2, false, true);
      ctx.restore();
    }

    // upgrade buttons
    renderUpgradeButtons();

    // tutorial label
    if (ui.tutorialLabel.visible) {
      ctx.save();
      const text = ui.tutorialLabel.text;
      ctx.font = `${18 * GameState.world.scale}px sans-serif`;
      const mw = ctx.measureText(text).width + 40 * GameState.world.scale;
      const x = (w - mw) / 2;
      const y = h * 0.3;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      roundRect(x, y, mw, 40 * GameState.world.scale, 20 * GameState.world.scale, true, false);
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, x + mw/2, y + 20 * GameState.world.scale);
      ctx.restore();
    }

    // floating texts
    for (const ft of GameState.floatingTexts) {
      const alpha = 1 - ft.age / ft.life;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = ft.color;
      ctx.font = `${16 * GameState.world.scale}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(ft.text, ft.x, ft.y - GameState.world.cameraY);
      ctx.restore();
    }

    // coins flying
    for (const c of GameState.coinsFlying) {
      ctx.save();
      const cr = 8 * GameState.world.scale;
      const grad = ctx.createRadialGradient(c.x - cr/3, c.y - cr/3 - GameState.world.cameraY, cr*0.2,
                                            c.x, c.y - GameState.world.cameraY, cr);
      grad.addColorStop(0, '#fff59d');
      grad.addColorStop(1, '#fbc02d');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(c.x, c.y - GameState.world.cameraY, cr, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    ctx.restore();
  }

  function renderUpgradeButtons() {
    const ui = GameState.ui.upgradeButtons;
    const mfBtn = ui.maxFish;
    const mdBtn = ui.maxDepth;

    // max fish
    renderUpgradeButton(
      mfBtn,
      `Max Fish: ${GameState.maxFishCapacity}`,
      GameState.purchasedMaxFishLevel,
      MaxFishUpgradeSteps
    );
    // max depth
    renderUpgradeButton(
      mdBtn,
      `Max Depth: ${GameState.maxDepth}m`,
      GameState.purchasedMaxDepthLevel,
      MaxDepthUpgradeSteps
    );
  }

  function renderUpgradeButton(btn, label, level, steps) {
    const x = btn.x, y = btn.y, w = btn.width, h = btn.height;
    ctx.save();
    let grad;
    if (!btn.enabled) {
      grad = ctx.createLinearGradient(0, y, 0, y + h);
      grad.addColorStop(0, '#455a64');
      grad.addColorStop(1, '#263238');
    } else {
      grad = ctx.createLinearGradient(0, y, 0, y + h);
      grad.addColorStop(0, '#82b1ff');
      grad.addColorStop(1, '#2962ff');
    }
    ctx.fillStyle = grad;
    roundRect(x, y, w, h, 18 * GameState.world.scale, true, false);

    ctx.fillStyle = '#eceff1';
    ctx.font = `${14 * GameState.world.scale}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, x + w/2, y + h*0.35);

    ctx.font = `${12 * GameState.world.scale}px sans-serif`;
    let costText;
    if (level >= steps.length - 1) {
      costText = 'MAXED';
    } else {
      const cost = steps[level + 1].cost;
      costText = `Upgrade: ${cost}c`;
    }
    ctx.fillText(costText, x + w/2, y + h*0.7);
    ctx.restore();
  }

  function renderEndcard() {
    const w = GameState.world.width;
    const h = GameState.world.height;
    const ui = GameState.ui;

    ctx.save();
    // center panel
    const pw = w * 0.8;
    const ph = h * 0.5;
    const px = (w - pw)/2;
    const py = (h - ph)/2 - 20;
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    roundRect(px, py, pw, ph, 24 * GameState.world.scale, true, false);

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    ctx.fillStyle = '#ffffff';
    ctx.font = `${26 * GameState.world.scale}px sans-serif`;
    ctx.fillText('Your Deep Sea Fortune', w/2, py + ph*0.22);

    ctx.font = `${18 * GameState.world.scale}px sans-serif`;
    ctx.fillStyle = '#b0bec5';
    ctx.fillText('Total coins collected', w/2, py + ph*0.38);

    // big coins
    const coinY = py + ph*0.56;
    const innerCoins = Math.floor(GameState.coins);
    const coinStr = innerCoins.toString();
    ctx.fillStyle = '#ffd54f';
    ctx.font = `${32 * GameState.world.scale}px sans-serif`;
    ctx.fillText(coinStr, w/2 + 24 * GameState.world.scale, coinY);

    const cr = 18 * GameState.world.scale;
    const cx = w/2 - ctx.measureText(coinStr).width/2 - 26 * GameState.world.scale;
    const grad = ctx.createRadialGradient(cx - cr/3, coinY - cr/3, cr*0.2, cx, coinY, cr);
    grad.addColorStop(0, '#fff59d');
    grad.addColorStop(1, '#fbc02d');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(cx, coinY, cr, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#f57f17';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(cx, coinY, cr*0.7, 0, Math.PI*2);
    ctx.stroke();

    // CTA button
    const r = ui.ctaButton;
    const gradBtn = ctx.createLinearGradient(0, r.y, 0, r.y + r.height);
    gradBtn.addColorStop(0, '#ff8a65');
    gradBtn.addColorStop(1, '#ff3d00');
    ctx.fillStyle = gradBtn;
    roundRect(r.x, r.y, r.width, r.height, 26 * GameState.world.scale, true, false);
    ctx.fillStyle = '#ffffff';
    ctx.font = `${24 * GameState.world.scale}px sans-serif`;
    ctx.fillText('INSTALL', r.x + r.width/2, r.y + r.height/2);

    ctx.restore();
  }

  function roundRect(x, y, w, h, r, fill, stroke) {
    const radius = Math.min(r, h/2, w/2);
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + w - radius, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
    ctx.lineTo(x + w, y + h - radius);
    ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
    ctx.lineTo(x + radius, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // ---------- INIT ----------
  function create() {
    GameState.coins = 100;
    GameState.displayCoins = 100;
    GameState.roundIndex = 0;
    GameState.purchasedMaxFishLevel = 0;
    GameState.purchasedMaxDepthLevel = 0;
    GameState.maxFishCapacity = MaxFishUpgradeSteps[0].cap;
    GameState.maxDepth = MaxDepthUpgradeSteps[0].depth;
    GameState.ui.fishCounter.maxValue = GameState.maxFishCapacity;
    GameState.caughtFish = [];
    GameState.floatingTexts = [];
    GameState.coinsFlying = [];
    GameState.roundSummary.stage = 0;
    GameState.currentState = 'GAMEPLAY';
    GameState.gameplayStage = 'roundIdle';
    spawnFishForRound();
  }

  function init() {
    resizeCanvas();
    setupInput();
    create();
    requestAnimationFrame(gameLoop);
  }

  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('load', init);
})();
</script>
</body>
</html>