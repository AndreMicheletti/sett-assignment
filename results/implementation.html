<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Fishing In The Deep</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020612;
      color: #fff;
    }
    #game-root {
      position: relative;
      width: 100vw;
      height: 100vh;
      max-width: 600px;
      margin: 0 auto;
      overflow: hidden;
      background: radial-gradient(circle at top, #1a6fb8 0%, #020b24 55%, #000214 100%);
    }

    /* HUD */
    #hud {
      position: absolute;
      top: 6px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      z-index: 20;
    }
    #round-indicator {
      position: absolute;
      left: 8px;
      top: 6px;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
    }
    #main-counter {
      min-width: 110px;
      max-width: 180px;
      padding: 4px 10px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(0,0,0,0.75), rgba(0,0,0,0.5));
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: 0 2px 6px rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-weight: 600;
      pointer-events: auto;
    }
    #counter-icon {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fff6c0 0%, #f5c542 35%, #c79224 80%);
      box-shadow: 0 0 4px rgba(0,0,0,0.6);
      position: relative;
      flex: 0 0 auto;
    }
    #counter-icon.fish-mode {
      border-radius: 12px 12px 12px 4px;
      background: linear-gradient(135deg, #64b5f6, #26a69a);
    }
    #counter-value {
      font-size: 16px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    #fish-progress {
      position: absolute;
      top: 34px;
      left: 50%;
      transform: translateX(-50%);
      width: 48%;
      max-width: 210px;
      height: 6px;
      border-radius: 999px;
      background: rgba(0,0,0,0.4);
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0,0,0,0.7) inset;
      z-index: 19;
    }
    #fish-progress-fill {
      width: 0%;
      height: 100%;
      border-radius: inherit;
      background: linear-gradient(90deg, #4caf50, #ffc107);
      transition: width 0.12s ease-out;
    }

    /* Scene */
    #scene-container {
      position: absolute;
      top: 48px;
      bottom: 120px;
      left: 0;
      right: 0;
      display: flex;
      flex-direction: column;
    }
    #sky {
      flex: 0 0 18%;
      background: linear-gradient(to bottom, #70c0ff 0%, #a6ddff 50%, rgba(0,0,0,0) 100%);
      position: relative;
      z-index: 1;
    }
    #water {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: linear-gradient(to bottom, #00a7e1 0%, #0076ba 25%, #004b84 55%, #021838 100%);
      box-shadow: inset 0 6px 16px rgba(0,0,0,0.7);
    }

    /* Boat */
    #boat {
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-40%);
      width: 110px;
      height: 32px;
    }
    #boat-hull {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 18px;
      background: linear-gradient(135deg, #5d4037, #3e2723);
      border-radius: 0 0 40px 40px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.6);
    }
    #boat-top {
      position: absolute;
      bottom: 14px;
      left: 18px;
      right: 26px;
      height: 10px;
      border-radius: 8px;
      background: linear-gradient(135deg, #eeeeee, #bdbdbd);
    }
    #boat-cabin {
      position: absolute;
      bottom: 22px;
      left: 28px;
      width: 22px;
      height: 14px;
      border-radius: 4px 4px 0 0;
      background: linear-gradient(135deg, #ffcc80, #fb8c00);
    }
    #boat-cabin::after {
      content:"";
      position:absolute;
      left: 4px;
      top: 4px;
      width: 6px;
      height: 6px;
      border-radius: 2px;
      background:#fff;
    }
    #boat-mast {
      position:absolute;
      bottom: 22px;
      right: 20px;
      width: 3px;
      height: 26px;
      background:#d7ccc8;
    }

    /* Camera, hook, fish */
    #camera {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: -600px;
      transform: translateY(0);
      will-change: transform;
    }
    #hook {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 420px;
      pointer-events: none;
    }
    #hook-line {
      position: absolute;
      top: -120px;
      left: 50%;
      transform: translateX(-50%);
      width: 2px;
      height: 420px;
      background: linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(255,255,255,0.2));
      box-shadow: 0 0 2px rgba(255,255,255,0.7);
    }
    #hook-head {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 20px;
      height: 20px;
      border-radius: 12px 12px 14px 14px;
      background: radial-gradient(circle at 20% 20%, #ffffff 0%, #d7ccc8 35%, #6d4c41 100%);
      box-shadow: 0 2px 4px rgba(0,0,0,0.8);
    }
    #hook-head::after {
      content:"";
      position:absolute;
      bottom: -6px;
      left: 7px;
      width: 6px;
      height: 10px;
      border-radius: 0 0 8px 8px;
      border: 2px solid #d7ccc8;
      border-top: none;
      box-sizing: border-box;
    }
    #hook-caught-container {
      position: absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      min-height: 10px;
    }

    #fish-layer {
      position: absolute;
      top: 20px;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }
    .fish {
      position: absolute;
      width: 26px;
      height: 14px;
      border-radius: 14px 10px 10px 14px;
      transform-origin: center;
      box-shadow: 0 1px 3px rgba(0,0,0,0.6);
      will-change: transform;
    }
    .fish::before {
      content:"";
      position:absolute;
      right: -7px;
      top: 3px;
      border-style: solid;
      border-width: 4px 0 4px 7px;
      border-color: transparent transparent transparent rgba(0,0,0,0.35);
      opacity: 0.7;
    }
    .fish::after {
      content:"";
      position:absolute;
      left: 6px;
      top: 5px;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: rgba(255,255,255,0.9);
    }
    .fish-common {
      background: linear-gradient(135deg, #64b5f6, #1e88e5);
    }
    .fish-rare {
      background: linear-gradient(135deg, #ffb74d, #fb8c00);
    }
    .fish-epic {
      background: linear-gradient(135deg, #ba68c8, #8e24aa);
    }
    .fish-legendary {
      background: linear-gradient(135deg, #ffe082, #ffd54f);
      box-shadow: 0 0 6px rgba(255,241,118,0.9);
    }

    /* Controls */
    #controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 6px 10px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      z-index: 15;
      pointer-events: none;
    }
    #upgrades {
      display: flex;
      width: 100%;
      max-width: 420px;
      gap: 6px;
      justify-content: center;
      pointer-events: auto;
    }
    .upgrade-btn {
      flex: 1 1 0;
      padding: 5px 6px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.3);
      background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.15), rgba(0,0,0,0.7));
      color: #fff;
      font-size: 11px;
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 2px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.6);
    }
    .upgrade-btn span.label {
      font-weight: 600;
      font-size: 11px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }
    .upgrade-btn span.detail {
      font-size: 10px;
      opacity: 0.9;
    }
    .upgrade-btn.disabled {
      opacity: 0.45;
      border-color: rgba(255,255,255,0.1);
    }

    #gauge-container {
      width: 100%;
      max-width: 420px;
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 2px 0 0;
    }
    #gauge-track {
      position: relative;
      width: 100%;
      height: 14px;
      border-radius: 999px;
      background: linear-gradient(135deg, #1a237e, #0d47a1);
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.7);
      overflow: hidden;
    }
    #gauge-pointer {
      position: absolute;
      top: 1px;
      width: 20px;
      height: 12px;
      border-radius: 8px;
      background: radial-gradient(circle at 30% 30%, #fffde7 0%, #ffeb3b 45%, #f9a825 100%);
      box-shadow: 0 0 6px rgba(255,235,59,0.9);
      transform: translateX(-50%);
    }

    #btn-play {
      border: none;
      padding: 6px 28px;
      border-radius: 999px;
      font-weight: 700;
      font-size: 15px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: linear-gradient(135deg, #ffca28, #ff9800);
      color: #3e2723;
      box-shadow: 0 4px 9px rgba(0,0,0,0.6);
    }
    #btn-play:active {
      transform: translateY(1px);
      box-shadow: 0 2px 5px rgba(0,0,0,0.7);
    }

    /* Overlays */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.45);
      z-index: 30;
    }
    .hidden {
      display: none !important;
    }

    #tutorial-overlay-content {
      max-width: 260px;
      padding: 10px 14px;
      border-radius: 12px;
      background: radial-gradient(circle at 10% 10%, rgba(255,255,255,0.15), rgba(0,0,0,0.85));
      border: 1px solid rgba(255,255,255,0.4);
      text-align: center;
      font-size: 13px;
      box-shadow: 0 4px 9px rgba(0,0,0,0.8);
    }

    #summary-content {
      max-width: 280px;
      width: 82%;
      padding: 14px 16px 12px;
      border-radius: 14px;
      background: radial-gradient(circle at 10% 10%, rgba(255,255,255,0.12), rgba(0,0,0,0.92));
      border: 1px solid rgba(255,255,255,0.35);
      text-align: center;
      box-shadow: 0 6px 14px rgba(0,0,0,0.9);
    }
    #summary-title {
      font-size: 15px;
      font-weight: 700;
      margin-bottom: 4px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.9);
    }
    #summary-amount {
      font-size: 26px;
      font-weight: 700;
      color: #ffeb3b;
      text-shadow: 0 0 10px rgba(255,235,59,0.9);
      margin: 4px 0 2px;
    }
    #summary-subtext {
      font-size: 11px;
      opacity: 0.85;
      margin-bottom: 8px;
    }
    #summary-continue-btn {
      border: none;
      padding: 6px 20px;
      border-radius: 999px;
      background: linear-gradient(135deg, #4caf50, #2e7d32);
      color: #e8f5e9;
      font-weight: 600;
      box-shadow: 0 3px 7px rgba(0,0,0,0.7);
      font-size: 13px;
    }

    #end-screen-content {
      max-width: 280px;
      width: 82%;
      padding: 16px 18px 14px;
      border-radius: 16px;
      background: radial-gradient(circle at 10% 10%, rgba(255,255,255,0.14), rgba(0,0,0,0.96));
      border: 1px solid rgba(255,255,255,0.4);
      text-align: center;
      box-shadow: 0 7px 16px rgba(0,0,0,0.9);
    }
    #end-title {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 6px;
    }
    #end-coins {
      font-size: 24px;
      font-weight: 700;
      color: #ffeb3b;
      text-shadow: 0 0 10px rgba(255,235,59,0.9);
      margin-bottom: 10px;
    }
    #end-cta {
      border: none;
      padding: 7px 26px;
      border-radius: 999px;
      background: linear-gradient(135deg, #42a5f5, #1976d2);
      color: #e3f2fd;
      font-weight: 600;
      font-size: 13px;
      box-shadow: 0 4px 9px rgba(0,0,0,0.8);
    }

    /* Effects */
    .floating-text {
      position: absolute;
      font-size: 11px;
      font-weight: 600;
      color: #ffeb3b;
      text-shadow: 0 1px 3px rgba(0,0,0,0.9);
      pointer-events: none;
      z-index: 40;
      white-space: nowrap;
    }
    .coin-fly {
      position: absolute;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fff8e1 0%, #fbc02d 35%, #f57f17 100%);
      box-shadow: 0 0 4px rgba(255,235,59,0.9);
      pointer-events: none;
      z-index: 40;
    }

    @media (min-aspect-ratio: 9/16) {
      #game-root {
        height: 100vh;
        width: calc(100vh * 9 / 16);
      }
    }
  </style>
</head>
<body>
  <div id="game-root">
    <!-- HUD -->
    <div id="hud">
      <div id="round-indicator"></div>
      <div id="main-counter">
        <span id="counter-icon"></span>
        <span id="counter-value"></span>
      </div>
    </div>
    <div id="fish-progress" class="hidden">
      <div id="fish-progress-fill"></div>
    </div>

    <!-- Scene -->
    <div id="scene-container">
      <div id="sky"></div>
      <div id="water">
        <div id="boat">
          <div id="boat-hull"></div>
          <div id="boat-top"></div>
          <div id="boat-cabin"></div>
          <div id="boat-mast"></div>
        </div>
        <div id="camera">
          <div id="hook">
            <div id="hook-line"></div>
            <div id="hook-caught-container"></div>
            <div id="hook-head"></div>
          </div>
          <div id="fish-layer"></div>
        </div>
      </div>
    </div>

    <!-- Controls -->
    <div id="controls">
      <div id="upgrades">
        <button id="btn-upgrade-fish" class="upgrade-btn">
          <span class="label">Max Fish</span>
          <span class="detail"></span>
        </button>
        <button id="btn-upgrade-depth" class="upgrade-btn">
          <span class="label">Max Depth</span>
          <span class="detail"></span>
        </button>
      </div>
      <div id="gauge-container">
        <div id="gauge-track">
          <div id="gauge-pointer"></div>
        </div>
        <button id="btn-play">CAST</button>
      </div>
    </div>

    <!-- Overlays -->
    <div id="tutorial-overlay" class="overlay hidden">
      <div id="tutorial-overlay-content">
        Drag left and right to move the hook and catch fish!
      </div>
    </div>

    <div id="summary-overlay" class="overlay hidden">
      <div id="summary-content">
        <div id="summary-title">Catch Summary</div>
        <div id="summary-amount">+0</div>
        <div id="summary-subtext"></div>
        <button id="summary-continue-btn">Next cast</button>
      </div>
    </div>

    <div id="end-screen" class="overlay hidden">
      <div id="end-screen-content">
        <div id="end-title">Fishing Complete!</div>
        <div id="end-coins"></div>
        <button id="end-cta">Play Full Game</button>
      </div>
    </div>
  </div>

  <script>
    // ---------- Game State ----------
    const GameState = {
      phase: 'LOBBY',
      round: 1,
      maxRounds: 3,

      coins: 100,
      maxFish: 6,
      maxDepth: 5,

      fishUpgradeLevels: [6, 7, 8, 9, 10],
      fishUpgradeCosts: [0, 50, 100, 200, 400],
      depthUpgradeLevels: [5, 10, 15, 20, 30],
      depthUpgradeCosts: [0, 50, 75, 150, 300],
      currentFishUpgradeIndex: 0,
      currentDepthUpgradeIndex: 0,

      selectedDepth: 0,
      caughtFishThisRound: [],
      caughtCount: 0
    };

    // ---------- DOM Cache ----------
    const el = {
      root: document.getElementById('game-root'),
      roundIndicator: document.getElementById('round-indicator'),
      counterIcon: document.getElementById('counter-icon'),
      counterValue: document.getElementById('counter-value'),
      fishProgress: document.getElementById('fish-progress'),
      fishProgressFill: document.getElementById('fish-progress-fill'),
      water: document.getElementById('water'),
      camera: document.getElementById('camera'),
      hook: document.getElementById('hook'),
      hookLine: document.getElementById('hook-line'),
      hookHead: document.getElementById('hook-head'),
      hookCaughtContainer: document.getElementById('hook-caught-container'),
      fishLayer: document.getElementById('fish-layer'),
      btnUpgradeFish: document.getElementById('btn-upgrade-fish'),
      btnUpgradeDepth: document.getElementById('btn-upgrade-depth'),
      gaugeTrack: document.getElementById('gauge-track'),
      gaugePointer: document.getElementById('gauge-pointer'),
      btnPlay: document.getElementById('btn-play'),
      tutorialOverlay: document.getElementById('tutorial-overlay'),
      summaryOverlay: document.getElementById('summary-overlay'),
      summaryAmount: document.getElementById('summary-amount'),
      summarySubtext: document.getElementById('summary-subtext'),
      summaryContinueBtn: document.getElementById('summary-continue-btn'),
      endScreen: document.getElementById('end-screen'),
      endCoins: document.getElementById('end-coins')
    };

    // ---------- Helpers ----------
    function clamp(v, a, b) { return v < a ? a : v > b ? b : v; }
    function rand(min, max) { return Math.random() * (max - min) + min; }
    function lerp(a, b, t) { return a + (b - a) * t; }

    // depth (m) to scene Y pixels
    const depthScale = 40; // px per meter
    function depthToY(depth) {
      return depth * depthScale;
    }

    // ---------- UI Manager ----------
    const UIManager = (function () {
      function updateRound() {
        el.roundIndicator.textContent = `Cast ${GameState.round} / ${GameState.maxRounds}`;
      }

      function showCoinCounter() {
        el.counterIcon.classList.remove('fish-mode');
        el.fishProgress.classList.add('hidden');
        el.counterValue.textContent = GameState.coins.toString();
      }

      function showFishCounter() {
        el.counterIcon.classList.add('fish-mode');
        el.fishProgress.classList.remove('hidden');
        updateFishProgress(0, GameState.maxFish);
        el.counterValue.textContent = `0 / ${GameState.maxFish}`;
      }

      function updateFishProgress(caught, max) {
        const ratio = max > 0 ? caught / max : 0;
        el.fishProgressFill.style.width = (ratio * 100).toFixed(1) + '%';
        el.counterValue.textContent = `${caught} / ${max}`;
      }

      function updateUpgrades() {
        // Max Fish
        const fi = GameState.currentFishUpgradeIndex;
        const fishBtn = el.btnUpgradeFish;
        const fishDetail = fishBtn.querySelector('.detail');
        const currentFish = GameState.fishUpgradeLevels[fi];
        let text = `Now: ${currentFish}`;
        if (fi < GameState.fishUpgradeLevels.length - 1) {
          const next = GameState.fishUpgradeLevels[fi + 1];
          const cost = GameState.fishUpgradeCosts[fi + 1];
          text += `  •  Next: ${next} ( ${cost} )`;
          fishBtn.classList.remove('disabled');
        } else {
          text += '  •  MAX';
          fishBtn.classList.add('disabled');
        }
        fishDetail.textContent = text;

        // Depth
        const di = GameState.currentDepthUpgradeIndex;
        const depthBtn = el.btnUpgradeDepth;
        const depthDetail = depthBtn.querySelector('.detail');
        const currentDepth = GameState.depthUpgradeLevels[di];
        let dtxt = `Now: ${currentDepth} m`;
        if (di < GameState.depthUpgradeLevels.length - 1) {
          const next = GameState.depthUpgradeLevels[di + 1];
          const cost = GameState.depthUpgradeCosts[di + 1];
          dtxt += `  •  Next: ${next} m ( ${cost} )`;
          depthBtn.classList.remove('disabled');
        } else {
          dtxt += '  •  MAX';
          depthBtn.classList.add('disabled');
        }
        depthDetail.textContent = dtxt;
      }

      function showTutorial() {
        el.tutorialOverlay.classList.remove('hidden');
        setTimeout(() => {
          el.tutorialOverlay.classList.add('hidden');
        }, 1800);
      }

      function showSummary(totalCoins, fishCount) {
        el.summaryAmount.textContent = `+${totalCoins}`;
        if (fishCount === 0) {
          el.summarySubtext.textContent = 'No fish this time. Try aiming deeper!';
        } else {
          el.summarySubtext.textContent = `${fishCount} fish caught this cast.`;
        }
        el.summaryOverlay.classList.remove('hidden');
        el.summaryContinueBtn.disabled = true;

        // Count-up animation
        let elapsed = 0;
        const duration = 700;
        const start = performance.now();
        const startVal = 0;
        function tick(t) {
          elapsed = t - start;
          const k = clamp(elapsed / duration, 0, 1);
          const eased = k < 1 ? (1 - Math.cos(k * Math.PI)) / 2 : 1;
          const val = Math.round(lerp(startVal, totalCoins, eased));
          el.summaryAmount.textContent = `+${val}`;
          if (k < 1) {
            requestAnimationFrame(tick);
          } else {
            // Spawn small coin fly animation then enable button
            Effects.flyCoinsFromSummaryToCounter(() => {
              GameState.coins += totalCoins;
              showCoinCounter();
              el.summaryContinueBtn.disabled = false;
            });
          }
        }
        requestAnimationFrame(tick);
      }

      function hideSummary() {
        el.summaryOverlay.classList.add('hidden');
      }

      function showEndScreen() {
        el.endCoins.textContent = `${GameState.coins} coins collected`;
        el.endScreen.classList.remove('hidden');
      }

      return {
        updateRound,
        showCoinCounter,
        showFishCounter,
        updateFishProgress,
        updateUpgrades,
        showTutorial,
        showSummary,
        hideSummary,
        showEndScreen
      };
    })();

    // ---------- Effects ----------
    const Effects = (function () {
      function spawnFloatingText(worldX, worldY, text, color) {
        const div = document.createElement('div');
        div.className = 'floating-text';
        div.textContent = text;
        if (color) div.style.color = color;

        // Position relative to root
        const rectRoot = el.root.getBoundingClientRect();
        div.style.left = (worldX - rectRoot.left) + 'px';
        div.style.top = (worldY - rectRoot.top) + 'px';
        el.root.appendChild(div);

        const start = performance.now();
        const duration = 700;
        function loop(t) {
          const k = clamp((t - start) / duration, 0, 1);
          const yOffset = -20 * k;
          const alpha = 1 - k;
          div.style.transform = `translate(-50%, ${yOffset}px)`;
          div.style.opacity = alpha.toFixed(2);
          if (k < 1) {
            requestAnimationFrame(loop);
          } else {
            div.remove();
          }
        }
        requestAnimationFrame(loop);
      }

      function bounceHook() {
        el.hookHead.style.transform = 'translateX(-50%) scale(1.15)';
        setTimeout(() => {
          el.hookHead.style.transform = 'translateX(-50%) scale(1)';
        }, 120);
      }

      function flyCoinsFromSummaryToCounter(onComplete) {
        const srcRect = el.summaryAmount.getBoundingClientRect();
        const dstRect = el.counterIcon.getBoundingClientRect();
        const count = 4;
        let finished = 0;

        for (let i = 0; i < count; i++) {
          const c = document.createElement('div');
          c.className = 'coin-fly';
          const startX = srcRect.left + srcRect.width * 0.5 + rand(-18, 18);
          const startY = srcRect.top + srcRect.height * 0.5 + rand(-10, 10);
          c.style.left = (startX - el.root.getBoundingClientRect().left) + 'px';
          c.style.top = (startY - el.root.getBoundingClientRect().top) + 'px';
          el.root.appendChild(c);

          const targetX = dstRect.left + dstRect.width * 0.5;
          const targetY = dstRect.top + dstRect.height * 0.5;

          const sx = startX;
          const sy = startY;
          const dx = targetX - sx;
          const dy = targetY - sy;

          const startTime = performance.now();
          const duration = rand(420, 620);
          (function animate(t) {
            const k = clamp((t - startTime) / duration, 0, 1);
            const ease = k < 1 ? 1 - Math.pow(1 - k, 3) : 1;
            const x = sx + dx * ease;
            const y = sy + dy * ease;
            c.style.left = (x - el.root.getBoundingClientRect().left) + 'px';
            c.style.top = (y - el.root.getBoundingClientRect().top) + 'px';
            c.style.opacity = (1 - k * 0.4).toFixed(2);
            if (k < 1) {
              requestAnimationFrame(animate);
            } else {
              c.remove();
              finished++;
              if (finished === count && onComplete) onComplete();
            }
          })(startTime);
        }

        if (!count && onComplete) onComplete();
      }

      function onFishCaught(fish, hookScreenPos) {
        let label = `+${fish.value}`;
        let color = '#ffeb3b';
        if (fish.type === 'rare') {
          label += '  RARE';
          color = '#ffcc80';
        } else if (fish.type === 'epic') {
          label += '  EPIC';
          color = '#ce93d8';
        } else if (fish.type === 'legendary') {
          label += '  LEGENDARY';
          color = '#fff176';
        }
        spawnFloatingText(hookScreenPos.x, hookScreenPos.y - 10, label, color);
        bounceHook();
      }

      return {
        onFishCaught,
        flyCoinsFromSummaryToCounter
      };
    })();

    // ---------- Fish Manager ----------
    class FishEntity {
      constructor(opts) {
        this.id = opts.id;
        this.type = opts.type;
        this.value = opts.value;
        this.depth = opts.depth;
        this.x = opts.x;
        this.y = opts.y;
        this.caught = false;
        this.dom = opts.dom;
        this.offsetOnHook = 0;
      }
    }

    const FishManager = (function () {
      let fishes = [];
      let idCounter = 1;

      function reset() {
        fishes.forEach(f => f.dom && f.dom.remove());
        fishes = [];
      }

      function getFishes() {
        return fishes;
      }

      function rarityForDepth(depth) {
        if (depth < 8) {
          const r = Math.random();
          if (r < 0.85) return 'common';
          if (r < 0.97) return 'rare';
          return 'epic';
        } else if (depth < 18) {
          const r = Math.random();
          if (r < 0.6) return 'common';
          if (r < 0.88) return 'rare';
          if (r < 0.985) return 'epic';
          return 'legendary';
        } else {
          const r = Math.random();
          if (r < 0.3) return 'common';
          if (r < 0.7) return 'rare';
          if (r < 0.95) return 'epic';
          return 'legendary';
        }
      }

      function valueForType(type) {
        switch (type) {
          case 'common': return Math.round(rand(5, 12));
          case 'rare': return Math.round(rand(15, 28));
          case 'epic': return Math.round(rand(35, 50));
          case 'legendary': return Math.round(rand(60, 90));
          default: return 5;
        }
      }

      function generateField(maxDepth) {
        reset();
        const count = Math.round(maxDepth * 2) + 14;
        const waterRect = el.water.getBoundingClientRect();
        const minX = waterRect.width * 0.12;
        const maxX = waterRect.width * 0.88;

        for (let i = 0; i < count; i++) {
          const depth = rand(0.3, maxDepth + 0.5);
          const type = rarityForDepth(depth);
          const value = valueForType(type);
          const y = depthToY(depth) + rand(-10, 10);
          const x = rand(minX, maxX);
          const fishDiv = document.createElement('div');
          fishDiv.className = `fish fish-${type}`;
          fishDiv.style.left = x + 'px';
          fishDiv.style.top = y + 'px';
          fishDiv.style.transform = `translate(-50%, -50%) scale(${rand(0.9, 1.25)})`;
          el.fishLayer.appendChild(fishDiv);

          const entity = new FishEntity({
            id: idCounter++,
            type,
            value,
            depth,
            x,
            y,
            dom: fishDiv
          });
          fishes.push(entity);
        }
      }

      return {
        generateField,
        reset,
        getFishes
      };
    })();

    // ---------- Upgrade System ----------
    const UpgradeSystem = (function () {
      function tryUpgradeFish() {
        const idx = GameState.currentFishUpgradeIndex;
        if (idx >= GameState.fishUpgradeLevels.length - 1) return;
        const cost = GameState.fishUpgradeCosts[idx + 1];
        if (GameState.coins < cost) return;
        GameState.coins -= cost;
        GameState.currentFishUpgradeIndex++;
        GameState.maxFish = GameState.fishUpgradeLevels[GameState.currentFishUpgradeIndex];
        UIManager.updateUpgrades();
        UIManager.showCoinCounter();
      }

      function tryUpgradeDepth() {
        const idx = GameState.currentDepthUpgradeIndex;
        if (idx >= GameState.depthUpgradeLevels.length - 1) return;
        const cost = GameState.depthUpgradeCosts[idx + 1];
        if (GameState.coins < cost) return;
        GameState.coins -= cost;
        GameState.currentDepthUpgradeIndex++;
        GameState.maxDepth = GameState.depthUpgradeLevels[GameState.currentDepthUpgradeIndex];
        UIManager.updateUpgrades();
        UIManager.showCoinCounter();
      }

      return { tryUpgradeFish, tryUpgradeDepth };
    })();

    // ---------- Fishing Controller ----------
    const FishingController = (function () {
      let hookX = 0;
      let hookY = 0;
      let baseHookX = 0;
      let targetDepthY = 0;
      let verticalSpeed = 120; // px/s base
      let ascentSpeed = 160;
      let fastAscentSpeed = 280;
      let atDepthTimer = 0;
      let allowDrag = false;
      let dragging = false;
      let dragStartX = 0;
      let dragHookStartX = 0;

      function resetHook() {
        const waterRect = el.water.getBoundingClientRect();
        baseHookX = waterRect.width * 0.55;
        hookX = baseHookX;
        hookY = 10;
        applyHookTransform();
        el.camera.style.transform = 'translateY(0px)';
        el.hookCaughtContainer.innerHTML = '';
      }

      function applyHookTransform() {
        el.hook.style.left = hookX + 'px';
        el.hook.style.top = hookY + 'px';
      }

      function startRound(depthMeters) {
        GameState.phase = 'HOOK_DESCENDING';
        GameState.selectedDepth = depthMeters;
        GameState.caughtFishThisRound = [];
        GameState.caughtCount = 0;
        UIManager.showFishCounter();
        FishManager.generateField(GameState.maxDepth);
        resetHook();

        targetDepthY = depthToY(depthMeters) + 30;
      }

      function hookScreenPos() {
        const headRect = el.hookHead.getBoundingClientRect();
        return { x: headRect.left + headRect.width / 2, y: headRect.top + headRect.height / 2 };
      }

      function update(dt) {
        const phase = GameState.phase;
        if (phase === 'HOOK_DESCENDING') {
          const dy = verticalSpeed * dt;
          if (hookY + dy >= targetDepthY) {
            hookY = targetDepthY;
            GameState.phase = 'HOOK_AT_DEPTH';
            atDepthTimer = (GameState.round === 1 ? 2.0 : 0.8);
            if (GameState.round === 1) UIManager.showTutorial();
          } else {
            hookY += dy;
          }
          applyHookTransform();
          el.camera.style.transform = `translateY(${-hookY * 0.7}px)`;
        } else if (phase === 'HOOK_AT_DEPTH') {
          atDepthTimer -= dt;
          if (atDepthTimer <= 0) {
            GameState.phase = 'HOOK_ASCENDING';
            allowDrag = true;
          }
        } else if (phase === 'HOOK_ASCENDING' || phase === 'RETURNING_FAST') {
          const speed = phase === 'RETURNING_FAST' ? fastAscentSpeed : ascentSpeed;
          const dy = speed * dt;
          if (hookY - dy <= 10) {
            hookY = 10;
            applyHookTransform();
            el.camera.style.transform = 'translateY(0px)';
            allowDrag = false;
            if (phase === 'HOOK_ASCENDING') {
              GameState.phase = 'AT_SURFACE_RESOLVE';
            } else {
              GameState.phase = 'AT_SURFACE_RESOLVE';
            }
            if (phase === 'RETURNING_FAST') {
              UIManager.showCoinCounter();
            }
            // Resolve round
            resolveAtSurface();
          } else {
            hookY -= dy;
            applyHookTransform();
            el.camera.style.transform = `translateY(${-hookY * 0.7}px)`;
            if (phase === 'HOOK_ASCENDING') {
              checkFishCollisions();
            }
          }
        }
      }

      function resolveAtSurface() {
        const total = GameState.caughtFishThisRound.reduce((s, f) => s + f.value, 0);
        UIManager.showSummary(total, GameState.caughtFishThisRound.length);
      }

      function checkFishCollisions() {
        const fishes = FishManager.getFishes();
        const hookRect = el.hookHead.getBoundingClientRect();
        const hx = hookRect.left + hookRect.width / 2;
        const hy = hookRect.top + hookRect.height / 2;

        const catchRadiusX = 24;
        const catchRadiusY = 26;

        for (let i = 0; i < fishes.length; i++) {
          const f = fishes[i];
          if (f.caught) continue;
          const rect = f.dom.getBoundingClientRect();
          const fx = rect.left + rect.width / 2;
          const fy = rect.top + rect.height / 2;
          if (Math.abs(fx - hx) <= catchRadiusX && Math.abs(fy - hy) <= catchRadiusY) {
            // Catch it
            f.caught = true;
            GameState.caughtFishThisRound.push(f);
            GameState.caughtCount++;
            UIManager.updateFishProgress(GameState.caughtCount, GameState.maxFish);

            // Attach to hook
            f.dom.style.left = '50%';
            f.dom.style.top = (10 + 10 * GameState.caughtCount) + 'px';
            f.dom.style.transform = `translate(-50%, -50%) scale(0.85)`;
            el.hookCaughtContainer.appendChild(f.dom);

            Effects.onFishCaught(f, hookScreenPos());

            if (GameState.caughtCount >= GameState.maxFish) {
              GameState.phase = 'RETURNING_FAST';
              allowDrag = false;
              break;
            }
          }
        }
      }

      function onPointerDown(clientX) {
        if (!allowDrag) return;
        dragging = true;
        dragStartX = clientX;
        dragHookStartX = hookX;
      }

      function onPointerMove(clientX) {
        if (!dragging || !allowDrag) return;
        const dx = clientX - dragStartX;
        const waterRect = el.water.getBoundingClientRect();
        const minX = waterRect.width * 0.12;
        const maxX = waterRect.width * 0.88;
        hookX = clamp(dragHookStartX + dx, minX, maxX);
        applyHookTransform();
      }

      function onPointerUp() {
        dragging = false;
      }

      return {
        startRound,
        update,
        resetHook,
        onPointerDown,
        onPointerMove,
        onPointerUp
      };
    })();

    // ---------- Gauge Logic ----------
    let gaugeTime = 0;
    const gaugeSpeed = 2.6; // rad/s

    function updateGauge(dt) {
      if (GameState.phase !== 'GAUGE_SELECT') return;
      gaugeTime += dt * gaugeSpeed;
      const progress = (Math.sin(gaugeTime) + 1) / 2; // 0..1
      const trackRect = el.gaugeTrack.getBoundingClientRect();
      const x = lerp(trackRect.width * 0.05, trackRect.width * 0.95, progress);
      el.gaugePointer.style.left = x + 'px';
    }

    function currentGaugeNormalized() {
      const trackRect = el.gaugeTrack.getBoundingClientRect();
      const ptrRect = el.gaugePointer.getBoundingClientRect();
      const cx = ptrRect.left + ptrRect.width / 2 - trackRect.left;
      const n = clamp((cx - trackRect.width * 0.05) / (trackRect.width * 0.9), 0, 1);
      return n;
    }

    // ---------- Main Loop ----------
    let lastTime = 0;
    function gameLoop(timestamp) {
      const dt = (timestamp - lastTime) / 1000 || 0;
      lastTime = timestamp;

      if (GameState.phase === 'GAUGE_SELECT') {
        updateGauge(dt);
      }

      FishingController.update(dt);

      requestAnimationFrame(gameLoop);
    }

    // ---------- Flow Control ----------
    function goToLobby() {
      GameState.phase = 'LOBBY';
      UIManager.updateRound();
      UIManager.showCoinCounter();
      UIManager.updateUpgrades();
      FishManager.reset();
      FishingController.resetHook();
      el.summaryOverlay.classList.add('hidden');
    }

    function advanceAfterSummary() {
      UIManager.hideSummary();
      if (GameState.round < GameState.maxRounds) {
        GameState.round++;
        goToLobby();
      } else {
        GameState.phase = 'END_SCREEN';
        UIManager.showEndScreen();
      }
    }

    // ---------- Event Listeners ----------
    function setupEvents() {
      el.btnUpgradeFish.addEventListener('click', () => {
        if (GameState.phase !== 'LOBBY') return;
        UpgradeSystem.tryUpgradeFish();
      });
      el.btnUpgradeDepth.addEventListener('click', () => {
        if (GameState.phase !== 'LOBBY') return;
        UpgradeSystem.tryUpgradeDepth();
      });

      el.btnPlay.addEventListener('click', () => {
        if (GameState.phase === 'LOBBY') {
          GameState.phase = 'GAUGE_SELECT';
          el.btnPlay.textContent = 'STOP';
        } else if (GameState.phase === 'GAUGE_SELECT') {
          const n = currentGaugeNormalized();
          const maxDepth = GameState.maxDepth;
          const minD = Math.max(0, maxDepth - 2);
          const selected = minD + n * 2;
          FishingController.startRound(selected);
          el.btnPlay.textContent = 'CAST';
        }
      });

      function pointerDown(e) {
        const x = e.touches ? e.touches[0].clientX : e.clientX;
        FishingController.onPointerDown(x);
      }
      function pointerMove(e) {
        if (!e.touches && e.buttons === 0) return;
        const x = e.touches ? e.touches[0].clientX : e.clientX;
        FishingController.onPointerMove(x);
      }
      function pointerUp() {
        FishingController.onPointerUp();
      }

      el.water.addEventListener('mousedown', pointerDown);
      window.addEventListener('mousemove', pointerMove);
      window.addEventListener('mouseup', pointerUp);

      el.water.addEventListener('touchstart', pointerDown, { passive: true });
      window.addEventListener('touchmove', pointerMove, { passive: true });
      window.addEventListener('touchend', pointerUp);

      el.summaryContinueBtn.addEventListener('click', () => {
        if (GameState.phase === 'AT_SURFACE_RESOLVE' || GameState.phase === 'ROUND_END') {
          advanceAfterSummary();
        } else if (GameState.phase === 'LOBBY') {
          el.summaryOverlay.classList.add('hidden');
        } else {
          advanceAfterSummary();
        }
      });

      el.endScreen.addEventListener('click', () => {
        // In a real playable ad, CTA would open store.
      });
      el.endScreen.querySelector('#end-cta').addEventListener('click', (e) => {
        e.stopPropagation();
      });
    }

    // ---------- Init ----------
    function init() {
      UIManager.updateRound();
      UIManager.showCoinCounter();
      UIManager.updateUpgrades();
      FishingController.resetHook();
      setupEvents();
      requestAnimationFrame((t) => {
        lastTime = t;
        gameLoop(t);
      });
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>