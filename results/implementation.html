<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Fishing In The Deep</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background: #003366;
    color: #fff;
  }
  #game-root {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: radial-gradient(circle at 50% 0%, #6ec6ff 0%, #01579b 40%, #001f3f 100%);
    touch-action: none;
  }
  #game-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  #ui-root {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  /* Top HUD */
  .top-hud {
    position: absolute;
    top: 8px;
    left: 8px;
    right: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    pointer-events: none;
    z-index: 10;
  }
  .hud-pill {
    min-width: 80px;
    padding: 4px 8px;
    border-radius: 999px;
    background: rgba(0,0,0,0.5);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    pointer-events: auto;
  }
  .hud-pill span.icon {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    margin-right: 4px;
    background: radial-gradient(circle at 30% 30%, #fffaa0 0%, #ffd54f 40%, #ffb300 100%);
  }
  #coin-hud { display: flex; }
  #fish-hud { display: none; }

  #fish-hud-count {
    margin-right: 8px;
  }
  #fish-progress {
    position: relative;
    width: 80px;
    height: 8px;
    border-radius: 999px;
    background: rgba(255,255,255,0.15);
    overflow: hidden;
  }
  #fish-progress-fill {
    position: absolute;
    left: 0; top: 0; bottom: 0;
    width: 0%;
    border-radius: 999px;
    background: linear-gradient(90deg,#4caf50,#cddc39);
  }

  /* Bottom panel: gauge + play + upgrades */
  #bottom-panel {
    position: absolute;
    left: 8px; right: 8px; bottom: 8px;
    pointer-events: none;
    z-index: 10;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  #gauge-wrapper {
    pointer-events: auto;
    display: none;
    align-items: center;
    justify-content: center;
    margin-bottom: 4px;
  }
  #gauge {
    flex: 1;
    max-width: 460px;
    height: 18px;
    border-radius: 999px;
    background: rgba(0,0,0,0.4);
    position: relative;
    overflow: hidden;
  }
  #gauge-track {
    position: absolute;
    inset: 4px;
    border-radius: 999px;
    background: linear-gradient(90deg,#004d40,#006064);
  }
  #gauge-pointer {
    position: absolute;
    top: 0; bottom: 0;
    width: 4px;
    margin-left: -2px;
    border-radius: 999px;
    background: #ffeb3b;
    box-shadow: 0 0 8px rgba(255,235,59,0.8);
    left: 50%;
  }
  #play-button {
    pointer-events: auto;
    align-self: center;
    margin-top: 4px;
    padding: 8px 24px;
    border-radius: 999px;
    border: none;
    background: linear-gradient(180deg,#ffb300,#ff6f00);
    color: #000;
    font-weight: 700;
    font-size: 16px;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 2px 0 rgba(0,0,0,0.5);
    cursor: pointer;
  }
  #play-button:active {
    transform: translateY(1px);
    box-shadow: 0 1px 0 rgba(0,0,0,0.4);
  }

  #upgrades {
    display: flex;
    justify-content: center;
    gap: 8px;
    pointer-events: auto;
  }
  .upgrade-btn {
    flex: 1;
    min-width: 0;
    padding: 6px 8px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.35);
    background: rgba(0,0,0,0.5);
    color: #fff;
    font-size: 12px;
    text-align: left;
    cursor: pointer;
  }
  .upgrade-btn.disabled {
    opacity: 0.4;
    cursor: default;
  }
  .upgrade-title {
    font-weight: 700;
    font-size: 11px;
    text-transform: uppercase;
  }
  .upgrade-desc {
    font-size: 11px;
    opacity: 0.9;
  }

  /* Tutorial overlay */
  #tutorial-overlay {
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at 50% 20%, rgba(0,0,0,0.1), rgba(0,0,0,0.75));
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 20;
    pointer-events: auto;
  }
  #tutorial-box {
    max-width: 260px;
    padding: 14px 16px;
    border-radius: 16px;
    background: rgba(0,0,0,0.9);
    border: 1px solid rgba(255,255,255,0.2);
    text-align: center;
    font-size: 14px;
  }
  #tutorial-title {
    font-weight: 700;
    margin-bottom: 6px;
    font-size: 15px;
  }
  #tutorial-body {
    margin-bottom: 8px;
  }
  #tutorial-note {
    font-size: 11px;
    opacity: 0.7;
  }

  /* Summary panel */
  #summary-panel {
    position: absolute;
    left: 50%;
    bottom: 25%;
    transform: translateX(-50%);
    min-width: 220px;
    max-width: 300px;
    padding: 12px 16px;
    border-radius: 16px;
    background: rgba(0,0,0,0.9);
    border: 1px solid rgba(255,255,255,0.3);
    display: none;
    flex-direction: column;
    align-items: center;
    z-index: 15;
    pointer-events: auto;
  }
  #summary-title {
    font-weight: 700;
    text-transform: uppercase;
    font-size: 13px;
    letter-spacing: 1px;
    margin-bottom: 4px;
  }
  #summary-fish-list {
    width: 100%;
    min-height: 24px;
    font-size: 12px;
    margin-bottom: 4px;
    text-align: center;
    opacity: 0.9;
  }
  #summary-total-row {
    margin-top: 4px;
    font-size: 13px;
  }
  #summary-total-label {
    opacity: 0.8;
    margin-right: 4px;
  }
  #summary-total-amount {
    font-weight: 700;
    color: #ffeb3b;
  }

  /* End card */
  #endcard {
    position: absolute;
    inset: 0;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: radial-gradient(circle at 50% 0%, rgba(255,255,255,0.15), rgba(0,0,0,0.95));
    z-index: 30;
    pointer-events: auto;
  }
  #endcard-inner {
    padding: 16px 18px;
    border-radius: 18px;
    background: rgba(0,0,0,0.9);
    border: 1px solid rgba(255,255,255,0.2);
    max-width: 280px;
    text-align: center;
  }
  #endcard-title {
    font-size: 18px;
    font-weight: 800;
    text-transform: uppercase;
    margin-bottom: 6px;
  }
  #endcard-body {
    font-size: 13px;
    margin-bottom: 10px;
  }
  #cta-button {
    padding: 8px 20px;
    border-radius: 999px;
    border: none;
    background: linear-gradient(180deg,#00e676,#00b248);
    color: #000;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    cursor: pointer;
  }

  /* Catch pop text */
  .catch-pop {
    position: absolute;
    font-size: 12px;
    font-weight: 700;
    color: #ffeb3b;
    text-shadow: 0 0 4px rgba(0,0,0,0.8);
    pointer-events: none;
    opacity: 0;
    transform: translate(-50%, -50%) translateY(0);
    animation: catch-pop 0.6s ease-out forwards;
    z-index: 25;
    white-space: nowrap;
  }
  @keyframes catch-pop {
    0% { opacity: 0; transform: translate(-50%, -50%) translateY(8px) scale(0.7); }
    20% { opacity: 1; transform: translate(-50%, -50%) translateY(0px) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -50%) translateY(-16px) scale(1); }
  }

  /* Coin burst */
  .coin-burst {
    position: absolute;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #fffaa0 0%, #ffd54f 40%, #ffb300 100%);
    opacity: 0;
    pointer-events: none;
    animation: coin-burst 0.5s ease-out forwards;
    z-index: 22;
  }
  @keyframes coin-burst {
    0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
    100% { opacity: 0; transform: translate(-50%, -150%) scale(1.1); }
  }

  @media (orientation: landscape) {
    #bottom-panel {
      left: 8px;
      right: auto;
      width: 260px;
    }
  }
</style>
</head>
<body>
<div id="game-root">
  <canvas id="game-canvas"></canvas>
  <div id="ui-root">
    <div class="top-hud">
      <div id="coin-hud" class="hud-pill">
        <span class="icon"></span>
        <span id="coin-count">0</span>
      </div>
      <div id="fish-hud" class="hud-pill">
        <span id="fish-hud-count">0/0</span>
        <div id="fish-progress"><div id="fish-progress-fill"></div></div>
      </div>
    </div>

    <div id="bottom-panel">
      <div id="gauge-wrapper">
        <div id="gauge">
          <div id="gauge-track"></div>
          <div id="gauge-pointer"></div>
        </div>
      </div>
      <button id="play-button">CAST</button>
      <div id="upgrades">
        <button id="upgrade-max-fish" class="upgrade-btn">
          <div class="upgrade-title">More Fish</div>
          <div class="upgrade-desc">Catch +0 fish (0)</div>
        </button>
        <button id="upgrade-max-depth" class="upgrade-btn">
          <div class="upgrade-title">Deeper</div>
          <div class="upgrade-desc">Depth +0m (0)</div>
        </button>
      </div>
    </div>

    <div id="tutorial-overlay">
      <div id="tutorial-box">
        <div id="tutorial-title">Drag to catch fish</div>
        <div id="tutorial-body">When the hook comes up, move your finger left and right to catch as many fish as you can.</div>
        <div id="tutorial-note">Try to reach your max fish before surfacing.</div>
      </div>
    </div>

    <div id="summary-panel">
      <div id="summary-title">Catch Summary</div>
      <div id="summary-fish-list"></div>
      <div id="summary-total-row">
        <span id="summary-total-label">Round coins:</span>
        <span id="summary-total-amount">0</span>
      </div>
    </div>

    <div id="endcard">
      <div id="endcard-inner">
        <div id="endcard-title">Nice haul!</div>
        <div id="endcard-body">
          You fished through 3 casts and upgraded your gear.<br/>
          Imagine what you could catch in the full game.
        </div>
        <button id="cta-button">Play Full Game</button>
      </div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
<script>
(function() {
  'use strict';

  /********************
   * Global State
   ********************/
  const GameState = {
    currentState: 'LOADING', // 'LOADING'|'GAMEPLAY'|'TUTORIAL'|'ENDCARD'
    currentPhase: 'SETUP',   // 'SETUP','GAUGE','CAST_DOWN','PAUSE_AT_DEPTH','ASCEND','SURFACE_SUMMARY'
    round: 1,
    maxRounds: 3,

    coins: 100,

    maxFish: 6,
    maxFishTierIndex: 0,
    maxFishTiers: [
      { value: 6, cost: 0 },
      { value: 7, cost: 50 },
      { value: 8, cost: 100 },
      { value: 9, cost: 200 },
      { value: 10, cost: 400 }
    ],

    maxDepth: 5,
    maxDepthTierIndex: 0,
    maxDepthTiers: [
      { value: 5, cost: 0 },
      { value: 10, cost: 50 },
      { value: 15, cost: 75 },
      { value: 20, cost: 150 },
      { value: 30, cost: 300 }
    ],

    selectedDepth: 5,
    hookDepth: 0,
    hookX: 0,
    hookSpeedDown: 10,
    hookSpeedUp: 8,

    fishCaught: [],
    fishCaughtCount: 0,

    tutorialShown: false
  };

  const FishTypes = [
    { id: 'small',   baseValue: 5,  depthMin: 0,  depthMax: 10, rarityLabel: null,         color: 0x66ccff },
    { id: 'medium',  baseValue: 15, depthMin: 5,  depthMax: 20, rarityLabel: 'rare!',      color: 0x44aa44 },
    { id: 'big',     baseValue: 30, depthMin: 10, depthMax: 30, rarityLabel: 'amazing!',   color: 0xffaa00 },
    { id: 'legend',  baseValue: 60, depthMin: 20, depthMax: 40, rarityLabel: 'legendary!', color: 0xaa44ff }
  ];

  const HookState = {
    mesh: null,
    lineMesh: null,
    targetDepth: 0,
    verticalSpeed: 0,
    horizontalTargetX: 0,
    horizontalSpeed: 15
  };

  const CameraState = {
    camera: null,
    baseY: 5,
    followSpeed: 5
  };

  const SummaryState = {
    step: 0,
    timer: 0,
    totalRoundCoins: 0,
    addedToCoins: false
  };

  const UI = {
    coinCounter: null,
    fishCounter: null,
    fishProgressFill: null,
    playButton: null,
    gaugeWrapper: null,
    gaugePointer: null,
    upgradeMaxFishBtn: null,
    upgradeMaxDepthBtn: null,
    tutorialOverlay: null,
    summaryPanel: null,
    summaryFishList: null,
    summaryTotalAmount: null,
    endCard: null
  };

  let renderer, scene;
  let fishEntities = [];
  let worldMinX = -5, worldMaxX = 5;

  // Gauge animation
  let gaugeTime = 0;
  let gaugeDirection = 1;
  const gaugeDuration = 1.5; // seconds from min to max

  // Pause at depth
  let pauseTimer = 0;

  // Summary total display
  let currentDisplayTotal = 0;

  let lastTime = 0;

  /********************
   * Utilities
   ********************/
  function easeInOutQuad(t) {
    return t < 0.5 ? 2*t*t : -1 + (4 - 2*t) * t;
  }

  function clamp(v, min, max) {
    return v < min ? min : (v > max ? max : v);
  }

  function worldToScreen(pos) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const vector = pos.clone().project(CameraState.camera);
    const x = (vector.x + 1) * 0.5 * width;
    const y = (-vector.y + 1) * 0.5 * height;
    const rect = canvas.getBoundingClientRect();
    return { x: rect.left + x, y: rect.top + y };
  }

  function createDiv(className) {
    const el = document.createElement('div');
    if (className) el.className = className;
    document.body.appendChild(el);
    return el;
  }

  /********************
   * DOM / UI setup
   ********************/
  function cacheDomElements() {
    UI.coinCounter = document.getElementById('coin-count');
    UI.fishCounter = document.getElementById('fish-hud-count');
    UI.fishProgressFill = document.getElementById('fish-progress-fill');
    UI.playButton = document.getElementById('play-button');
    UI.gaugeWrapper = document.getElementById('gauge-wrapper');
    UI.gaugePointer = document.getElementById('gauge-pointer');
    UI.upgradeMaxFishBtn = document.getElementById('upgrade-max-fish');
    UI.upgradeMaxDepthBtn = document.getElementById('upgrade-max-depth');
    UI.tutorialOverlay = document.getElementById('tutorial-overlay');
    UI.summaryPanel = document.getElementById('summary-panel');
    UI.summaryFishList = document.getElementById('summary-fish-list');
    UI.summaryTotalAmount = document.getElementById('summary-total-amount');
    UI.endCard = document.getElementById('endcard');

    document.getElementById('cta-button').addEventListener('click', function() {
      // Stub click-through
    });
  }

  function showCoinHUD(show) {
    document.getElementById('coin-hud').style.display = show ? 'flex' : 'none';
  }

  function showFishHUD(show) {
    document.getElementById('fish-hud').style.display = show ? 'flex' : 'none';
  }

  function showGauge(show) {
    UI.gaugeWrapper.style.display = show ? 'flex' : 'none';
  }

  function showUpgradeButtons(show) {
    document.getElementById('upgrades').style.display = show ? 'flex' : 'none';
  }

  function showTutorialOverlay(show) {
    UI.tutorialOverlay.style.display = show ? 'flex' : 'none';
  }

  function showSummaryPanel(show) {
    UI.summaryPanel.style.display = show ? 'flex' : 'none';
  }

  function updateCoinCounterUI() {
    UI.coinCounter.textContent = GameState.coins | 0;
  }

  function updateFishCounterUI() {
    UI.fishCounter.textContent = GameState.fishCaughtCount + '/' + GameState.maxFish;
    const ratio = GameState.maxFish > 0 ? GameState.fishCaughtCount / GameState.maxFish : 0;
    UI.fishProgressFill.style.width = (ratio * 100) + '%';
  }

  function updateUpgradeButtonsUI() {
    // Max Fish
    const mfIdx = GameState.maxFishTierIndex;
    const mfBtn = UI.upgradeMaxFishBtn;
    const mfNextIdx = mfIdx + 1;
    if (mfNextIdx >= GameState.maxFishTiers.length) {
      mfBtn.classList.add('disabled');
      mfBtn.querySelector('.upgrade-desc').textContent = 'Maxed at ' + GameState.maxFish + ' fish';
    } else {
      const next = GameState.maxFishTiers[mfNextIdx];
      const delta = next.value - GameState.maxFish;
      mfBtn.querySelector('.upgrade-desc').textContent = 'Catch +' + delta + ' fish (' + next.cost + ')';
      if (GameState.coins >= next.cost) {
        mfBtn.classList.remove('disabled');
      } else {
        mfBtn.classList.add('disabled');
      }
    }

    // Max Depth
    const mdIdx = GameState.maxDepthTierIndex;
    const mdBtn = UI.upgradeMaxDepthBtn;
    const mdNextIdx = mdIdx + 1;
    if (mdNextIdx >= GameState.maxDepthTiers.length) {
      mdBtn.classList.add('disabled');
      mdBtn.querySelector('.upgrade-desc').textContent = 'Maxed at ' + GameState.maxDepth + 'm';
    } else {
      const nextD = GameState.maxDepthTiers[mdNextIdx];
      const deltaD = nextD.value - GameState.maxDepth;
      mdBtn.querySelector('.upgrade-desc').textContent = 'Depth +' + deltaD + 'm (' + nextD.cost + ')';
      if (GameState.coins >= nextD.cost) {
        mdBtn.classList.remove('disabled');
      } else {
        mdBtn.classList.add('disabled');
      }
    }
  }

  function updateGaugePointerUI(eased) {
    UI.gaugePointer.style.left = (eased * 100) + '%';
  }

  /********************
   * Three.js scene
   ********************/
  function setupThreeScene() {
    const canvas = document.getElementById('game-canvas');
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x002244, 0.07);

    const fov = 60;
    const aspect = canvas.clientWidth / canvas.clientHeight || 1;
    const near = 0.1;
    const far = 200;
    CameraState.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    CameraState.camera.position.set(0, 5, 16);
    CameraState.camera.lookAt(0, 0, 0);

    const ambient = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 10, 8);
    scene.add(dir);

    // Water plane (infinite-looking)
    const waterGeo = new THREE.PlaneGeometry(50, 50);
    const waterMat = new THREE.MeshPhongMaterial({
      color: 0x0288d1,
      transparent: true,
      opacity: 0.9,
      side: THREE.DoubleSide
    });
    const water = new THREE.Mesh(waterGeo, waterMat);
    water.rotation.x = -Math.PI / 2;
    water.position.y = 0;
    scene.add(water);

    // Boat
    const boatGeo = new THREE.BoxGeometry(4, 0.6, 2);
    const boatMat = new THREE.MeshPhongMaterial({ color: 0x5d4037 });
    const boat = new THREE.Mesh(boatGeo, boatMat);
    boat.position.set(0, 0.4, 0);
    scene.add(boat);

    // Fisherman (simple body + head)
    const bodyGeo = new THREE.BoxGeometry(0.6, 1.2, 0.4);
    const bodyMat = new THREE.MeshPhongMaterial({ color: 0x1e88e5 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.set(0, 1.4, 0);
    scene.add(body);

    const headGeo = new THREE.SphereGeometry(0.35, 16, 16);
    const headMat = new THREE.MeshPhongMaterial({ color: 0xffcc80 });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.set(0, 2.2, 0);
    scene.add(head);

    // Hook
    const hookGeo = new THREE.BoxGeometry(0.2, 0.4, 0.2);
    const hookMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
    HookState.mesh = new THREE.Mesh(hookGeo, hookMat);
    HookState.mesh.position.set(0, -0.5, 0);
    scene.add(HookState.mesh);

    // Line
    const lineGeo = new THREE.CylinderGeometry(0.03, 0.03, 5, 8);
    const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    HookState.lineMesh = new THREE.Mesh(lineGeo, lineMat);
    HookState.lineMesh.position.set(0, (0.4 - 2.5), 0); // anchored at boat to hook mid
    scene.add(HookState.lineMesh);
  }

  function createFishMesh(color) {
    const geo = new THREE.CapsuleGeometry(0.35, 0.8, 6, 12);
    const mat = new THREE.MeshPhongMaterial({ color });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.z = Math.PI / 2;
    return mesh;
  }

  function resize() {
    if (!renderer) return;
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    if (width === 0 || height === 0) return;
    renderer.setSize(width, height, false);
    CameraState.camera.aspect = width / height;
    CameraState.camera.updateProjectionMatrix();
  }

  window.addEventListener('resize', resize);

  /********************
   * Fish spawning
   ********************/
  function pickFishTypeForDepth(depth) {
    const candidates = FishTypes.filter(t => depth >= t.depthMin && depth <= t.depthMax);
    if (!candidates.length) return FishTypes[0];
    const idx = (Math.random() * candidates.length) | 0;
    return candidates[idx];
  }

  function prepareFishForCast() {
    for (const f of fishEntities) {
      scene.remove(f.mesh);
    }
    fishEntities.length = 0;

    const depthSpan = GameState.maxDepth * 1.2;
    const numFish = 22;
    for (let i = 0; i < numFish; i++) {
      const depth = Math.random() * depthSpan;
      const type = pickFishTypeForDepth(depth);
      const mesh = createFishMesh(type.color);
      const x = worldMinX + Math.random() * (worldMaxX - worldMinX);
      const y = -depth;
      mesh.position.set(x, y, 0);
      scene.add(mesh);
      fishEntities.push({
        id: i,
        type,
        mesh,
        x,
        depth,
        caught: false,
        value: type.baseValue
      });
    }
  }

  function updateFishIdle(dt) {
    const time = performance.now() / 1000;
    for (const fish of fishEntities) {
      if (fish.caught) continue;
      const sway = Math.sin(time * 1.5 + fish.id) * 0.2;
      fish.mesh.position.x = fish.x + sway;
    }
  }

  /********************
   * Hook & camera
   ********************/
  function updateHookWorldPosition() {
    const worldY = -GameState.hookDepth;
    HookState.mesh.position.set(GameState.hookX, worldY, 0);

    const lineLen = (0.4 - worldY);
    HookState.lineMesh.scale.set(1, Math.abs(lineLen) / 5, 1);
    HookState.lineMesh.position.set(0, (0.4 + worldY) / 2, 0);
  }

  function updateCamera(dt) {
    const targetY = HookState.mesh.position.y + 3;
    const cam = CameraState.camera;
    const dy = targetY - cam.position.y;
    cam.position.y += dy * Math.min(1, CameraState.followSpeed * dt);
    cam.lookAt(0, HookState.mesh.position.y, 0);
  }

  /********************
   * Catch & collisions
   ********************/
  function attachFishToHook(fish) {
    const mesh = fish.mesh;
    mesh.position.set(0, -0.4 - 0.3 * (GameState.fishCaughtCount - 1), 0);
    mesh.rotation.set(0, 0, 0);
    HookState.mesh.add(mesh);
  }

  function spawnCatchPopEffect(fish) {
    const worldPos = new THREE.Vector3();
    fish.mesh.getWorldPosition(worldPos);
    const screenPos = worldToScreen(worldPos);
    const el = createDiv('catch-pop');
    const label = '+' + fish.value + (fish.type.rarityLabel ? ' ' + fish.type.rarityLabel : '');
    el.textContent = label;
    el.style.left = screenPos.x + 'px';
    el.style.top = screenPos.y + 'px';
    el.addEventListener('animationend', () => {
      if (el.parentNode) el.parentNode.removeChild(el);
    });
  }

  function spawnCoinBurstAt(pos) {
    const screenPos = worldToScreen(pos);
    for (let i = 0; i < 4; i++) {
      const el = createDiv('coin-burst');
      el.style.left = screenPos.x + 'px';
      el.style.top = screenPos.y + 'px';
      el.style.animationDelay = (Math.random() * 0.1) + 's';
      el.addEventListener('animationend', () => {
        if (el.parentNode) el.parentNode.removeChild(el);
      });
    }
  }

  function checkFishCollisions() {
    const hookPos = new THREE.Vector3();
    HookState.mesh.getWorldPosition(hookPos);
    const hookRadius = 0.5;

    for (const fish of fishEntities) {
      if (fish.caught) continue;
      const fishPos = new THREE.Vector3();
      fish.mesh.getWorldPosition(fishPos);
      const dx = fishPos.x - hookPos.x;
      const dy = fishPos.y - hookPos.y;
      const distSq = dx*dx + dy*dy;
      const radius = hookRadius + 0.5;
      if (distSq <= radius * radius) {
        catchFish(fish);
        if (GameState.fishCaughtCount >= GameState.maxFish) {
          break;
        }
      }
    }
  }

  function catchFish(fish) {
    fish.caught = true;
    GameState.fishCaught.push(fish);
    GameState.fishCaughtCount++;
    attachFishToHook(fish);
    updateFishCounterUI();
    spawnCatchPopEffect(fish);
  }

  /********************
   * Phases
   ********************/
  function enterSetupPhase() {
    GameState.currentState = 'GAMEPLAY';
    GameState.currentPhase = 'SETUP';
    GameState.fishCaught.length = 0;
    GameState.fishCaughtCount = 0;
    GameState.hookDepth = 0;
    GameState.hookX = 0;
    HookState.horizontalTargetX = 0;
    updateHookWorldPosition();

    showCoinHUD(true);
    showFishHUD(false);
    showGauge(false);
    showUpgradeButtons(true);
    showSummaryPanel(false);
    UI.playButton.style.display = 'inline-block';
    UI.playButton.textContent = 'CAST';

    updateCoinCounterUI();
    updateFishCounterUI();
    updateUpgradeButtonsUI();
  }

  function startGaugePhase() {
    GameState.currentPhase = 'GAUGE';
    gaugeTime = 0;
    gaugeDirection = 1;
    showGauge(true);
    showUpgradeButtons(false);
    UI.playButton.textContent = 'STOP';
  }

  function lockGaugeAndStartCast() {
    const t = clamp(gaugeTime / gaugeDuration, 0, 1);
    const eased = easeInOutQuad(t);
    const minDepth = Math.max(1, GameState.maxDepth - 2);
    const maxDepth = GameState.maxDepth;
    GameState.selectedDepth = minDepth + (maxDepth - minDepth) * eased;

    showGauge(false);
    showCoinHUD(false);
    showFishHUD(true);

    prepareFishForCast();
    enterCastDownPhase();
  }

  function enterCastDownPhase() {
    GameState.currentPhase = 'CAST_DOWN';
    HookState.verticalSpeed = GameState.hookSpeedDown;
  }

  function updateCastDownPhase(dt) {
    GameState.hookDepth += HookState.verticalSpeed * dt;
    if (GameState.hookDepth >= GameState.selectedDepth) {
      GameState.hookDepth = GameState.selectedDepth;
      enterPauseAtDepthPhase();
    }
    updateHookWorldPosition();
  }

  function enterPauseAtDepthPhase() {
    GameState.currentPhase = 'PAUSE_AT_DEPTH';
    pauseTimer = 0;
    if (!GameState.tutorialShown && GameState.round === 1) {
      showTutorialOverlay(true);
    }
  }

  function updatePauseAtDepthPhase(dt) {
    pauseTimer += dt;
    const targetPause = (GameState.round === 1 ? 2.0 : 0.8);
    if (pauseTimer >= targetPause) {
      enterAscendPhase();
    }
  }

  function enterAscendPhase() {
    GameState.currentState = 'GAMEPLAY';
    GameState.currentPhase = 'ASCEND';
    HookState.verticalSpeed = -GameState.hookSpeedUp;
    showTutorialOverlay(false);
  }

  function updateAscendPhase(dt) {
    GameState.hookDepth += HookState.verticalSpeed * dt;
    if (GameState.hookDepth <= 0) {
      GameState.hookDepth = 0;
      updateHookWorldPosition();
      showFishHUD(false);
      showCoinHUD(true);
      enterSurfaceSummaryPhase();
      return;
    }

    const dx = HookState.horizontalTargetX - GameState.hookX;
    GameState.hookX += dx * Math.min(1, HookState.horizontalSpeed * dt);

    updateHookWorldPosition();
    checkFishCollisions();

    if (GameState.fishCaughtCount >= GameState.maxFish) {
      HookState.verticalSpeed = -GameState.hookSpeedUp * 2;
    }
  }

  function enterSurfaceSummaryPhase() {
    GameState.currentPhase = 'SURFACE_SUMMARY';

    SummaryState.step = 0;
    SummaryState.timer = 0;
    SummaryState.addedToCoins = false;
    SummaryState.totalRoundCoins = GameState.fishCaught.reduce((sum, f) => sum + f.value, 0);

    // Build simple text list of catches
    if (GameState.fishCaught.length === 0) {
      UI.summaryFishList.textContent = 'No fish this time. Cast deeper or upgrade your gear.';
    } else {
      const parts = [];
      const countsByType = {};
      for (const f of GameState.fishCaught) {
        countsByType[f.type.id] = (countsByType[f.type.id] || 0) + 1;
      }
      for (const type of FishTypes) {
        if (countsByType[type.id]) {
          const label = (type.rarityLabel ? type.rarityLabel + ' ' : '') + type.id;
          parts.push(countsByType[type.id] + '× ' + label);
        }
      }
      UI.summaryFishList.textContent = parts.join(' • ');
    }

    currentDisplayTotal = 0;
    UI.summaryTotalAmount.textContent = '0';
    showSummaryPanel(true);

    // Coin bursts for each caught fish
    for (const f of GameState.fishCaught) {
      const worldPos = new THREE.Vector3();
      f.mesh.getWorldPosition(worldPos);
      spawnCoinBurstAt(worldPos);
    }
  }

  function updateSurfaceSummaryPhase(dt) {
    SummaryState.timer += dt;
    switch (SummaryState.step) {
      case 0:
        if (SummaryState.timer >= 0.3) {
          SummaryState.step = 1;
          SummaryState.timer = 0;
        }
        break;
      case 1:
        updateTotalCountUp(dt);
        if (currentDisplayTotal >= SummaryState.totalRoundCoins) {
          SummaryState.step = 2;
          SummaryState.timer = 0;
        }
        break;
      case 2:
        if (SummaryState.timer >= 0.7) {
          finishRoundAndAdvance();
        }
        break;
    }
  }

  function updateTotalCountUp(dt) {
    const target = SummaryState.totalRoundCoins;
    if (target <= 0) {
      if (!SummaryState.addedToCoins) {
        SummaryState.addedToCoins = true;
      }
      currentDisplayTotal = 0;
      UI.summaryTotalAmount.textContent = '0';
      return;
    }
    const speed = target / 0.6;
    currentDisplayTotal += speed * dt;
    if (currentDisplayTotal >= target) {
      currentDisplayTotal = target;
      if (!SummaryState.addedToCoins) {
        SummaryState.addedToCoins = true;
        GameState.coins += target;
        updateCoinCounterUI();
      }
    }
    UI.summaryTotalAmount.textContent = Math.floor(currentDisplayTotal);
  }

  function finishRoundAndAdvance() {
    GameState.round++;
    if (GameState.round > GameState.maxRounds) {
      enterEndCard();
    } else {
      enterSetupPhase();
    }
  }

  function enterEndCard() {
    GameState.currentState = 'ENDCARD';
    GameState.currentPhase = '';
    showSummaryPanel(false);
    document.getElementById('bottom-panel').style.display = 'none';
    UI.endCard.style.display = 'flex';
  }

  /********************
   * Tutorial
   ********************/
  function updateTutorial(dt) {
    if (pauseTimer >= 2.0) {
      showTutorialOverlay(false);
      GameState.tutorialShown = true;
      GameState.currentState = 'GAMEPLAY';
    }
  }

  /********************
   * Inputs
   ********************/
  function onPlayButtonClick() {
    if (GameState.currentState !== 'GAMEPLAY') return;
    if (GameState.currentPhase === 'SETUP') {
      startGaugePhase();
    } else if (GameState.currentPhase === 'GAUGE') {
      lockGaugeAndStartCast();
    }
  }

  function onUpgradeMaxFish() {
    if (GameState.currentPhase !== 'SETUP') return;
    const nextIndex = GameState.maxFishTierIndex + 1;
    if (nextIndex >= GameState.maxFishTiers.length) return;
    const tier = GameState.maxFishTiers[nextIndex];
    if (GameState.coins < tier.cost) return;
    GameState.coins -= tier.cost;
    GameState.maxFishTierIndex = nextIndex;
    GameState.maxFish = tier.value;
    updateCoinCounterUI();
    updateUpgradeButtonsUI();
    updateFishCounterUI();
  }

  function onUpgradeMaxDepth() {
    if (GameState.currentPhase !== 'SETUP') return;
    const nextIndex = GameState.maxDepthTierIndex + 1;
    if (nextIndex >= GameState.maxDepthTiers.length) return;
    const tier = GameState.maxDepthTiers[nextIndex];
    if (GameState.coins < tier.cost) return;
    GameState.coins -= tier.cost;
    GameState.maxDepthTierIndex = nextIndex;
    GameState.maxDepth = tier.value;
    updateCoinCounterUI();
    updateUpgradeButtonsUI();
  }

  function pointerToWorldX(clientX) {
    const root = document.getElementById('game-root');
    const rect = root.getBoundingClientRect();
    const norm = clamp((clientX - rect.left) / rect.width, 0, 1); // 0..1
    return worldMinX + norm * (worldMaxX - worldMinX);
  }

  function onPointerMove(e) {
    if (GameState.currentState !== 'GAMEPLAY') return;
    if (GameState.currentPhase !== 'ASCEND') return;
    let clientX;
    if (e.touches && e.touches.length > 0) {
      clientX = e.touches[0].clientX;
    } else if (e.clientX != null) {
      clientX = e.clientX;
    } else {
      return;
    }
    HookState.horizontalTargetX = pointerToWorldX(clientX);
    if (e.cancelable) e.preventDefault();
  }

  function setupEventListeners() {
    UI.playButton.addEventListener('click', onPlayButtonClick);
    UI.upgradeMaxFishBtn.addEventListener('click', onUpgradeMaxFish);
    UI.upgradeMaxDepthBtn.addEventListener('click', onUpgradeMaxDepth);

    const root = document.getElementById('game-root');
    root.addEventListener('touchstart', onPointerMove, { passive: false });
    root.addEventListener('touchmove', onPointerMove, { passive: false });
    root.addEventListener('mousemove', onPointerMove);
  }

  /********************
   * Game loop
   ********************/
  function update(dt) {
    if (GameState.currentState === 'GAMEPLAY') {
      updateFishIdle(dt);
      switch (GameState.currentPhase) {
        case 'SETUP':
          break;
        case 'GAUGE':
          gaugeTime += dt * gaugeDirection;
          if (gaugeTime > gaugeDuration) {
            gaugeTime = gaugeDuration;
            gaugeDirection = -1;
          } else if (gaugeTime < 0) {
            gaugeTime = 0;
            gaugeDirection = 1;
          }
          const t = clamp(gaugeTime / gaugeDuration, 0, 1);
          updateGaugePointerUI(easeInOutQuad(t));
          break;
        case 'CAST_DOWN':
          updateCastDownPhase(dt);
          break;
        case 'PAUSE_AT_DEPTH':
          updatePauseAtDepthPhase(dt);
          break;
        case 'ASCEND':
          updateAscendPhase(dt);
          break;
        case 'SURFACE_SUMMARY':
          updateSurfaceSummaryPhase(dt);
          break;
      }
      updateCamera(dt);
    } else if (GameState.currentState === 'TUTORIAL') {
      updateTutorial(dt);
      updateCamera(dt);
    }
  }

  function render() {
    renderer.render(scene, CameraState.camera);
  }

  function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    update(dt);
    render();
    requestAnimationFrame(gameLoop);
  }

  /********************
   * Init
   ********************/
  function init() {
    cacheDomElements();
    setupThreeScene();
    setupEventListeners();
    resize();

    GameState.currentState = 'GAMEPLAY';
    GameState.currentPhase = 'SETUP';
    enterSetupPhase();

    requestAnimationFrame(gameLoop);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>
</body>
</html>