## Critical Analysis of the PRD

Key points and implications for implementation:

1. **Core Loop & Rounds**
   - 3 fishing rounds total. After the 3rd round’s summary, transition to end card.
   - Between rounds: player can buy upgrades (max fish / max depth) with coins.
   - Each round:  
     1) Adjust power gauge → choose depth  
     2) Hook descends, camera follows  
     3) Hook pauses at depth (tutorial overlay in round 1 only)  
     4) Hook ascends; player drags horizontally to catch fish until max fish reached  
     5) Surface summary: individual fish animations, coin bursts, total coins added.

2. **Economy & Progression**
   - Start with 100 coins.
   - Max fish capacity starts at 6; upgrades cost coins.
   - Max depth starts at 5m; upgrades cost coins.
   - Need fish models with `value`, possibly `rarity` affecting bonus text ("rare!", "legendary!").
   - Duration is short (playable ad), so we can simplify: small set of fish types and fixed upgrade tiers.

3. **UI Constraints**
   - Coin counter visible in hub/upgrade mode and during gauge selection.
   - Fish counter (with fill bar) replaces coin counter during active fishing (descent + ascent).
   - On ascent, fish count increments, bar fills relative to `maxFish`.
   - Right before surfacing, UI swaps back to coin counter.

4. **3D Requirement**
   - Fisherman and fishes must be **3D**, but can be simple shapes (cubes, cylinders, etc.).
   - This strongly suggests using WebGL via a small library (e.g., **Three.js** from CDN) for 3D rendering.
   - Hook/line, background, UI can be 2D or simple overlays.

5. **Single-file, mobile-first**
   - All code, CSS, and required assets must live in a single HTML file.
   - No external image assets; we will use:
     - Code-drawn Canvas shapes or Three.js primitive geometry.
     - Inline SVG for crisp HUD icons / gauges.
     - Pure CSS or base64 placeholders only if absolutely needed (e.g., icons).
   - Must handle portrait & landscape, and be tuned for touch (prevent 300ms delay, use pointer/touch events, avoid heavy allocations per frame).

6. **State & Tutorial**
   - Must use a **State Machine**: `LOADING`, `TUTORIAL`, `GAMEPLAY`, `ENDCARD` (with sub-states inside GAMEPLAY).
   - Only first round has a tutorial overlay at bottom depth.
   - Need clean transitions: no overlapping input or UI.

7. **Interactions**
   - Primary actions:
     - Tap/press **Play** to stop gauge and start fishing.
     - Drag horizontally to move hook during ascent.
     - Tap upgrades between rounds.
   - Interaction must drive state transitions (e.g., gauge → descent, summary → next round).

---

## High-Level Technical Architecture

### 1. Tech Stack

- **Base:** Vanilla JS (no build tools), single HTML file.
- **Rendering:**
  - **3D elements (fisherman, fish, hook, line, sea environment):**  
    - **Three.js via CDN** (lightweight minified build).
  - **2D UI / HUD (counters, buttons, gauge, tutorial labels, rarity text):**
    - HTML/CSS with inline SVG for icons/gauge.
  - **Optional Effects (small particles):**  
    - Either Three.js sprites/planes or 2D Canvas overlay; we’ll keep it simple with small 3D billboards or CSS transitions.

- **Input:**
  - Pointer events (`pointerdown`, `pointermove`, `pointerup`) for both mouse and touch.
  - No external libraries for gestures.

- **Game Loop:**
  - Single `requestAnimationFrame` loop managing:
    - Game state updates.
    - 3D scene updates & rendering.
    - Simple 2D UI animations.

---

### 2. Game States & State Machine

We’ll define an enum-like constant for states:

```js
const GameState = Object.freeze({
  LOADING: 0,
  TUTORIAL: 1,   // covers first-round tutorial overlay
  GAMEPLAY: 2,   // inclusive of pre-round hub, fishing, summary, etc.
  ENDCARD: 3
});
```

Within `GAMEPLAY`, we’ll use a sub-state enum:

```js
const GameplaySubState = Object.freeze({
  HUB: 0,            // upgrades & play gauge visible
  GAUGE_ACTIVE: 1,   // pointer moving on gauge, awaiting tap
  DESCENT: 2,        // hook going down, camera following
  AT_DEPTH_PAUSE: 3, // brief pause at bottom
  ASCENT: 4,         // hook coming up; user drags to catch fish
  SURFACE_SUMMARY: 5,// fish tally animations
  ROUND_TRANSITION: 6// finalizing coins, moving to next round or endcard
});
```

We will always refer to these enums instead of magic numbers or strings.

---

### 3. Core Systems Overview

1. **App / State Manager**
   - Keeps `currentState`, `gameplaySubState`, and `currentRound` (1–3).
   - Handles transitions:
     - `LOADING` → `TUTORIAL` (round1) or `GAMEPLAY` if tutorial overlay merges.
     - `TUTORIAL` → `GAMEPLAY/HUB`.
     - `GAMEPLAY/ROUND_TRANSITION` → next round or `ENDCARD`.
   - Owns top-level lifecycle functions:
     - `init()`
     - `preload()`
     - `create()`
     - `update(dt)`
     - `render()`

2. **3D Scene Manager**
   - Responsible for:
     - `scene`, `camera`, `renderer`.
     - Light setup.
     - Fisherman 3D model (primitive shapes).
     - Hook + fishing line (cylinder + line or narrow box).
     - Environmental elements (water gradient plane, distant background).
     - Fish pools (3D fish instances reused between rounds).
   - Provides API:
     - `setHookDepth(depthMeters)` → updates hook Y position.
     - `setCameraFollowHook(isFollowing)` and smooth follow logic.
     - `spawnFishField(depthConfig)` sets fish positions and types per round/depth.
     - `attachFishToHook(fish)` attaches fish model to hook for ascent.

3. **Game Data & Entities Manager**

   - Central data structures:

     ```js
     const MAX_ROUNDS = 3;

     const UpgradeType = Object.freeze({
       MAX_FISH: 0,
       MAX_DEPTH: 1
     });

     const rarityTexts = ["", "Rare!", "Amazing!", "Legendary!"];

     const fishTypes = [
       { id: 0, name: "Small",  baseValue: 5,  rarityIndex: 0, depthMin: 0,  depthMax: 10 },
       { id: 1, name: "Medium", baseValue: 10, rarityIndex: 1, depthMin: 5,  depthMax: 20 },
       { id: 2, name: "Big",    baseValue: 20, rarityIndex: 2, depthMin: 10, depthMax: 30 },
       { id: 3, name: "Deep",   baseValue: 40, rarityIndex: 3, depthMin: 15, depthMax: 40 }
     ];

     const maxFishUpgradeSteps = [
       { value: 6, cost: 0 },
       { value: 7, cost: 50 },
       { value: 8, cost: 100 },
       { value: 9, cost: 200 },
       { value: 10, cost: 400 }
     ];

     const maxDepthUpgradeSteps = [
       { value: 5,  cost: 0 },
       { value: 10, cost: 50 },
       { value: 15, cost: 75 },
       { value: 20, cost: 150 },
       { value: 30, cost: 300 }
     ];
     ```

   - Runtime game state:

     ```js
     const gameData = {
       coins: 100,
       roundIndex: 0,       // 0..2
       maxFishIndex: 0,     // index into maxFishUpgradeSteps
       maxDepthIndex: 0,    // index into maxDepthUpgradeSteps
       currentRoundCatch: [], // array of FishInstance
     };

     class FishInstance {
       constructor(typeRef, initialPosition) {
         this.type = typeRef;         // reference to fishTypes entry
         this.position = initialPosition; // 3D vector in scene
         this.isCaught = false;
         this.attachedToHook = false;
         this.value = typeRef.baseValue;
         this.rarityIndex = typeRef.rarityIndex;
         this.mesh = null; // Three.js mesh
       }
     }
     ```

4. **UI / HUD Manager**

   - HTML structure created at `create()`:
     - Coin counter container (`#coinCounter`):
       - Icon (SVG or simple circle).
       - Text label with current coin count.
     - Fish counter (`#fishCounter`), hidden initially:
       - Fish icon.
       - Text current fish count.
       - Progress bar:
         - Outer rounded rect (div).
         - Inner bar width scaled to `currentFish / maxFish`.
     - Gauge & Play button (`#gaugeContainer`):
       - SVG gauge bar with pointer.
       - Play button overlay capturing taps.
     - Upgrade buttons (`#upgradeMaxFish`, `#upgradeMaxDepth`):
       - Current value, next cost, disabled state if not enough coins or at max.
     - Tutorial overlay (`#tutorialOverlay`) text “Move the hook to catch fish”.
     - Rarity / feedback labels near center (`#rarityLabel`), simple fade in/out.
     - Summary panel (`#summaryPanel`) for end-of-round tallies.
     - End card CTA (`#endCard`) for final state.

   - Provides:
     - `showCoinCounter()`, `showFishCounter()`.
     - `updateCoinDisplay(coins)`.
     - `updateFishCounter(caught, max)`.
     - `updateGaugePointer(normalizedValue)` (0–1 from min to max to min; see below).
     - `showTutorial()`, `hideTutorial()`.
     - `showSummary(fishList)`, `updateSummaryCounter(progress)`.

5. **Input Manager**

   - Translates raw pointer events into game-intent:
     - Taps on Play gauge.
     - Taps on upgrade buttons.
     - Horizontal drag events while `gameplaySubState === GameplaySubState.ASCENT`.

   - Implementation:
     ```js
     const inputState = {
       isDraggingHook: false,
       lastPointerX: 0
     };

     window.addEventListener('pointerdown', onPointerDown);
     window.addEventListener('pointermove', onPointerMove);
     window.addEventListener('pointerup', onPointerUp);
     ```

   - Hooks:
     - `onGaugeTap()` (stop pointer, choose depth).
     - `onUpgradeClick(type)`.
     - `onHookDrag(deltaX)` (maps to horizontal hook movement).

6. **Animation & Timing Manager**

   - Simple timings:
     - At-depth pause: 2s for 1st round (tutorial), 0.5–1s for subsequent.
     - Hook descent/ascent speeds based on depth chosen.
     - Particle-like bursts: simple scale+fade for coin/fish.
     - Counter lerp for coin count summary.

   - Data structure:
     ```js
     const timers = {
       stateStartTime: 0,
       atDepthDuration: 0,
       summaryTimer: 0
     };
     ```

---

## Assets & Rendering Strategy

### 1. Fisherman & Hook (3D)

- **Technology:** Three.js primitives, no external textures.

- **Fisherman:**
  - Body: vertical cylinder.
  - Head: sphere.
  - Arms: thin boxes.
  - Simple one-color materials (`MeshStandardMaterial` or `MeshLambertMaterial`).
  - Positioned slightly above water plane.

- **Boat (optional):**
  - Simple flattened box as hull.

- **Hook & Line:**
  - Line: thin cylinder from boat down into water.
  - Hook: small bent geometry approximated with:
    - Torus segment or combined boxes.
    - Single color.

- **Animation:**
  - Fisherman idle: slight sway (sinusoidal rotation).
  - Hook/line: hook Y position updates; line scales along Y accordingly.

### 2. Fish (3D)

- **Technology:** Three.js primitives.

- Each fish type:
  - Body: stretched sphere / capsule (e.g., `SphereGeometry` scaled).
  - Tail: narrow pyramidal or triangulated box.
  - Color scheme based on rarity (e.g., grey, blue, purple, gold).
  - Slight scale breathing animation (`scale.set` with sin wave) even when idle.

- Fish motion:
  - Idle: slow small amplitude horizontal/vertical movement (sin-based).
  - When caught: move to hook position and attach; maybe small bounce relative to hook.

### 3. Environment (3D & 2D)

- **Water:**
  - Large plane under fisherman with gradient-like color via vertex colors or simple color.
  - Optional fog effect with different depth shading.

- **Background:**
  - Solid gradient via CSS background on canvas container or a big sky plane.

### 4. UI & HUD (2D)

- **Technology:** HTML/CSS + inline SVG.

- Coin icon:
  - Simple SVG circle with inner circle.

- Gauge:
  - SVG rectangle bar.
  - Moving pointer is an SVG triangle or line within container; we animate via CSS transform or JS `style.transform`.

- Progress bar:
  - CSS `div` with `overflow:hidden`; inner bar width set by percent.

- Rarity labels / tutorial:
  - HTML text overlays with fade via CSS classes (`opacity` + `transition`).

- No bitmap images; no need for base64 placeholders beyond maybe a logo/CTA icon if requested. For now we can generate everything via SVG or CSS.

---

## Coordinate & Depth System

- Define a simple world space:
  - Y=0: water surface / fisherman.
  - Positive Y downward into water:
    - Depth in meters maps linearly: 1 meter ≈ fixed world units.
  - For example: 1m → 1 unit; max depth of 30m → Y≈30.

- Camera:
  - Ortho or Perspective; for simplicity, use **Perspective** with:
    - Default `camera.position.set(0, -3, 15)`.
    - When following hook, `camera.position.y` smoothly lerps toward `hook.position.y - offset`.

- Horizontal movement:
  - Limit hook X from -maxX to +maxX (e.g., -5 to +5).
  - Map drag delta X (pixels) to world X offset with clamping.

---

## Gameplay Flow & System Implementation

### 1. Overall Lifecycle Functions

We’ll follow an engine-like structure:

```js
function init() {
  initRendererAndScene();
  initUI();
  bindEvents();
  currentState = GameState.LOADING;
  preload();
}

function preload() {
  // Minimal: we generate geometry; no heavy assets.
  // Could create all meshes here.
  create();
}

function create() {
  setup3DObjects();
  setupGameData();
  switchToTutorialOrGameplay();
  requestAnimationFrame(gameLoop);
}

function gameLoop(timestamp) {
  const dt = computeDeltaTime(timestamp);
  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}

function update(dt) {
  switch(currentState) {
    case GameState.LOADING:
      // Immediately transition once setup done
      break;
    case GameState.TUTORIAL:
      updateTutorial(dt);
      break;
    case GameState.GAMEPLAY:
      updateGameplay(dt);
      break;
    case GameState.ENDCARD:
      updateEndcard(dt);
      break;
  }
}

function render() {
  renderer.render(scene, camera);
  // UI is handled via DOM; only 3D needs explicit render
}
```

---

### 2. Gauge Interaction & Depth Selection

#### Gauge Logic

- Pointer oscillates from left (min) to right (max) and back:
  - Use a normalized t in [0, 1] for a full forward-back cycle.
  - Map to position: `p = t < 0.5 ? (t * 2) : (1 - (t - 0.5)*2)` to get min→max→min.

- Implementation data:

```js
const gaugeState = {
  active: false,
  t: 0,                 // 0..1
  speed: 0.5,           // cycles per second
  selectedNorm: null    // selected normalized depth [0..1]
};
```

#### Update:

```js
function updateGauge(dt) {
  if (!gaugeState.active) return;
  gaugeState.t += dt * gaugeState.speed;
  gaugeState.t %= 1;
  let phase = gaugeState.t < 0.5 ? (gaugeState.t * 2) : (1 - (gaugeState.t - 0.5)*2);
  // phase now in [0,1] left->right->left
  ui.updateGaugePointer(phase);
}
```

#### On Play Tap:

- Stop gauge, compute depth:

```js
function onGaugeTap() {
  if (gameplaySubState !== GameplaySubState.GAUGE_ACTIVE) return;

  gaugeState.active = false;
  const maxDepth = maxDepthUpgradeSteps[gameData.maxDepthIndex].value;
  const minDepth = Math.max(0, maxDepth - 2); // ensures >= 0
  const depthRange = maxDepth - minDepth;

  const depthNorm = ui.getCurrentGaugePhase(); // same as `phase`
  const selectedDepth = minDepth + depthRange * depthNorm; // meters

  startDescent(selectedDepth);
}
```

---

### 3. Descent & Camera Follow

```js
let hookState = {
  depthTarget: 0,
  depthCurrent: 0,
  speedDown: 10,  // m/s
  speedUp: 12,    // m/s base, will change when full
  atDepthTimer: 0,
  caughtFishCount: 0,
  maxFishThisRound: () => maxFishUpgradeSteps[gameData.maxFishIndex].value,
  fishOnLine: [] // FishInstance attached
};

function startDescent(selectedDepth) {
  hookState.depthTarget = selectedDepth;
  hookState.depthCurrent = 0;
  hookState.caughtFishCount = 0;
  hookState.fishOnLine.length = 0;

  // UI swap counters
  ui.showFishCounter();
  ui.hideCoinCounter();
  ui.setFishCounter(0, hookState.maxFishThisRound());

  gameplaySubState = GameplaySubState.DESCENT;
  timers.stateStartTime = performance.now();
}

function updateDescent(dt) {
  // Move hook down
  hookState.depthCurrent = Math.min(
    hookState.depthTarget,
    hookState.depthCurrent + hookState.speedDown * dt
  );
  sceneManager.setHookDepth(hookState.depthCurrent);
  sceneManager.updateCameraFollow(hookState.depthCurrent);

  if (hookState.depthCurrent >= hookState.depthTarget - 0.01) {
    enterAtDepthPause();
  }
}
```

---

### 4. At-Depth Pause & Tutorial

```js
function enterAtDepthPause() {
  gameplaySubState = GameplaySubState.AT_DEPTH_PAUSE;

  const isFirstRound = (gameData.roundIndex === 0);
  timers.atDepthDuration = isFirstRound ? 2.0 : 0.7;
  timers.stateStartTime = performance.now();

  if (isFirstRound) {
    ui.showTutorial("Move the hook to catch fish");
  }
}

function updateAtDepthPause(dt) {
  const elapsed = (performance.now() - timers.stateStartTime) / 1000;
  if (elapsed >= timers.atDepthDuration) {
    if (gameData.roundIndex === 0) {
      ui.hideTutorial();
    }
    startAscent();
  }
}
```

---

### 5. Ascent & Hook Drag

```js
function startAscent() {
  gameplaySubState = GameplaySubState.ASCENT;
  // Optionally generate fish population here or earlier at round start
  // sceneManager.spawnFishField(...);
}

function updateAscent(dt) {
  // Move hook up
  hookState.depthCurrent = Math.max(
    0,
    hookState.depthCurrent - hookState.speedUp * dt
  );
  sceneManager.setHookDepth(hookState.depthCurrent);
  sceneManager.updateCameraFollow(hookState.depthCurrent);

  // Hook horizontal move based on last drag:
  sceneManager.updateHookHorizontalPosition();

  // Collision check vs fish
  handleFishCollisions();

  // When max fish reached, accelerate to surface & disable further catching
  if (hookState.caughtFishCount >= hookState.maxFishThisRound()) {
    hookState.speedUp = 25; // speed boost
    disableFurtherCatching();
  }

  if (hookState.depthCurrent <= 0.01) {
    preSurfaceSwapCounters();
    enterSurfaceSummary();
  }
}
```

#### Input for Hook Drag

```js
function onPointerDown(ev) {
  if (gameplaySubState === GameplaySubState.ASCENT) {
    inputState.isDraggingHook = true;
    inputState.lastPointerX = ev.clientX;
  }
}

function onPointerMove(ev) {
  if (!inputState.isDraggingHook) return;
  const dx = ev.clientX - inputState.lastPointerX;
  inputState.lastPointerX = ev.clientX;
  onHookDrag(dx);
}

function onPointerUp(ev) {
  inputState.isDraggingHook = false;
}

function onHookDrag(deltaX) {
  // Convert screen delta to world delta
  const worldDeltaX = deltaX * 0.02; // tuning factor
  sceneManager.moveHookHorizontally(worldDeltaX);
}
```

---

### 6. Fish Collision & Catching

- We'll do simple distance checks per frame:
  - For each `FishInstance` not yet caught:
    - If distance between fish position and hook position < threshold → catch.

```js
function handleFishCollisions() {
  if (!catchingEnabled) return;
  if (hookState.caughtFishCount >= hookState.maxFishThisRound()) return;

  const hookPos = sceneManager.getHookPosition();

  for (const fish of fishPool) {
    if (fish.isCaught) continue;
    const distSq = fish.position.distanceToSquared(hookPos);
    if (distSq < 0.5 * 0.5) { // threshold radius=0.5
      catchFish(fish);
      if (hookState.caughtFishCount >= hookState.maxFishThisRound()) {
        break;
      }
    }
  }
}

function catchFish(fish) {
  fish.isCaught = true;
  fish.attachedToHook = true;
  hookState.caughtFishCount++;
  hookState.fishOnLine.push(fish);
  gameData.currentRoundCatch.push(fish);

  sceneManager.attachFishToHook(fish);

  // Update fish counter
  ui.setFishCounter(hookState.caughtFishCount, hookState.maxFishThisRound());

  // Show effect: bounce value & rarity text
  showCatchEffect(fish);
}

function showCatchEffect(fish) {
  const label = rarityTexts[fish.rarityIndex] || "";
  if (label) {
    ui.showRarityLabel(label); // fade-in/out
  }
  // Optionally: small popup "+X" near hook; we can position overlay approximately center.
}
```

To disable catching once full:

```js
let catchingEnabled = true;

function disableFurtherCatching() {
  catchingEnabled = false;
}
```

---

### 7. Pre-Surface Counter Swap & Summary State

Just before arriving at surface, the spec says:

> just before the hook+fish arrive to the surface the fish counter will be replaced by the coin counter.

Implementation:

```js
function preSurfaceSwapCounters() {
  ui.hideFishCounter();
  ui.showCoinCounter();
}
```

Then, once depth reaches near 0:

```js
function enterSurfaceSummary() {
  gameplaySubState = GameplaySubState.SURFACE_SUMMARY;
  timers.summaryTimer = 0;
  // Freeze camera at surface
  sceneManager.snapCameraToSurface();

  // Prepare UI summary
  ui.showSummary(gameData.currentRoundCatch);
}
```

Summary sequence:

1. Iterate through `currentRoundCatch` fish:
   - Animate each fish jumping slightly (Y offset / rotation).
   - Show value text (`+value`) near them.
   - If they have rarity label, show again in summary.
   - Coin burst effect: expand/fade small coin circles around fish.

2. After all fish individually processed, show total coin gain with counting animation from 0 → sum.

3. Animate coins flying from total to main coin counter:
   - Represented by 2D elements moving along a cubic Bezier or simple linear path; or simple CSS `transform` transitions.

4. At the end, apply coin gain to `gameData.coins`, update display, clear `currentRoundCatch`.

Pseudo:

```js
function updateSurfaceSummary(dt) {
  timers.summaryTimer += dt;

  // Delegate to UI to step through staged animations.
  const done = ui.updateSummaryAnimation(dt, gameData.currentRoundCatch, gameData);
  if (done) {
    finishRound();
  }
}

function finishRound() {
  gameData.roundIndex++;
  gameData.currentRoundCatch.length = 0;

  if (gameData.roundIndex >= MAX_ROUNDS) {
    enterEndcard();
  } else {
    enterNextRoundHub();
  }
}
```

---

### 8. Hub Between Rounds & Upgrades

`enterNextRoundHub()`:

```js
function enterNextRoundHub() {
  gameplaySubState = GameplaySubState.HUB;
  gaugeState.active = false;
  ui.showGauge();
  ui.updateUpgradeButtons(gameData);
  ui.showCoinCounter();
  ui.hideFishCounter();
}
```

Upgrade logic:

```js
function onUpgradeClick(type) {
  if (gameplaySubState !== GameplaySubState.HUB) return;

  if (type === UpgradeType.MAX_FISH) {
    const idx = gameData.maxFishIndex;
    if (idx >= maxFishUpgradeSteps.length - 1) return;
    const next = maxFishUpgradeSteps[idx + 1];
    if (gameData.coins >= next.cost) {
      gameData.coins -= next.cost;
      gameData.maxFishIndex++;
      ui.updateCoinDisplay(gameData.coins);
      ui.updateUpgradeButtons(gameData);
    }
  } else if (type === UpgradeType.MAX_DEPTH) {
    const idx = gameData.maxDepthIndex;
    if (idx >= maxDepthUpgradeSteps.length - 1) return;
    const next = maxDepthUpgradeSteps[idx + 1];
    if (gameData.coins >= next.cost) {
      gameData.coins -= next.cost;
      gameData.maxDepthIndex++;
      ui.updateCoinDisplay(gameData.coins);
      ui.updateUpgradeButtons(gameData);
    }
  }
}
```

Starting a round from hub:

```js
function onPlayButtonPressed() {
  if (gameplaySubState !== GameplaySubState.HUB) return;
  gameplaySubState = GameplaySubState.GAUGE_ACTIVE;
  gaugeState.active = true;
}
```

---

### 9. End Card State

After 3rd round summary:

```js
function enterEndcard() {
  currentState = GameState.ENDCARD;
  ui.hideHUD();
  ui.showEndCard(gameData.coins);
}

function updateEndcard(dt) {
  // Maybe small idle animations; no core logic needed.
}
```

Endcard will contain CTA button (e.g., “Install now”), whose click may be wired to external handler by the ad framework.

---

## Animation Details for Each Entity

1. **Fisherman**
   - Idle sway:
     ```js
     fishermanMesh.rotation.z = Math.sin(time * 0.5) * 0.03;
     ```
2. **Fish (uncaught)**
   - Gentle bobbing & tail wag:
     ```js
     fishMesh.position.x += Math.sin(time * 1 + phase) * 0.01;
     fishMesh.position.y += Math.cos(time * 0.5 + phase) * 0.005;
     fishTail.rotation.y = Math.sin(time * 10 + phase) * 0.3;
     ```
3. **Fish (caught on hook)**
   - Slight bouncing relative to hook:
     ```js
     fishMesh.position.y = hookPos.y + attachOffsetY + Math.sin(time * 10) * 0.05;
     ```
4. **Hook & Line**
   - Hook vertical movement as defined by `hookState.depthCurrent`.
   - Optionally small sway in X (`Math.sin(time * 1.5)*0.1`) when not being dragged.

5. **Gauge Pointer**
   - Updated each frame via CSS transform:
     ```js
     function updateGaugePointer(phase) {
       const percent = phase * 100;
       pointerElem.style.transform = `translateX(${percent}%)`;
     }
     ```

6. **Catch Popup**
   - For each caught fish: small DOM element with `+value` that scales from 0.5 to 1.2 and fades out.
   - Implemented by:
     - Creating element with CSS animation class.
     - Or manual `opacity` + `transform` updates in `update()` for a small list of active popups.

7. **Coin Bursts**
   - For summary: N small coin DOM elements near each fish:
     - Random radial offset, animate outwards and fade.
   - Keep count low (3–5 coins per fish) to avoid perf issues.

8. **Coin Counter Increment**
   - Once total coins gained computed, animate from old amount to new in ~0.5–1s:
     ```js
     const start = oldCoins;
     const end = newCoins;
     const t = clamp((time - startTime) / duration, 0, 1);
     const eased = t*t*(3 - 2*t); // smoothstep
     const current = Math.round(start + (end - start) * eased);
     ui.updateCoinDisplay(current);
     ```

---

## Mobile-First / Responsiveness & Performance

1. **Layout**
   - Use a single full-screen container (`#gameRoot`) with:
     - 3D canvas as background.
     - Absolute-positioned UI overlay.
   - Use viewport-based units (vw, vh) to scale UI elements.
   - For portrait vs landscape:
     - If `innerWidth < innerHeight`: treat as portrait; place gauge at bottom, counters at top.
     - If landscape: place gauge on right or bottom narrower bar.

2. **Touch Input**
   - Use `pointer-events` API; set `touch-action: none` on the canvas and main container to prevent browser scrolling while dragging.

3. **Performance**
   - Limit fish count per round (e.g., ~20–30 fish) to keep collision and rendering cheap.
   - Reuse fish meshes rather than recreating every round.
   - Avoid allocating new objects in `update()` loops (pre-allocate vectors or re-use).
   - Clamp frame time delta (`dt`) to avoid big jumps after tab switching.

---

## Step-by-Step Implementation Blueprint

1. **HTML Skeleton**
   - Single `<html>` file:
     - `<canvas id="gameCanvas"></canvas>` for Three.js renderer.
     - `<div id="uiRoot">` containing all HUD elements (counters, buttons, overlays).
     - `<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>`
     - `<script>` main game JS.

2. **CSS**
   - Full-screen responsive layout.
   - Position UI overlay with flexboxes.
   - Basic transitions for fades and transforms.

3. **JS Modules (within single script)**
   - Encapsulate with IIFE or just namespaces via objects:
     - `SceneManager`
     - `UIManager`
     - `GameStateManager` (main app)
     - `InputManager`
     - `AnimationManager` (simple; might be integrated into others).

4. **Initialization Order**
   - `initRendererAndScene()` → set up Three.js.
   - `initUI()` → create DOM elements, style, hide/show as needed.
   - `bindEvents()` → attach pointer & click handlers.
   - `setupGameData()` → initial coins, upgrades, round index.
   - Enter `TUTORIAL` or direct `GAMEPLAY/HUB` depending on design (PRD implies first fishing explains controls; we treat that as part of first round’s at-depth pause).

5. **Loop Implementation**
   - Single `gameLoop` with timestamps and `dt`.
   - Delegates to `update()` and `render()`.

6. **QA Hooks / Debug**
   - Optionally enable limited logging in console for state transitions.
   - Provide functions like `debugSkipToEndcard()` (not necessary for final PA but useful during dev).

---

If you’d like, the next step can be: translate this blueprint into a concrete, minimal implementation scaffold (the single HTML with boilerplate code structure, enums, and stubbed methods wired to the state machine).