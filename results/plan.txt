```markdown
# Technical Implementation Plan ‚Äì ‚ÄúFishing In The Deep‚Äù (Single HTML)

This document describes how to implement the playable ad ‚ÄúFishing In The Deep‚Äù as a single self-contained HTML file (HTML + inline CSS + inline JS; optional inline SVG/Canvas/WebGL). Focus is on simple 3D‚Äëlooking visuals (basic shapes / pseudo‚Äë3D) and minimal dependencies.

---

## 1. Core Systems & Architecture

### 1.1 Overall Structure

Single `index.html` file containing:

- `<style>` block for all CSS.
- `<canvas id="gameCanvas">` for rendering.
- `<div>` overlays for UI (coins, fish counter, upgrade buttons, play button, text labels).
- `<script>` block with:
  - Game state management.
  - Simple ‚Äú3D‚Äëlooking‚Äù rendering using either:
    - Option A (recommended): 2D canvas with faux‚Äë3D shapes (rectangles, gradients, perspective scaling).
    - Option B: Minimal three.js from CDN (if allowed) with primitive 3D objects and orthographic camera.
  - Input handling (mouse/touch).
  - Animation loop (requestAnimationFrame).

The entire game is run via a single `Game` object that manages subsystems:

- `Renderer` (canvas, 2D pseudo‚Äë3D).
- `UIManager` (HTML UI elements, buttons, labels).
- `RoundManager` (3 rounds, score/coins).
- `HookSystem` (pointer gauge ‚Üí hook movement ‚Üí collision).
- `FishSystem` (spawning, movement, catch logic).
- `UpgradeSystem` (max fish, max depth).

### 1.2 Main Game Loop

Use `requestAnimationFrame`:

```js
function gameLoop(timestamp) {
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;

  game.update(dt);
  game.render();

  requestAnimationFrame(gameLoop);
}
```

`game.update(dt)` handles:

- State machine transitions.
- Pointer gauge animation.
- Hook vertical movement.
- Hook horizontal drag.
- Fish movement and timers.
- Animation timers (effects, popups).
- UI text updates (coins, fish counter bar).

`game.render()` handles:

- Clear canvas.
- Draw background (sea layers).
- Draw static fisherman/boat at top.
- Draw hook and line.
- Draw fish still in water.
- Draw any caught fish following the hook.
- Layer any visual effects (text pops, coin bursts).

### 1.3 Game States

Use a simple finite state machine:

```js
const GameState = {
  UPGRADE: 'UPGRADE',            // Between rounds
  GAUGE_AIM: 'GAUGE_AIM',        // Pointer moving, waiting for click
  HOOK_DESCEND: 'HOOK_DESCEND',  // Hook going down
  HOOK_WAIT_AT_DEPTH: 'HOOK_WAIT_AT_DEPTH', // Pause (with tutorial on round 1)
  HOOK_ASCEND: 'HOOK_ASCEND',    // Hook rising, player can drag
  HOOK_ASCEND_FAST: 'HOOK_ASCEND_FAST', // Max fish reached, fast to surface
  SURFACE_SUMMARY: 'SURFACE_SUMMARY',   // Per-fish animation
  ROUND_SUMMARY: 'ROUND_SUMMARY',       // Total coins, fly to counter
  END_SCREEN: 'END_SCREEN'             // After 3 rounds
};
```

State transitions drive when UI elements show/hide and what input is active.

### 1.4 Coordinate System & Camera

To simulate depth scrolling:

- World Y coordinate increases downwards:
  - `y=0` surface (boat).
  - Depth in meters corresponds to `y = depth * depthScale` (e.g., `depthScale = 30 px/m`).
- Camera is a vertical offset:
  - `cameraY` is interpolated to follow hook‚Äôs `y`.
  - Render objects at `screenY = worldY - cameraY`.

Hook depth selection from gauge:

- Gauge result ‚Üí `targetDepthMeters` between `[maxDepth - 2, maxDepth]`.
- Hook‚Äôs `targetY = targetDepthMeters * depthScale`.

---

## 2. Gameplay Flow

### 2.1 Initial Setup

- Start with:
  - `coins = 100`.
  - `round = 1`.
  - `maxFish = 6`.
  - `maxDepth = 5` (meters).
- Visible UI:
  - Coin counter: `100`.
  - Upgrades UI: ‚ÄúMax Fish‚Äù, ‚ÄúMax Depth‚Äù with current level and next cost.
  - Play button with gauge (pointer idle/disabled until upgrades resolved).
- Fish counter hidden.

### 2.2 Upgrade Phase (Between Rounds)

State: `UPGRADE`

- Player may tap upgrade buttons:
  - **Max Fish levels**:
    - Start: 6.
    - Upgrades: 7 (50ü™ô), 8 (100ü™ô), 9 (200ü™ô), 10 (400ü™ô).
  - **Max Depth levels**:
    - Start: 5m.
    - Upgrades: 10m (50ü™ô), 15m (75ü™ô), 20m (150ü™ô), 30m (300ü™ô).
- Deduct coins immediately on purchase.
- Disable upgrade button if:
  - Player can't afford.
  - Already at max tier.
- ‚ÄúPlay‚Äù button enabled at all times.
- When player presses ‚ÄúPlay‚Äù:
  - Switch to `GAUGE_AIM`.

### 2.3 Gauge & Depth Selection

State: `GAUGE_AIM`

- Pointer moves in pendulum motion across bar:
  - Normalized `t` moves in `[0,1]` then reverses, easing at ends.
  - Map `t` to actual depth:
    - `depthRange = 2` meters (maxDepth - 2).
    - `targetDepthMeters = maxDepth - 2 + 2 * t` (clamped to [maxDepth-2, maxDepth]).
- UI:
  - Coin counter visible.
  - Fish counter hidden.
- Once player taps the Play button:
  - Lock in `targetDepth`.
  - Initialize hook at surface (`hookY = 0`).
  - Spawn fish field (if not already persistent).
  - Switch to `HOOK_DESCEND`.
  - Swap UI:
    - Hide coin counter.
    - Show fish counter: 0 / maxFish, with empty progress bar.

### 2.4 Hook Descent

State: `HOOK_DESCEND`

- Hook moves from `y=0` to `targetY`.
  - Constant or eased velocity.
- Camera:
  - `cameraY` follows hook with smoothing.
- Input:
  - No horizontal drag yet (hook falls straight).
- When hook reaches `targetY`:
  - Move to `HOOK_WAIT_AT_DEPTH`.
  - Start pause timer (1st round longer).

### 2.5 Pause at Depth

State: `HOOK_WAIT_AT_DEPTH`

- Timer:
  - `pauseDuration`:
    - Round 1: ~2.0s.
    - Rounds 2‚Äì3: 0.5‚Äì1.0s.
- Round 1 only:
  - Overlay text near hook: ‚ÄúMove the hook to catch fish‚Äù.
  - It fades/disappears when pause completes.
- At end of pause:
  - Switch to `HOOK_ASCEND`.

### 2.6 Hook Ascent & Catching Fish

State: `HOOK_ASCEND`

- Hook moves up from `targetY` toward surface (`y=0`).
- Player input:
  - Drag left/right to move hook horizontally (within limits).
  - Implementation:
    - On pointer down (mousedown/touchstart) over canvas ‚Üí capture pointer.
    - Track delta `dx` and apply to `hookX`.
    - Clamp hook‚Äôs X within world bounds.
- Collision detection:
  - For each fish not yet caught:
    - If distance between fish position and hook < catch radius, then:
      - Mark fish as caught.
      - Attach fish to hook (store offset).
      - Add to `caughtFish` list.
      - Increase fish counter:
        - `caughtCount += 1`.
        - Progress bar fill = `caughtCount / maxFish`.
      - Play catch effect:
        - Bouncy popup of fish value at fish position.
        - Optional tag text like ‚ÄúRare!‚Äù based on fish rarity.
- When fish is caught:
  - Show a quick number popup: `+<value>` above hook or fish.
- When `caughtCount >= maxFish`:
  - Switch to `HOOK_ASCEND_FAST`.

### 2.7 Fast Ascent to Surface

State: `HOOK_ASCEND_FAST`

- Hook quickly moves to surface:
  - Increased vertical speed.
  - Disable further collision checks.
- Just before reaching surface:
  - Swap UI:
    - Hide fish counter.
    - Show coin counter (still showing pre-round coin total; final addition comes in summary).
- When hook reaches surface:
  - Move to `SURFACE_SUMMARY`.

### 2.8 Per-Fish Surface Summary

State: `SURFACE_SUMMARY`

- Camera returns to surface (`cameraY ‚Üí 0`).
- The hooked fish appear near fisherman / on deck.
- Animations:
  - For each fish (sequence or slight stagger):
    - Jump/bounce animation (scale/position).
    - Display its coin value.
    - If fish has rarity/attaboy text (e.g., ‚ÄúRare!‚Äù, ‚ÄúAmazing!‚Äù, ‚ÄúLegendary!‚Äù), show it near the fish.
    - Play coin burst effect:
      - Simple radial burst of small coin sprites around fish.
- Keep running total for this round:
  - `roundCoins = sum(fish.value)`.
- After all fish animations are finished:
  - Switch to `ROUND_SUMMARY`.

### 2.9 Round Summary & Coin Fly Animation

State: `ROUND_SUMMARY`

- Show a summary UI (e.g. centered overlay):
  - ‚ÄúTotal catch: X coins‚Äù.
  - Slight counter animation:
    - Animate number from 0 ‚Üí `roundCoins`.
- Coin fly animation:
  - A few coin icons animate from summary text to the coin counter position.
  - On complete:
    - Add `roundCoins` to `coins`.
    - Update coin counter text.
- Clean up:
  - Clear `caughtFish` list.
  - Optionally respawn fish or reset fish positions for next cast.
- Check round:
  - If `round < 3`:
    - `round++`.
    - Switch to `UPGRADE`.
  - Else:
    - Switch to `END_SCREEN`.

### 2.10 End Screen

State: `END_SCREEN`

- Show final total coins and ‚ÄúPlay Again‚Äù or ‚ÄúInstall Now‚Äù CTA (depending on needs).
- Consider:
  - A summary of upgrades chosen or best catch.
- For ‚ÄúPlay Again‚Äù:
  - Reset game variables to initial state and return to `UPGRADE`.

---

## 3. Entities & Data

### 3.1 Core Data Structures

#### Game State

```js
const gameState = {
  currentState: GameState.UPGRADE,
  round: 1,
  maxRounds: 3,

  coins: 100,
  roundCoins: 0,

  // Upgrades
  maxFish: 6,
  maxDepth: 5,
  maxFishLevel: 0,   // index into tiers
  maxDepthLevel: 0,

  // Gauge
  gaugeProgress: 0,  // 0..1
  gaugeDirection: 1, // 1 or -1
  gaugeSpeed: 0.7,   // normalized per second

  // Hook
  hookX: 0,
  hookY: 0,
  hookTargetY: 0,
  hookSpeedDown: 200,
  hookSpeedUp: 150,
  hookSpeedUpFast: 400,
  caughtFish: [],          // array of Fish
  hookMaxFishThisRound: 0, // copy of maxFish at begin round

  // Camera
  cameraY: 0,

  // Timers
  pauseTimer: 0,
  tutorialShown: false
};
```

#### Upgrades Config

```js
const maxFishTiers = [
  { value: 6, cost: 0 },
  { value: 7, cost: 50 },
  { value: 8, cost: 100 },
  { value: 9, cost: 200 },
  { value: 10, cost: 400 }
];

const maxDepthTiers = [
  { value: 5, cost: 0 },
  { value: 10, cost: 50 },
  { value: 15, cost: 75 },
  { value: 20, cost: 150 },
  { value: 30, cost: 300 }
];
```

#### Fish Entity

```js
class Fish {
  constructor(x, y, depthMeters, rarity) {
    this.x = x;
    this.y = y;
    this.depthMeters = depthMeters;
    this.rarity = rarity;  // 'common', 'rare', 'legendary', etc.
    this.value = this.computeValue();
    this.caught = false;
    this.attachedOffsetX = 0; // relative to hook when caught
    this.attachedOffsetY = 0;

    // For swimming animation
    this.baseX = x;
    this.swimPhase = Math.random() * Math.PI * 2;
  }

  computeValue() {
    // Example: value increases with depth & rarity
    let base = 5 + Math.floor(this.depthMeters * 0.8);
    if (this.rarity === 'rare') base *= 2;
    if (this.rarity === 'legendary') base *= 4;
    return base;
  }
}
```

#### Rarity & Attaboys

Define depth-dependent rarity probabilities and labels:

```js
const rarityConfig = [
  // [minDepth, maxDepth, {common, rare, legendary}]
  { min: 0, max: 10, probs: { common: 0.85, rare: 0.15, legendary: 0.0 } },
  { min: 10, max: 20, probs: { common: 0.70, rare: 0.25, legendary: 0.05 } },
  { min: 20, max: 40, probs: { common: 0.50, rare: 0.35, legendary: 0.15 } }
];

const rarityLabels = {
  rare: 'Rare!',
  legendary: 'Legendary!',
  amazing: 'Amazing!' // could be used for high-value threshold
};
```

Attaboy determination example:

```js
function getAttaboyForFish(fish) {
  if (fish.rarity === 'legendary') return 'Legendary!';
  if (fish.rarity === 'rare') return 'Rare!';
  if (fish.value > 50) return 'Amazing!';
  return null;
}
```

### 3.2 UI Elements

All defined in HTML, referenced in JS by ID:

- `#coinCounter`: Shows current coins (text).
- `#fishCounterContainer`:
  - `#fishCountText`: `caught / maxFish`.
  - `#fishProgressFill`: inner div with width `%`.
- `#upgradeMaxFishBtn`, `#upgradeMaxDepthBtn`: upgrade buttons.
  - Optional child spans for cost & value.
- `#playButton`: triggers gauge & round start.
- `#gaugeBar`, `#gaugePointer`: visual gauge elements.
- `#tutorialText`: hidden label for tutorial.
- `#summaryOverlay`, `#summaryText`: round summary UI.
- `#endScreen`, `#finalCoinsText`, `#playAgainBtn`: final screen.

Visibility toggled via a helper:

```js
function showElement(id, show) {
  document.getElementById(id).style.display = show ? 'block' : 'none';
}
```

---

## 4. Step-by-Step Implementation Plan

### Step 1 ‚Äì Basic HTML Skeleton

1. Create `index.html`.
2. Add:
   - `<canvas id="gameCanvas"></canvas>`.
   - Container `<div id="ui">` for HUD and buttons.
3. Within UI:
   - `#coinCounter`
   - `#fishCounterContainer` with count text and progress bar.
   - `#upgradePanel` with two buttons.
   - `#playButton`, `#gaugeBar`, `#gaugePointer`.
   - `#tutorialText`.
   - `#summaryOverlay`.
   - `#endScreen`.
4. Ensure the whole game is responsive, but you can define a fixed game area (e.g., 720x1280) and scale canvas with CSS.

### Step 2 ‚Äì CSS Layout & Styling

1. Set body to fill screen, no scroll, center the game container.
2. Set canvas to fixed internal resolution, scale to fit parent.
3. Style:
   - Coin counter at top-left.
   - Fish counter replacing coin counter in same location.
   - Upgrades panel at bottom.
   - Play button & gauge at center bottom.
   - Summary overlay centered, semi-transparent background.
   - End screen overlay full-screen.
4. Basic visuals:
   - Gauge as a horizontal bar with gradient/rounded corners.
   - Pointer a small vertical rectangle or triangle.
   - Progress bar as colored bar inside container.

### Step 3 ‚Äì Canvas & Renderer Setup

1. In JS:
   - Get canvas, set its width/height (e.g., `480x800`).
   - Get `ctx = canvas.getContext('2d');`.
2. Implement `resize()` if you want responsive scaling (optional).
3. Implement `Renderer` class or module:
   - `clear()`: fill background with gradient (light blue ‚Üí dark blue).
   - `drawBoatAndFisherman()`: simple rectangles/circles at surface (y=0).
   - `drawHook(hookX, hookY)`: line from boat down to hook, circle/rectangle as hook.
   - `drawFish(fish)`: simple ellipses/rectangles with small fins; scale slightly based on depth or rarity.
   - `drawEffects()`: temporary for later.

### Step 4 ‚Äì Game State & Loop

1. Initialize `gameState` and config constants.
2. Implement `game.update(dt)`:
   - Switch on `currentState`.
   - For each state, implement behavior (hook movement, timers).
3. Implement `game.render()`:
   - `renderer.clear()`.
   - `renderer.setCamera(game.cameraY)` or pass cameraY into render functions.
   - Draw sea background relative to camera.
   - Draw boat/fisherman at top.
   - Draw fish (only those not caught).
   - Draw hook & caught fish attached.
4. Start main loop:

```js
let lastTime = 0;
requestAnimationFrame(function loop(t) {
  const dt = (t - lastTime) / 1000;
  lastTime = t;
  game.update(dt);
  game.render();
  requestAnimationFrame(loop);
});
```

### Step 5 ‚Äì Input Handling

1. Add handlers to canvas:
   - `mousedown` / `touchstart` ‚Üí `onPointerDown`.
   - `mousemove` / `touchmove` ‚Üí `onPointerMove`.
   - `mouseup` / `touchend` ‚Üí `onPointerUp`.
2. In `HOOK_ASCEND` and `HOOK_ASCEND_FAST`:
   - When pointer is down, track lastX; on move, update `hookX` by delta.
   - Clamp `hookX` within range (e.g., `[-width/2 + margin, width/2 - margin]`).
3. Play button & upgrades:
   - Add click listeners to each button DOM element.
   - Buttons call methods on `game` (e.g. `game.startGauge()`).

### Step 6 ‚Äì Gauge System

1. In `GAUGE_AIM` state:
   - Update pointer position:
     - `gaugeProgress += gaugeSpeed * gaugeDirection * dt`.
     - If `gaugeProgress > 1` or `< 0`, clamp and reverse `gaugeDirection`.
     - Apply easing at ends by reducing speed near 0 and 1 or by using a sinusoidal function.
2. Position pointer DOM element:
   - `pointer.style.left = (gaugeProgress * 100) + '%';`.
3. On Play button click (while in `UPGRADE` ‚Üí `GAUGE_AIM` cycle):
   - First click from upgrade enters `GAUGE_AIM`.
   - Second click (or same button behavior) while in `GAUGE_AIM`:
     - Lock gauge.
     - Compute `targetDepthMeters` from `gaugeProgress`.
     - Set `hookTargetY = targetDepthMeters * depthScale`.
     - Initialize hook at surface (`hookX=0`, `hookY=0`).
     - Prepare `hookMaxFishThisRound = maxFish`.
     - Switch to `HOOK_DESCEND`.
     - Toggle UI: hide gauge or disable, show fish counter.

### Step 7 ‚Äì Fish Field & Spawning

1. On game initialization (or each round), create a list of fish:

   - Define sea area:
     - Depth from 0 to maxDepthTier value (e.g., 30m).
     - Horizontal range: `[-worldWidth/2, worldWidth/2]`.
   - Spawn a fixed number per depth band (e.g., 10‚Äì20 fish per 10m band).
   - For each fish:
     - Random `depthMeters` within band.
     - Convert to `y = depthMeters * depthScale`.
     - Random `x` within world width.
     - Determine rarity via depth-based probabilities.
   - Store in `game.fishList`.

2. In `update(dt)` for states that show water (descend/ascend):
   - Animate fish swimming:
     - `fish.x = fish.baseX + Math.sin(time * swimSpeed + fish.swimPhase) * swimAmplitude;`.

3. You can keep fish persistent across rounds or respawn between rounds (simpler: persistent).

### Step 8 ‚Äì Hook Motion & Camera

1. In `HOOK_DESCEND`:
   - `hookY += hookSpeedDown * dt;`.
   - If `hookY >= hookTargetY`, clamp and switch to `HOOK_WAIT_AT_DEPTH`, set `pauseTimer`.
2. Camera follow:
   - Desired `cameraY = hookY - cameraOffset` (keep hook near center of screen).
   - Smooth:
     - `cameraY += (targetCameraY - cameraY) * cameraLerpFactor * dt`.
3. In `HOOK_WAIT_AT_DEPTH`:
   - `pauseTimer -= dt`.
   - When `pauseTimer <= 0` ‚Üí switch to `HOOK_ASCEND`.
4. In `HOOK_ASCEND`:
   - `hookY -= hookSpeedUp * dt;`.
   - If `hookY <= 0`, set `hookY = 0` and go to `SURFACE_SUMMARY` (if not already forced to fast).
5. In `HOOK_ASCEND_FAST`:
   - Same as ascend but with `hookSpeedUpFast`.

### Step 9 ‚Äì Collision & Catching

1. Only active in `HOOK_ASCEND`:
   - For each `fish` where `!fish.caught`:
     - Compute world positions with camera offset for rendering; for collision, just use world positions.
     - If `Math.hypot(fish.x - hookX, fish.y - hookY) < catchRadius`:
       - `fish.caught = true;`
       - `fish.attachedOffsetX = fish.x - hookX;`
       - `fish.attachedOffsetY = fish.y - hookY;`
       - Push into `caughtFish`.
       - Update UI fish counter:
         - `caughtCount = caughtFish.length;`
         - Update text and progress width.
       - Trigger catch popup/effect (store in effects array).
       - If `caughtCount >= hookMaxFishThisRound`:
         - Switch state to `HOOK_ASCEND_FAST`.

2. In render:
   - For `fish.caught === true`: draw them relative to hook:
     - `drawFishAt(hookX + fish.attachedOffsetX, hookY + fish.attachedOffsetY)`.

### Step 10 ‚Äì Effects System (Popups & Coin Bursts)

1. Define effect objects:

```js
class PopupText {
  constructor(text, x, y, duration) {
    this.text = text;
    this.x = x;
    this.y = y;
    this.duration = duration;
    this.time = 0;
  }
}
class CoinBurst {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.particles = [...]; // each with angle, speed, life
  }
}
```

2. Maintain arrays `popupTexts` and `coinBursts` in game.
3. On catching a fish:
   - Create popup `"+<value>"` at hook position.
4. On surface per-fish reveal:
   - Create `CoinBurst` at fish display location.
   - Create attaboy popup if any.
5. In `update(dt)`:
   - Update lifetimes, positions, and remove finished.
6. In `render()`:
   - Draw texts (`ctx.fillText`) with alpha fade.
   - Draw particles as small yellow circles.

### Step 11 ‚Äì Surface Summary & Round Summary

1. When entering `SURFACE_SUMMARY`:
   - Freeze hook at surface.
   - Prepare local list of caught fish for display animations.
   - Option: reposition them neatly around boat (e.g., row on deck), or keep them hanging from hook with bigger bounce.
2. Implement a small state internal to `SURFACE_SUMMARY`:
   - Sequentially:
     - For each fish i:
       - Run 0.3‚Äì0.5s bounce animation.
       - Trigger coin burst and value popup.
   - Simpler: animate all fish at once, with staggered delays.
3. After fixed duration or when all fish animations done:
   - Compute `roundCoins = sum(caughtFish[i].value)`.
   - Switch to `ROUND_SUMMARY`.

4. In `ROUND_SUMMARY`:
   - Fade in `#summaryOverlay`.
   - Animate number:
     - `displayedTotal = lerp(0, roundCoins, t)` over ~0.8s.
   - After counter finishes, start coin fly animation:
     - Predefine a few coin icons in DOM or draw in canvas, animate their positions from summary text to coin counter location.
5. On completion:
   - Update `game.coins += roundCoins;`.
   - Set coin counter text.
   - Clear `caughtFish`.
   - Hide summary overlay.

6. Round progression:
   - `round++`.
   - If `round <= maxRounds`:
     - Go back to `UPGRADE`:
       - Show upgrade buttons & gauge.
       - Reset gauge stats.
   - Else:
     - Go to `END_SCREEN`:
       - Show final coin total and CTA.

### Step 12 ‚Äì End Screen

1. Show overlay:
   - Text: ‚ÄúFishing Complete!‚Äù.
   - `finalCoinsText`: the final coin count.
   - `Play Again` button (if needed).
2. On `Play Again`:
   - Reset:
     - `coins = 100;`
     - `round = 1;`
     - `maxFishLevel = maxDepthLevel = 0;`
     - `maxFish = 6;`
     - `maxDepth = 5;`
     - Rebuild fish list (optional).
   - Hide `endScreen`, switch state to `UPGRADE`.

### Step 13 ‚Äì Tutorial Message (Round 1)

1. On entering `HOOK_WAIT_AT_DEPTH` for round 1:
   - Show `#tutorialText` near center of screen or near hook.
   - Set `tutorialShown = true`.
2. After the pause time ends (round 1 longer):
   - Hide `#tutorialText`.
   - Move to `HOOK_ASCEND`.

### Step 14 ‚Äì Polishing & Adjustments

- Tweak speeds:
  - Hook descent/ascent times should feel snappy but readable.
- Tweak fish population:
  - Ensure there are enough fish within reachable area along the vertical path.
- UI clarity:
  - Ensure fish counter appears exactly when hook starts descending and disappears before surface.
- Visual hierarchy:
  - Keep fisherman and boat always at top of screen.
  - Depth gradient: darker at lower depths.
- Debug tools (optional):
  - Show depth marker text near hook (e.g., ‚Äú12m‚Äù) during debug.
  - Outline hook collision radius.

---

## 5. Summary of Implementation Order

1. Static HTML structure + CSS layout.
2. Canvas setup + basic rendering (background, boat, static hook).
3. Game loop and state machine skeleton.
4. UI controls (coin counter, play button, upgrade buttons) wiring.
5. Upgrades system and coin spending.
6. Gauge animation & depth selection.
7. Hook vertical movement and camera following.
8. Fish spawning and basic drawing.
9. Hook horizontal drag and collision detection.
10. Fish counter UI & progress bar updates.
11. Catch effects and ‚Äúrare!/legendary!‚Äù labels.
12. Surface summary animations & per-fish values.
13. Round summary (total coins, coin fly animation).
14. Round progression and end screen.
15. Balancing, polishing visuals, and performance checks.

This plan yields a complete single-file playable that follows all major requirements: 3 rounds, upgrades, depth gauge, descending/ascending hook, catching fish with rarity feedback, coin economy, and a final summary.
```