## Critical Analysis of the PRD

**Clarity & completeness**

- Core loop is clear:  
  1) Pre‑cast upgrade/coin management  
  2) Aim cast depth with gauge  
  3) Auto‑descent, then manual horizontal drag to catch fish while ascending  
  4) Payout, coin summary, repeat for 3 rounds → End Card.
- Economy: Well‑defined coin starting point (100) and upgrade prices. Fish → coins mapping is not defined; we’ll need to define:
  - Fish types, depths, and values.
  - Probability distribution for “rare / amazing / legendary” etc.
- Depth: Units (5m, 10m, etc.) are conceptual; need a mapping to world Y coordinates (pixels).
- Fish capacity: “max fish” is starting at 6, upgradable to 10. Clear.
- Gauge: Min–max–min pendulum is specified (ease in/out). Good, just need exact timing.
- Tutorial: Only one tutorial label on first cast while hook is at bottom. Straightforward.
- 3D requirement: “3D but no real assets… can be basic 3D shape.”
  - In a single-file JS+Canvas context, “3D look” will be achieved via faux‑3D (simple shading + perspective scaling) rather than a true 3D engine.
- Rounds: Exactly 3 casts, then End Screen. We must lock out further input and show install CTA.

**Missing / to be assumed**

- Fish spawn logic: spawn pattern, movement, density over depth → we’ll define a simple lane‑based spawn system.
- Fish values and labels:
  - e.g. “Common/Uncommon/Rare/Epic/Legendary” tiers with increasing coin values and depth weighting.
- Monetization/CTA specifics:
  - Only says “end screen” and implicitly “Install button”. We’ll:
    - Add CTA at end screen.
    - Optionally use small inline “Install” button always visible but non‑intrusive (respecting safety zones).
- Failure state: There is no “lose”; even few fish still give coins. We’ll keep it positive and always progress.

**Technical constraints**

- Single HTML file → inline JS, inline CSS; all art via:
  - Canvas drawing primitives, or
  - Small inline SVGs/base64 for simple icons (coin, fish silhouette).
- Performance: Must run on low‑end mobile browsers, so:
  - No heavy frameworks; use Vanilla JS + Canvas.
  - Single `requestAnimationFrame` loop, object pooling where possible.
- Orientation: Must support portrait/landscape → design ratio‑independent scaling and safe zones.

---

## High-Level Architecture

### Tech Stack

- **HTML5 Canvas** (single `<canvas>` full‑screen).
- **Vanilla JS**, no bundler.
- Optional tiny helper: a very small math/easing utility (implemented inline).
- Single HTML file structure:
  ```html
  <html>
    <head>… minimal styles, viewport meta …</head>
    <body>
      <canvas id="game"></canvas>
      <script>/* all JS here */</script>
    </body>
  </html>
  ```

---

## Core Game Loop Analysis

### Hook (Motivator)

- **Fantasy**: Go deeper, catch more valuable fish, and earn more coins with clever aiming and upgrades.
- **Immediate hook**:
  - Starting coins visible.
  - Big, central play/gauge UI, with satisfying, visible hook/fish and coin explosions.
  - First cast tutorial text highlights drag mechanic.

### Interaction

1. **Between rounds**:
   - Tap on upgrade buttons (max fish / max depth) when affordable.
   - Tap play button → start gauge.
   - Tap again to stop gauge and define depth.
2. **During fishing**:
   - Drag side‑to‑side on screen (touch / mouse) to move hook horizontally during ascent.
   - Watch fish get collected, see visual feedback (numbers, labels).
3. **After 3rd round**:
   - Tap “Install” / “Play Now” CTA.

### CTA

- **Primary CTA**: Big “Install” button on end screen.
- **Optional secondary**: Small persistent Install button at top/right or bottom/right, but not overlapping core interaction area and respecting mobile safe zones.

---

## State Management (State Machine)

We’ll use a simple enum + state object with `enter/exit/update/render` per state.

### States

1. **LOADING**
   - Preload any fonts or decode inline assets (if any).
   - Setup canvas, event listeners.
   - Transition → `TUTORIAL` or `GAMEPLAY` Intro depending on design; for this PRD:
     - We enter a generic “pre‑round idle” which is still part of `GAMEPLAY` but with substage “roundIdle”.

2. **GAMEPLAY**  
   Internally, we manage **sub‑stages** for clarity:
   - `roundIdle` (pre‑cast: upgrades & play)
   - `gauge` (casting gauge moving)
   - `hookDescent`
   - `hookPause` (brief pause at bottom; on first round shows tutorial overlay)
   - `hookAscent` (player drag phase)
   - `surfaceSummary` (fish jump and coin tally)
   - `roundTransition` (prep for next round or end)

3. **TUTORIAL** (implemented as flags within `GAMEPLAY`)
   - Not a separate top‑level state to avoid complexity; we use:
     - `isTutorialShown` flag
     - When `roundIndex === 0`, show overlay label “Move the hook to catch fish” during `hookPause`.

4. **ENDCARD**
   - Final summary of collected coins.
   - Big Install CTA.
   - Possibly visual recap of last catch.

### State Transitions

Top-level:

- `LOADING` → `GAMEPLAY` (substage: `roundIdle`).
- `GAMEPLAY`:
  - After `roundIndex === 2` and end of `surfaceSummary` → `ENDCARD`.
- `ENDCARD` → (no further game transitions; only external click handler to store CTA click).

Substages in `GAMEPLAY`:

1. `roundIdle`:
   - Wait for user input.
   - Upgrades enabled.
   - When Play button tapped → goto `gauge`.

2. `gauge`:
   - Pointer oscillates (min–max–min).
   - Next:
     - On user tap → record normalized gauge value, compute `targetDepth`, goto `hookDescent`.

3. `hookDescent`:
   - Camera scrolls down with hook.
   - When hook reaches `targetDepth` → goto `hookPause`.

4. `hookPause`:
   - Wait for 0.5–1s (first round: 2s; show tutorial text).
   - Then goto `hookAscent`.

5. `hookAscent`:
   - Hook moves upward; player can drag horizontally.
   - Fish collisions accumulate in `caughtFish` list and update fish counter.
   - When:
     - `caughtFish.length >= maxFish` → start fast ascent to surface.
   - When hook reaches surface (y>=surfaceY) → goto `surfaceSummary`.

6. `surfaceSummary`:
   - Show fish near surface, one-by-one “jump” animations and coin bursts.
   - Transition sequence:
     - Animate each fish → show coin value and labels (rare/legendary, etc.).
     - Animate coins flying to coin counter.
     - Increment `coins`.
   - At end:
     - Increment `roundIndex`.
     - If `roundIndex < 3` → goto `roundTransition`.
     - Else → `ENDCARD`.

7. `roundTransition`:
   - Quick reset (clear fish, reset hook to top).
   - Fade-in UI for next cast.
   - Then goto `roundIdle`.

---

## Entities and Data Structures

We’ll define simple JS objects / classes. Example type summaries:

### Global Game State

```js
const GameState = {
  currentState: 'LOADING', // 'GAMEPLAY', 'ENDCARD'
  gameplayStage: null,     // 'roundIdle', 'gauge', ...
  roundIndex: 0,           // 0, 1, 2
  coins: 100,
  maxFishCapacity: 6,
  maxDepth: 5,             // in meters
  purchasedMaxFishLevel: 0,
  purchasedMaxDepthLevel: 0,
  // Derived:
  world: {
    width: 0,
    height: 0,
    scale: 1,
    surfaceY: 0,
    bottomY: 0
  },
  input: {
    isDown: false,
    startX: 0,
    x: 0
  },
  hook: { /* see below */ },
  fish: [],         // all fish in world for current round
  caughtFish: [],   // fish caught this cast
  ui: { /* UI layout info */ },
  tutorialShown: false
};
```

### Hook Entity

```js
const Hook = {
  x: 0,
  y: 0,
  radius: 12,         // not real pixels; scaled by world.scale
  vx: 0,
  vy: 0,
  targetDepth: 10,    // meters
  worldDepthToY: 0,   // depth → y conversion
  caught: [],         // references to caught fish
  state: 'idle',      // 'descent', 'pause', 'ascent'
};
```

### Fish Entity

```js
const Fish = {
  x: 0,
  y: 0,
  radius: 10,
  type: 'common', // 'rare', 'legendary'
  value: 10,
  depth: 0,       // in meters
  caught: false,
  highlightLabel: null, // e.g. 'Rare', 'Amazing!', 'Legendary!'
};
```

### Upgrade Data

```js
const MaxFishUpgradeSteps = [
  { cap: 6,  cost: 0 },   // base
  { cap: 7,  cost: 50 },
  { cap: 8,  cost: 100 },
  { cap: 9,  cost: 200 },
  { cap: 10, cost: 400 },
];

const MaxDepthUpgradeSteps = [
  { depth: 5,  cost: 0 },  // base
  { depth: 10, cost: 50 },
  { depth: 15, cost: 75 },
  { depth: 20, cost: 150 },
  { depth: 30, cost: 300 },
];
```

### Gauge Data

```js
const Gauge = {
  t: 0,                // time accumulator
  period: 2000,        // ms for min→max→min cycle
  value: 0,            // [0..1] normalized depth position
  isRunning: false,
};
```

### UI Layout & Counters

```js
const UI = {
  coinCounter: {
    x: 0, y: 0, width: 0, height: 0,
    visible: true,
    value: 100
  },
  fishCounter: {
    x: 0, y: 0, width: 0, height: 0,
    visible: false,
    value: 0,
    maxValue: 6,
    fillRatio: 0
  },
  playButton: {
    x: 0, y: 0, width: 0, height: 0,
    visible: true
  },
  gaugeBar: {
    x: 0, y: 0, width: 0, height: 0,
    visible: false
  },
  upgradeButtons: {
    maxFish: { x:0,y:0,w:0,h:0, enabled: true },
    maxDepth: { x:0,y:0,w:0,h:0, enabled: true },
  },
  ctaButton: {
    x:0,y:0,w:0,h:0, visible:false
  },
  tutorialLabel: {
    visible: false,
    text: "Move the hook to catch fish"
  }
};
```

---

## Responsive Grid & Scaling

### Core Principles

1. **Logical coordinate system**:
   - Define a reference design resolution (e.g. 720×1280 for portrait).
   - Compute a scale factor from actual device size to our reference.
   - All game logic uses reference units; we render multiplied by `scale`.

2. **Aspect Ratio Handling**:
   - For tall screens (>= 16:9 portrait):
     - Keep vertical content; more depth can be visible; adjust world bottomY to maintain approximate “feel”.
   - For wide screens or landscape:
     - Keep the fishing “column” central with side margins; UI reposition to avoid overlaps.

### Layout Zones

- **Safe content zone** (center ~80% of screen):
  - Hook + fish area.
  - Gauge and play button.
- **Safe UI zones for fingers**:
  - Coin/fish counters at top center.
  - Upgrades at bottom left/right.
  - CTA at bottom center or bottom right, with ~48dp padding from screen edges.

### Example Layout Calculations

On `resize`:

```js
function layoutUI() {
  const w = canvas.width;
  const h = canvas.height;
  const isPortrait = h >= w;

  const refW = 720;
  const refH = 1280;
  const scale = Math.min(w / refW, h / refH);
  GameState.world.scale = scale;

  // World vertical extents (surface near top quarter)
  GameState.world.surfaceY = h * 0.25;
  GameState.world.bottomY = h * 0.9; // deepest visible limit

  // Coin / Fish counter
  UI.coinCounter.x = w * 0.5;
  UI.coinCounter.y = h * 0.08;

  UI.fishCounter.x = UI.coinCounter.x;
  UI.fishCounter.y = UI.coinCounter.y;

  // Play button
  UI.playButton.width = 220 * scale;
  UI.playButton.height = 80 * scale;
  UI.playButton.x = (w - UI.playButton.width)/2;
  UI.playButton.y = h * 0.75;

  // Gauge
  UI.gaugeBar.width = w * 0.6;
  UI.gaugeBar.height = 20 * scale;
  UI.gaugeBar.x = (w - UI.gaugeBar.width)/2;
  UI.gaugeBar.y = UI.playButton.y - 60 * scale;

  // Upgrades at bottom left/right
  const btnW = 180 * scale;
  const btnH = 60 * scale;
  UI.upgradeButtons.maxFish.x = w * 0.1;
  UI.upgradeButtons.maxFish.y = h * 0.85;
  UI.upgradeButtons.maxFish.width = btnW;
  UI.upgradeButtons.maxFish.height = btnH;

  UI.upgradeButtons.maxDepth.x = w - w * 0.1 - btnW;
  UI.upgradeButtons.maxDepth.y = h * 0.85;
  UI.upgradeButtons.maxDepth.width = btnW;
  UI.upgradeButtons.maxDepth.height = btnH;

  // CTA button (endcard)
  UI.ctaButton.width = 260 * scale;
  UI.ctaButton.height = 80 * scale;
  UI.ctaButton.x = (w - UI.ctaButton.width)/2;
  UI.ctaButton.y = h - UI.ctaButton.height - 24 * scale; // safe zone from bottom
}
```

---

## UI/UX & Install Button Placement

### Coin/Fish Counters

- Located near the top‑center; large enough to be clearly readable.
- Transition:
  - In `roundIdle`: coin counter visible, fish counter hidden.
  - When `gauge` start or just on `hookDescent` start:
    - Animate coin counter fade out, fish counter fade in.
  - On approach to surface in `hookAscent`:
    - Reverse: fish counter → coin counter.

### Upgrades

- Always visible during `roundIdle`.
- Grayed out / disabled when:
  - Not enough coins.
  - Already at max upgrade level.
  - Any other substage than `roundIdle` (to avoid confusion).

### Play Button

- Center‑bottom, large tap target.
- Two modes:
  - Idle: “PLAY” (starts gauge).
  - Gauge running: tap anywhere on button area stops gauge.

### Install CTA (End Card)

- On `ENDCARD`:
  - Full-screen overlay with:
    - Title: “Your Deep Sea Fortune” or similar.
    - Big coin total.
    - Hook/fish “trophy” display.
  - **Install Button**:
    - Center‑bottom, wide, high contrast, safe from edges by ~24px.
- During gameplay (optional small CTA):
  - Top‑right or bottom‑right small pill button: “Install”.
  - Not overlapping the hook path or gauge region.
  - Must not intercept core actions (we keep its hitbox mostly in edge margin).

---

## Assets Strategy

Given single file constraint:

- **Canvas API**:
  - All main visuals: fisherman, boat, hook, fish, background.
  - Use simple shapes & gradients:
    - Fisherman as a stylized silhouette (rectangles, circles, minimal shading).
    - Boat as trapezoid + mast.
    - Fish as oval with triangle tail, some stripes, color-coded rarity.
    - 3D illusion by:
      - Slight perspective: fish scale down as they go “deeper” (further from surface).
      - Simple highlights (lighter edge) & shadows (darker underside).
      - Overlapping layers & parallax background shapes.

- **Optional inline SVG / Base64**:
  - Coin icon sprite (simple circle + inner stroke).
  - Used for UI counters and coin bursts.
  - Embedded as base64 `<img>` or Canvas path, but since we’re staying Canvas‑only, we can draw circles with radial gradient instead (no real need for images).

No external image loads → no slow network dependencies.

---

## Gameplay Flow Implementation

### Depth Conversion

- `maxDepth` (m) mapped to world Y positions:
  - Depth 0m (surface) → `world.surfaceY`.
  - Depth `maxDepth` → some Y below the bottom, camera scrolls so hook is centered.
- We’ll maintain both:
  - Depth in meters for logic.
  - Y coordinates for rendering.

```js
function depthToY(depthM) {
  const maxM = GameState.maxDepth;
  const surfaceY = GameState.world.surfaceY;
  const bottomY = GameState.world.bottomY;
  const t = depthM / maxM;
  return surfaceY + t * (bottomY - surfaceY);
}
```

### Gauge to Depth Mapping

- Gauge value `g` in [0..1] defines actual depth:
  - `minDepth = maxDepth - 2`
  - `actualDepth = minDepth + g * (maxDepth - minDepth)`
- So at edges:
  - g=0 → `minDepth` (shallow)
  - g=1 → `maxDepth`
- We clamp `minDepth` ≥ 1 (so we always see some descent).

---

## Step-by-Step Logic & Modular Functions

We’ll structure the code around typical game loop phases: `init`, `preload` (minimal), `create`, `update`, `render`.

### 1. `init()`

- Called on `window.onload`.
- Responsibilities:
  - Get canvas, context.
  - Setup viewport meta (already in HTML).
  - Attach event listeners:
    - `resize` → `onResize`
    - `touchstart`, `touchmove`, `touchend`
    - `mousedown`, `mousemove`, `mouseup`
  - Set `GameState.currentState = 'LOADING'`.
  - Call `preload()`.

```js
function init() {
  canvas = document.getElementById('game');
  ctx = canvas.getContext('2d');

  window.addEventListener('resize', onResize);
  setupInputListeners();

  onResize();
  GameState.currentState = 'LOADING';
  preload();
  requestAnimationFrame(loop);
}
```

### 2. `preload()`

- Inline assets means almost nothing to preload.
- Maybe measure text baseline, warm up fonts by drawing once.
- Then go to `create()`.

```js
function preload() {
  // any async tasks if needed can run here; we assume none
  create();
}
```

### 3. `create()`

- Initialize `GameState` values.
- Call `layoutUI()`.
- Seed fish for first round (or each round later).
- Set `GameState.currentState = 'GAMEPLAY'`, `gameplayStage = 'roundIdle'`.

```js
function create() {
  GameState.coins = 100;
  GameState.roundIndex = 0;
  GameState.maxFishCapacity = MaxFishUpgradeSteps[0].cap;
  GameState.maxDepth = MaxDepthUpgradeSteps[0].depth;
  GameState.purchasedMaxFishLevel = 0;
  GameState.purchasedMaxDepthLevel = 0;

  layoutUI();
  resetHookToSurface();
  spawnFishForRound();
  
  GameState.currentState = 'GAMEPLAY';
  GameState.gameplayStage = 'roundIdle';
}
```

### 4. `update(dt)`

Central loop, frame‑time aware.

```js
function update(dt) {
  switch (GameState.currentState) {
    case 'GAMEPLAY':
      updateGameplay(dt);
      break;
    case 'ENDCARD':
      updateEndcard(dt);
      break;
    // LOADING has no long-lived state
  }
}
```

#### `updateGameplay(dt)`

```js
function updateGameplay(dt) {
  switch (GameState.gameplayStage) {
    case 'roundIdle':
      updateRoundIdle(dt);
      break;
    case 'gauge':
      updateGauge(dt);
      break;
    case 'hookDescent':
      updateHookDescent(dt);
      break;
    case 'hookPause':
      updateHookPause(dt);
      break;
    case 'hookAscent':
      updateHookAscent(dt);
      break;
    case 'surfaceSummary':
      updateSurfaceSummary(dt);
      break;
    case 'roundTransition':
      updateRoundTransition(dt);
      break;
  }
}
```

##### `updateRoundIdle(dt)`

- No world movement.
- Only UI interactions (handled via input).
- Make sure UI states (affordability of upgrades) are updated.

##### `updateGauge(dt)`

- Increase `Gauge.t`.
- Compute oscillating pointer value with ease in/out:
  - We can use a sine function: `value = 0.5 - 0.5 * Math.cos(2π * t / period)`
    - This yields min→max→min with easing at ends.
- On user tap (flag set by input handler), stop:
  - `Gauge.isRunning = false`
  - Compute `targetDepth` and assign to hook.
  - `GameState.gameplayStage = 'hookDescent'`.

```js
function updateGauge(dt) {
  if (!Gauge.isRunning) return;

  Gauge.t += dt;
  const phase = (Gauge.t % Gauge.period) / Gauge.period; // 0..1
  Gauge.value = 0.5 - 0.5 * Math.cos(2 * Math.PI * phase);

  if (GameState.pendingGaugeStop) {
    GameState.pendingGaugeStop = false;
    const minDepth = Math.max(1, GameState.maxDepth - 2);
    const depthRange = GameState.maxDepth - minDepth;
    const targetDepth = minDepth + Gauge.value * depthRange;
    GameState.hook.targetDepth = targetDepth;
    GameState.gameplayStage = 'hookDescent';
    UI.gaugeBar.visible = false;
  }
}
```

##### `updateHookDescent(dt)`

- Move hook down (increase y or depth) at fixed speed until `depth >= targetDepth`.
- Camera offset: compute so hook always near screen center vertically (or a bit above mid).

```js
function updateHookDescent(dt) {
  const speedMperSec = 12; // tune
  const deltaM = speedMperSec * dt / 1000;
  GameState.hookDepthM += deltaM;
  if (GameState.hookDepthM >= GameState.hook.targetDepth) {
    GameState.hookDepthM = GameState.hook.targetDepth;
    GameState.gameplayStage = 'hookPause';
    GameState.hookPauseTimer = (GameState.roundIndex === 0) ? 2000 : 700;
    if (GameState.roundIndex === 0) {
      UI.tutorialLabel.visible = true;
    }
  }
  updateHookWorldY();
  updateCamera();
}
```

##### `updateHookPause(dt)`

- Countdown timer.
- After timer, hide tutorial label (if any) and go to `hookAscent`.

```js
function updateHookPause(dt) {
  GameState.hookPauseTimer -= dt;
  if (GameState.hookPauseTimer <= 0) {
    UI.tutorialLabel.visible = false;
    GameState.gameplayStage = 'hookAscent';
    GameState.hookAscentSpeed = 18; // base speed M/s
    GameState.caughtFish.length = 0;
    UI.fishCounter.visible = true;
    UI.coinCounter.visible = false;
  }
}
```

##### `updateHookAscent(dt)`

- Move hook upward (decrease depth).
- Horizontal movement from touch dragging:
  - Use input.x vs previous x to set `hook.vx`.
  - Clamp `hook.x` inside horizontal bounds.
- Check collision with all fish:
  - Simple circle collision.
  - On collision:
    - Mark fish `caught = true`.
    - Attach fish to hook (store offset).
    - Add to `caughtFish[]`.
    - Increment fish counter; update fill ratio.
    - Show floating text (`+value`, “Rare!”).
- When `caughtFish.length >= maxFishCapacity`, increase ascent speed, and ignore further collisions.
- When depthM <= 0 (or y <= surfaceY), transition:
  - UI switch to coin counter.
  - Stage → `surfaceSummary`.

```js
function updateHookAscent(dt) {
  const maxCap = GameState.maxFishCapacity;
  const atCapacity = GameState.caughtFish.length >= maxCap;

  // Vertical
  const baseSpeed = atCapacity ? 30 : 18;
  GameState.hookDepthM -= baseSpeed * dt / 1000;
  if (GameState.hookDepthM <= 0) {
    GameState.hookDepthM = 0;
    // reached surface
    GameState.gameplayStage = 'surfaceSummary';
    UI.fishCounter.visible = false;
    UI.coinCounter.visible = true;
    prepareSurfaceSummary();
    return;
  }

  updateHookWorldY();

  // Horizontal: based on touch drag
  updateHookHorizontalFromInput(dt);
  clampHookX();

  if (!atCapacity) {
    checkHookFishCollisions();
  }

  updateCamera();
}
```

##### `updateSurfaceSummary(dt)`

- Drive a small state machine for fish animations:
  - For each caught fish, sequentially:
    - Jump up, fall back, show value label and highlight label.
    - Emit some coins that travel towards coin counter.
- Once all fish processed:
  - Count up coins from this round total to actual `GameState.coins` with a numeric tween.
  - After done, `roundIndex++` and either:
    - `gameplayStage = 'roundTransition'` or
    - if `roundIndex >= 3` → `currentState = 'ENDCARD'`.

---

### 5. `render()`

Central render dispatcher.

```js
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  switch (GameState.currentState) {
    case 'GAMEPLAY':
      renderGameplay();
      break;
    case 'ENDCARD':
      renderEndcard();
      break;
  }
}
```

#### `renderGameplay()`

1. Render background:
   - Sky gradient above surface.
   - Sea gradient below surface.
   - Light rays and bubbles for “deepness”.
2. Render fisherman & boat fixed at top (camera anchored to surface).
3. Apply camera offset for underwater elements (hook + fish).
4. Render fish:
   - Only those in current visible Y range.
   - For caught fish: drawn at hook position with offsets.
5. Render hook:
   - Line from boat to hook.
   - Hook as small 3D‑ish shape (e.g., curved hook).
6. Render UI:
   - Coin/fish counters with icons and text.
   - Gauge bar & pointer when visible.
   - Play button if `roundIdle` or `gauge`.
   - Upgrade buttons.
   - Tutorial label if visible.
   - Any floating texts and effects.

#### `renderEndcard()`

- Dim background.
- Center panel:
  - “Total Coins Earned” text.
  - Large coin total.
  - Possibly stylized hook & fish.
- Big Install button (UI.ctaButton).
- Some subtle motion (pulsing button, glint over coins).

---

### 6. `loop(timestamp)`

Main animation loop with delta time.

```js
let lastTime = 0;
function loop(timestamp) {
  const dt = Math.min(50, timestamp - lastTime); // clamp
  lastTime = timestamp;

  update(dt);
  render();

  requestAnimationFrame(loop);
}
```

---

## Input Handling & Touch Lag Prevention

- Use `touchstart` / `touchmove` / `touchend` for mobile; `mouse*` for desktop.
- Prevent default scroll/zoom gestures when interacting inside canvas.

```js
function setupInputListeners() {
  canvas.addEventListener('touchstart', onTouchStart, {passive:false});
  canvas.addEventListener('touchmove', onTouchMove, {passive:false});
  canvas.addEventListener('touchend', onTouchEnd);
  canvas.addEventListener('mousedown', onMouseDown);
  canvas.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('mouseup', onMouseUp);
}
```

### Tap vs Drag

- During `roundIdle` & `gauge`:
  - Taps in:
    - Play button area → start/stop gauge.
    - Upgrade buttons → buy upgrades.
- During `hookAscent`:
  - Drag events adjust hook `x`:
    - Map touch X to world X or use deltaX to move hook smoothly.

### Example: Handling Tap on Gauge

```js
function handleTap(x, y) {
  if (GameState.currentState === 'GAMEPLAY') {
    if (GameState.gameplayStage === 'roundIdle') {
      if (pointInRect(x,y,UI.playButton)) startGauge();
      else handleUpgradeTap(x,y);
    } else if (GameState.gameplayStage === 'gauge') {
      if (pointInRect(x,y,UI.playButton)) GameState.pendingGaugeStop = true;
    }
  } else if (GameState.currentState === 'ENDCARD') {
    if (pointInRect(x,y,UI.ctaButton)) onInstallClick();
  }
}
```

---

## Fish Spawn System

We need simple but effective spawn behavior:

- Define depth bands:
  - Shallow (0–10m): commons, low value.
  - Mid (10–20m): more uncommons/rares.
  - Deep (20–30m): rares and legendaries more frequent.
- For each round:
  - Generate, say, 40–60 fish distributed over all depths up to `maxDepth`.
  - Place fish in horizontal “lanes” (e.g., 5 lanes).
  - Add slight random movement left/right.

```js
function spawnFishForRound() {
  GameState.fish.length = 0;
  const lanes = 5;
  const total = 50;
  for (let i=0;i<total;i++) {
    const depthM = Math.random() * GameState.maxDepth;
    const type = pickFishTypeForDepth(depthM);
    const lane = (i % lanes) + 0.5;
    const x = (lane / lanes) * canvas.width;
    const y = depthToY(depthM);
    GameState.fish.push({
      x, y,
      radius: 14,
      depth: depthM,
      type: type.name,
      value: type.value,
      highlightLabel: type.label,
      caught: false
    });
  }
}
```

`pickFishTypeForDepth()` returns something like:

- Shallow: 80% common, 18% uncommon, 2% rare.
- Mid: 50% common, 30% uncommon, 15% rare, 5% legendary.
- Deep: 30% uncommon, 35% rare, 25% epic, 10% legendary.

---

## Coins and Visual Feedback

- **On catch** (during ascent):
  - Spawn a small text effect: `+10` near hook.
  - If `highlightLabel` exists, spawn text like “Rare!” above fish.
  - Add the fish to `caughtFish` list but **do not** immediately add coins to global counter; we sum them at surface.
- **At surface summary**:
  - For each fish, animate:
    - Fish jumps: `y(t) = baseY - jumpHeight * sin(π * t/T)` over 0.6s.
    - Coin burst: draw multiple small coins moving outward and then curving toward coin counter.
  - Accumulate `roundCoinsTotal`.
  - Then animate coin counter counting up.

---

## Summary of Main Functions

- **Lifecycle**
  - `init()`
  - `preload()`
  - `create()`
  - `loop(timestamp)`
- **Layout & Resize**
  - `onResize()`
  - `layoutUI()`
- **Update**
  - `update(dt)`
  - `updateGameplay(dt)`
    - `updateRoundIdle(dt)`
    - `updateGauge(dt)`
    - `updateHookDescent(dt)`
    - `updateHookPause(dt)`
    - `updateHookAscent(dt)`
    - `updateSurfaceSummary(dt)`
    - `updateRoundTransition(dt)`
  - `updateEndcard(dt)`
- **Render**
  - `render()`
  - `renderGameplay()`
  - `renderEndcard()`
  - `renderBackground()`
  - `renderFish()`
  - `renderHook()`
  - `renderBoatAndFisherman()`
  - `renderUI()`
- **Input**
  - `setupInputListeners()`
  - `onTouchStart/Move/End()`
  - `onMouseDown/Move/Up()`
  - `handleTap(x,y)`
  - `updateHookHorizontalFromInput(dt)`
- **Game Logic Helpers**
  - `resetHookToSurface()`
  - `updateHookWorldY()`
  - `updateCamera()`
  - `checkHookFishCollisions()`
  - `spawnFishForRound()`
  - `pickFishTypeForDepth(depthM)`
  - `prepareSurfaceSummary()`
  - `pointInRect(x,y,rect)`
- **CTA**
  - `onInstallClick()` (calls external `mraid.open()` or tracking stub)

This blueprint keeps everything modular, responsive, and optimized for a single-file playable ad built on Canvas with clear state transitions and minimal asset overhead.