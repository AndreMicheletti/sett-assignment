## Critical Analysis of the PRD

### Scope & Completeness
- Core loop is well defined:  
  1) Upgrade > 2) Choose depth with timing gauge > 3) Catch fish on the way up > 4) Get coins > 5) Repeat for 3 rounds > 6) End screen.  
- Economy is mostly specified (upgrade costs, starting coins), but:
  - Fish values are not defined (how many coins per fish / rarity).
  - Probability/rarity distribution for “rare / amazing / legendary” is not specified, only “higher depth better chance”.
- “3D but basic shapes” requested for fisherman & fish; no further visual style constraints (textures, colors, etc.), so we can use simple 3D primitives.
- Number of fish in the environment, spawn patterns, and depth distribution are not fully specified. We’ll have to define reasonable defaults.
- Tutorial behavior is mostly clear (first round only, when hook pauses at depth).

### Tech/Implementation Considerations
- Single-file HTML5 with 3D elements: best candidate is **three.js via CDN** inside a single HTML file, using:
  - 3D scene for fisherman, hook, fish, water background.
  - 2D HTML/CSS or Canvas overlay for UI (coins, fish counter, upgrades, CTA).
- States are clearly segmentable: Loading → Tutorial → Gameplay (3 rounds) → EndCard.
- Input: need to support tap/drag with low latency; we’ll use `pointerdown/move/up` with passive listeners and requestAnimationFrame-based loop.
- Camera-following hook: will require continuous interpolation and clamping; must not be jarring when transitioning from surface to depth and back.

### Open Design Decisions (we will assume defaults)
1. **Fish economy & rarity (assumed)**
   - Base fish value: e.g., 10–30 coins.
   - Rare types: +x2 / legendary: +x3 value.
2. **Fish distribution by depth (assumed)**
   - Shallow: many common, few rare.
   - Deep: fewer total fish, higher rare+legendary proportion.
3. **Session duration**
   - Each round must be short (approx. 8–15 seconds). We will tune hook speed and depth accordingly.

---

## 1. Core Loop Analysis

### Hook
- Visually satisfying “dive → catch → cash-in” loop in under ~15 seconds.
- Progression: upgrades improve max fish and max depth; deeper = more and/or better fish.

### Interaction
1. **Pre-round**
   - Player taps upgrade buttons (if enough coins).
   - Player taps/holds “Play” button to **stop pointer** on timing gauge (pendulum motion).
2. **Fishing**
   - Hook auto-moves downward to chosen depth, camera follows.
   - Upward phase: player **drags horizontally** to steer hook and collide with fish.
3. **Results**
   - On-surface coin summarization and animated payout.

### CTA
- EndCard with prominent **“Install”** button.
- Soft CTA seeds:
  - “Legendary!” popups.
  - End-of-round summary showcasing big coin gains.
  - End screen summarizing upgrades and “Get more by installing”.

---

## 2. High-Level Architecture

### Tech Stack
- **Engine**: Vanilla JS + **three.js (CDN)** for simple 3D.
- **Rendering**:
  - 3D: three.js Canvas/WebGL context.
  - UI: HTML/CSS positioned on top (for crisp text & flexible layout).
- **Single File**: All JS in `<script>` tag; simple inline CSS; minimal HTML structure.

### Core Systems
1. **State Machine**
   - States:
     - `LOADING`
     - `TUTORIAL`
     - `GAMEPLAY`
     - `ENDCARD`
   - Each state has: `enter(prevState)`, `update(dt)`, `render()`, `exit(nextState)`.

2. **Game Systems**
   - `AssetManager` (even though most is generated, used for timing and texture placeholders).
   - `SceneManager` (3D world setup & management).
   - `InputManager` (pointer handling and mapping to actions).
   - `EconomyManager` (coins, upgrade costs, fish values).
   - `RoundManager` (3 rounds progression logic).
   - `UIManager` (DOM layout, counters, gauges, CTA).
   - `AnimationSystem` (timed tweens for UI & 3D motions).
   - `Physics/Collision` (hook vs fish).

---

## 3. Entities & Data Definitions

### Core Data Structures (JS Objects)

```js
const GameState = {
  LOADING: 'loading',
  TUTORIAL: 'tutorial',
  GAMEPLAY: 'gameplay',
  ENDCARD: 'endcard'
};

const MAX_ROUNDS = 3;

const player = {
  coins: 100,
  round: 1,
  maxFish: 6,
  maxDepth: 5, // in meters
  ownedUpgrades: {
    maxFishLevel: 0,  // index into maxFishUpgradeSteps
    maxDepthLevel: 0  // index into maxDepthUpgradeSteps
  }
};

const maxFishUpgradeSteps = [
  { fishCap: 7, cost: 50 },
  { fishCap: 8, cost: 100 },
  { fishCap: 9, cost: 200 },
  { fishCap: 10, cost: 400 }
];

const maxDepthUpgradeSteps = [
  { depth: 10, cost: 50 },
  { depth: 15, cost: 75 },
  { depth: 20, cost: 150 },
  { depth: 30, cost: 300 }
];

// Fish rarity types
const FishRarity = {
  COMMON: 'common',
  RARE: 'rare',
  AMAZING: 'amazing',
  LEGENDARY: 'legendary'
};

const fishRarityConfig = {
  common:   { label: null,    baseValue: 10, color: 0x77ccff },
  rare:     { label: 'RARE!', baseValue: 20, color: 0x44ff88 },
  amazing:  { label: 'AMAZING!', baseValue: 30, color: 0xffcc00 },
  legendary:{ label: 'LEGENDARY!', baseValue: 50, color: 0xff4444 }
};

// Per-round runtime data
let roundData = {
  currentDepthChoice: 5,
  actualDepthMeters: 5,
  hookPhase: 'idle', // 'descending', 'pause', 'ascending', 'summary'
  fishCaught: [],
  fishCap: player.maxFish,
  coinsGainedThisRound: 0
};
```

### 3D Entities

1. **Fisherman**
   - **3D Required**: yes.
   - Graphics: simple 3D:
     - Body: cylinder.
     - Head: sphere.
     - Boat: box.
   - Behavior: idle bobbing animation at surface.

2. **Hook**
   - **3D Required**: yes.
   - Graphics:
     - Line (rope): thin cylinder.
     - Hook: small inverted “J” shape via bent cylinder or two cylinders.
   - Behavior:
     - Vertical motion: down/up based on depth.
     - Horizontal: user-controlled; limited range.
     - Attachment point for caught fish.

3. **Fish**
   - **3D Required**: yes.
   - Graphics: simple 3D:
     - Body: elongated sphere or capsule.
     - Tail: small triangular prism or flat plane.
     - Color depends on rarity.
   - Behavior:
     - Idle: side-to-side swim in small sine wave; random horizontal direction.
     - On catch: attach to hook with slight offset; bounce animation on surface.

4. **Background / Environment**
   - **3D/2D**:
     - Water: large vertical gradient plane or clear color; can be 3D plane with gradient texture.
     - Depth markers (optional): subtle lines/markers along vertical axis.
   - Camera: perspective camera looking towards side view; camera y-position follows hook.

---

## 4. Asset Strategy (2D vs 3D vs Base64)

Given single-file constraint and 3D requirement:

- **3D (three.js primitives)**:
  - Fisherman & boat.
  - Hook & rope.
  - Fish.
  - Water background plane.

- **Canvas / Code-drawn or HTML/CSS**:
  - Gauge bar and pointer: drawn in Canvas or HTML `<div>` with CSS transforms.
  - Coin counter, fish counter, popup labels: HTML divs with CSS animations.

- **Base64 placeholders**:
  - Not strictly necessary; we can avoid external images.
  - If we want a coin icon or fish icon for counters, we can embed tiny Base64 PNG or draw via Canvas/SVG.

### Summary Per Element
- Fisherman: 3D (three.js primitives).
- Hook: 3D (three.js primitives).
- Fish: 3D (three.js primitives).
- Water: 3D plane + gradient material (generated).
- Gauge: 2D HTML/CSS or Canvas.
- Buttons & Counters: HTML/CSS.
- Coins/fish icons: simple CSS shapes or minimal Base64 images.

---

## 5. State Management and Transitions

### States

1. **LOADING**
   - Initialize three.js scene, camera, lights.
   - Create fisherman, boat, hook, water.
   - Pre-spawn fish pools at different depths.
   - Initialize UI elements (hidden as necessary).
   - Transition:
     - `LOADING → TUTORIAL` once init is done (first round).

2. **TUTORIAL**
   - Essentially the first round with extra messaging.
   - UI: show coins, upgrades, gauge, play button.
   - Tutorial text appears at first hook pause at depth: “move the hook to catch fish”.
   - Transition conditions:
     - When first round fishing finishes and summary shown → `GAMEPLAY` (if more rounds).
     - After third round: `TUTORIAL → ENDCARD` (if we treat TUTORIAL just as first round gameplay).

   Implementation-wise we can treat TUTORIAL as a flag inside the first round of GAMEPLAY state, but PRD wants a Tutorial conceptually; we’ll expose it in the state machine:

   - `LOADING → TUTORIAL (round=1, tutorial=true)`
   - `TUTORIAL → GAMEPLAY (round=2, tutorial=false)` after first round summary.
   - `GAMEPLAY → ENDCARD` after third round.

3. **GAMEPLAY**
   - Same as TUTORIAL but without tutorial overlay.

4. **ENDCARD**
   - Show final coins, highlight potential if installed.
   - Full-screen overlay with big **Install** button.

### Detailed Transitions per Round

1. **Pre-round (within TUTORIAL/GAMEPLAY)**
   - Substate: `ROUND_PREP`
     - Show coins & upgrades.
     - Play button visible.
   - On Play press: go to `GAUGE` substate.

2. **Gauge Phase**
   - Pointer oscillates (pendulum) between min and max.
   - On tap/click:
     - Stop pointer.
     - Convert pointer position [0..1] to depth:
       - `chosenDepth = minDepth + t * (maxDepth - minDepth)`
       - minDepth = `maxDepthChosen - 2m` as per PRD.
     - Transition to `DESCENDING`.

3. **Descending**
   - Replace coin counter with fish counter UI.
   - Hook moves down to `chosenDepth`.
   - Camera follows (smooth).
   - On arrival:
     - Pause phase:
       - First round: 2s + tutorial overlay.
       - Other rounds: ~0.5–1s.
     - Then to `ASCENDING`.

4. **Ascending (Gameplay)**
   - Hook moves upward at constant speed.
   - Player drags horizontally; hook x-position follows with smoothing.
   - Collision detection with fish:
     - On collision, attach fish to hook if not exceeding `fishCap`.
     - Show immediate popup coin value & rarity label (floating upward).
     - Update fish counter bar.
   - Once `fishCaught.length` == `fishCap`:
     - Hook vertical speed increases for the remainder of ascent.
     - Disable further catching (skip collisions).
   - Near surface:
     - Swap fish counter back to coin counter (preparing for summary).

5. **Surface Summary**
   - Hook stops near fisherman.
   - Substate: `SUMMARY`:
     - For each fish caught:
       - Play “jump” animation of fish (bounce).
       - Show “+coins” text and rarity labels.
       - Play coin burst + UI coins flying to counter.
     - Then show total catch counter (slight progressive count up).
     - Update global `player.coins` value.
   - After summary:
     - If `player.round < 3`:
       - `round++` → go back to `ROUND_PREP`.
     - Else:
       - Move to `ENDCARD`.

---

## 6. Responsive Grid & Layout

### Overall Layout Strategy

- **Mobile-first, portrait primary**; handle landscape via scaled layout.
- Use a **relative, anchored design** with percentage-based positions and `vw/vh` for sizes:
  - 3D canvas: full screen (`width: 100vw; height: 100vh`).
  - UI overlay: positioned with CSS using absolute coordinates relative to `body`.

### Portrait Layout (Primary)
- Top safe zone (notch-friendly):
  - Coin counter: top-left (within ~10% margin from left, 5% from top).
- Top-right: optional mute/settings (if needed).
- Middle:
  - Gauge and Play button: bottom-center (~70–90% of screen height).
  - Upgrade buttons: just above gauge or to left/right of gauge.

- Fish counter:
  - Same position as coin counter (top-left); swap visibility.

### Landscape Layout
- Shorter height; we’ll:
  - Place coin/fish counters in top-left within ~5–7% margins.
  - Gauge + Play button at bottom center, slightly smaller.
  - Upgrades either bottom-left/right or along top.

### Safe zone & Scaling
- Use CSS:
  - `max-width: 100vw; max-height: 100vh;` on root container.
  - Font sizes using `clamp(12px, 2.5vw, 22px)` for readability.
- Scale UI relative to min(width, height) to remain legible across aspect ratios.

---

## 7. UI/UX: CTA and Buttons

### CTA / Install Button (EndCard)
- Position:
  - **Centered near bottom** (roughly at 75–85% of height).
  - Width ~60–80% of screen width on mobile.
- Safety:
  - Minimum 16px margin to edges; avoid notch/gesture areas.
  - Large tap area: at least 48x48 CSS pixels.
- Styling:
  - High contrast (e.g., bright green/orange) vs background dim.
  - Clear label: “Install” or “Play Now”.

### In-game Buttons
- **Play Button & Gauge**:
  - Bottom-center; big enough to tap easily.
- **Upgrade Buttons**:
  - Either:
    - Horizontally above gauge (two big rectangular buttons).
    - Or vertically stacked on right side.
  - Each shows:
    - Current level / next value.
    - Cost.
    - Disabled state (gray) if insufficient coins.

---

## 8. Step-by-Step Code Structure

We’ll adopt a simplified Phaser-like lifecycle with our own functions:

1. `init()`
2. `preload()` (conceptual; for async setup of three.js, though most is immediate)
3. `create()`
4. `update(dt)`
5. `render()` (3D is rendered each frame via three.js)

### Pseudocode Skeleton

```js
let currentState = GameState.LOADING;
let lastTime = 0;

function init() {
  setupDOM();
  setupInput();
  setupThreeScene();
  preload(); // if needed
  changeState(GameState.LOADING);
  requestAnimationFrame(gameLoop);
}

function preload() {
  // No heavy assets; but could set up materials, geometries, etc.
}

function create() {
  // Called at transition into first interactive state.
}

function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.033);
  lastTime = timestamp;

  update(dt);
  render();

  requestAnimationFrame(gameLoop);
}

function update(dt) {
  switch (currentState) {
    case GameState.LOADING:
      updateLoading(dt);
      break;
    case GameState.TUTORIAL:
      updateTutorial(dt);
      break;
    case GameState.GAMEPLAY:
      updateGameplay(dt);
      break;
    case GameState.ENDCARD:
      updateEndcard(dt);
      break;
  }
  AnimationSystem.update(dt);
}

function render() {
  renderer.render(scene, camera);
}

function changeState(newState) {
  // call exit(old), enter(new)
}
```

### Modular Functions Breakdown

#### Setup
- `setupDOM()`
  - Create overlay divs: coin counter, fish counter, gauge, play button, upgrade buttons, tutorial text, endcard.
  - Assign IDs/classes and initial visibility.

- `setupInput()`
  - Attach `pointerdown`, `pointermove`, `pointerup` to canvas & UI buttons.
  - Debounce and unify across touch/mouse.

- `setupThreeScene()`
  - Create:
    - `scene`, `camera`, `renderer`.
    - Lights.
    - Boat + fisherman meshes.
    - Hook mesh & rope.
    - Water plane.
  - Setup aspect ratio handling on `resize`.

#### State-specific logic

- `enterLoading()` / `updateLoading(dt)`:
  - Initialize everything once; once ready -> `changeState(GameState.TUTORIAL)`.

- `enterTutorial()`:
  - `player.round = 1;`
  - Show coins, upgrades, gauge, play button.
  - `roundData.hookPhase = 'idle';`
  - `tutorialActive = true;`

- `updateTutorial(dt)`:
  - Delegate to round update (gauge > descending > ascending > summary).
  - On first pause at depth, show tutorial text for 2 seconds.

- `enterGameplay()`:
  - For rounds 2 & 3: `tutorialActive = false;`
  - Similar to tutorial but without tutorial overlay.

- `updateGameplay(dt)`:
  - Manage round sub-phases via `roundData.hookPhase`.
  - `updateGauge(dt)` if in gauge phase.
  - `updateHookDescending(dt)`, `updateHookAscending(dt)`.
  - `updateSummary(dt)`.

- `enterEndcard()`:
  - Hide game UI.
  - Show final summary and install CTA.

- `updateEndcard(dt)`:
  - Maybe subtle animations (pulse install button).

#### Round Mechanics

- `startRound()`:
  - Reset `roundData`:
    - `fishCaught = [];`
    - `fishCap = player.maxFish;`
    - Spawn/position fish for the depth range used in this round.

- `startGaugePhase()`:
  - Show gauge, pointer oscillation state.
  - Pointer angle/time variable, e.g., `gaugeTime` with `Math.sin`.

- `onPlayButtonDown()`:
  - If in pre-round state: start gauge.
  - If in gauge state: lock pointer and compute depth; transition to descending.

- `updateGauge(dt)`:
  - `gaugeTime += dt * gaugeSpeed;`
  - `pointerPos = 0.5 + 0.5 * Math.sin(gaugeTime);` // pendulum
  - Update UI pointer transform.

- `computeDepthFromPointer(pointerPos)`:
  - `maxDepth = player.maxDepth;`
  - `minDepth = maxDepth - 2;`
  - `chosenDepth = minDepth + pointerPos * (maxDepth - minDepth);`
  - Save into `roundData.actualDepthMeters`.

- `updateHookDescending(dt)`:
  - Move hook down along Y:
    - `hookY -= descendSpeed * dt;`
  - Camera follows:
    - `cameraY = lerp(cameraY, hookY + offset, 0.1);`
  - On reaching `actualDepthMeters` (mapped to world units), start pause timer.

- `updateHookPause(dt)`:
  - Count down; if first round, also show tutorial text overlay for 2 seconds.

- `updateHookAscending(dt)`:
  - If `fishCaught.length < fishCap`:
    - Normal ascend speed.
  - Else:
    - Faster ascend speed, collisions disabled.
  - Horizontal movement: based on input.
  - Perform collision checks with fish each frame.

- `updateSummary(dt)`:
  - State machine just for summary:
    - `summaryPhase = 'per-fish'` or `'total'`.
  - Animate each fish’s bounce & coin text.
  - Count-up UI for total coins.
  - At end, increment `player.round` and either start next round or go to EndCard.

---

## 9. Animations Implementation

All animations run in the main game loop; we can implement a minimal tween system:

```js
const AnimationSystem = {
  tweens: [],
  add({target, property, from, to, duration, easing, onComplete}) { ... },
  update(dt) { ... }
};
```

### 3D Animations

1. **Fisherman/Boat Bobbing**
   - Simple sine on Y rotation or vertical position:
     - `boat.position.y = baseY + Math.sin(time * speed) * amplitude;`

2. **Hook Vertical Motion**
   - Driven by manual control in `updateHook*`; we can ease at start/stop if time permits.

3. **Fish Swimming**
   - Each fish has:
     ```js
     fish.swimPhase = Math.random() * Math.PI * 2;
     fish.direction = Math.random() < 0.5 ? -1 : 1;
     ```
   - Update:
     ```js
     fish.position.x += fish.direction * swimSpeed * dt;
     fish.position.y += Math.sin(time * smallFreq + fish.swimPhase) * smallAmp;
     // bounce or reverse when reaching horizontal limit
     ```

4. **Caught Fish on Hook**
   - On catch:
     - Parent fish to hook or track position relative to hook:
       - `fish.isCaught = true;` and `fish.offsetOnHook` index.
     - Slight bobbing:
       - `fish.position.y += Math.sin(time * 8 + index) * 0.05;`

5. **Surface Bounce Animation**
   - Use tween:
     - Scale from (0,0,0) to (1.1,1.1,1.1) then to (1,1,1).
     - Or y-position bounce: overshoot and settle.

### UI Animations

1. **Gauge Pointer**
   - Pendulum via `Math.sin`.
2. **Fish Counter Fill Bar**
   - Width / height = `fishCaught / fishCap` with smooth interpolation:
     - `currentFill = lerp(currentFill, targetFill, 0.2);`
3. **Coin Popups**
   - On catch:
     - Create DOM element at 2D projected position of fish/hook.
     - Animate upward and fade out (CSS transition or JS tween).
4. **Rarity Labels (“RARE!”, etc.)**
   - Similar to coin popup but maybe slightly larger & colored.
5. **Coin Burst & Fly to Counter**
   - Spawn a few small coin circles near fish:
     - Tween them outwards and then shrink.
   - For main summary:
     - One or few coins tween from fish position to coin counter UI position (Bezier or lerp).
6. **Total Coin Counter Increment**
   - Instead of jumping straight to new value:
     - Use a tween: currentValue → targetValue over ~0.5s.

---

## 10. Mobile Input & Lag Prevention

- Use `pointerdown/move/up` with `{ passive: true }` to avoid scroll blocking; ensure canvas consumes events with `preventDefault()` where appropriate.
- No polling of input each frame beyond tracking current pointer position; event-driven update of `desiredHookX`.
- Use requestAnimationFrame; no setInterval-based loop.
- Keep physics/collision simple (AABB or distance check; minimal loops via limiting fish count).

---

## 11. Summary of Visual Implementation Choices

- **3D Elements (three.js)**:
  - Fisherman + boat
  - Hook + rope
  - Fish (with color-coded rarity)
  - Water background plane

- **2D HTML/CSS / Canvas**:
  - UI overlay: gauge, buttons, counters, tutorial, summary texts.
  - Coin and fish counter visuals (text & simple shapes).

- **No external asset loading**:
  - All shapes are primitives; colors are constants.
  - Optional minimal Base64 PNG for coin icon; otherwise, CSS circle.

---

If you want, the next step can be a concrete skeleton of the single-file HTML (structure + key JS stubs) following this blueprint.