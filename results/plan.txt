## Critical Analysis of the PRD

Key points and implications:

1. **Core Objective & Loop**
   - Goal: Earn as many coins as possible in 3 fishing rounds.
   - Loop per round:
     1. Upgrade (optional) → 
     2. Timing mini-game (depth selection gauge) → 
     3. Descent (auto) → 
     4. Short pause (tutorial first time) → 
     5. Ascent while dragging hook horizontally to catch fish → 
     6. Surface → results / coins → back to upgrade & next round / end card.
   - CTA: “Install” or “Play Now” on final screen plus subtle persistent CTA.

2. **3D Requirement**
   - “Fisherman and fishes need to be in 3D but no real assets are required - can be a basic 3D shape.”
   - We can synthesize simple 3D using **three.js via CDN** and render minimalistic low-poly shapes.
   - Background / UI can be 2D Canvas or HTML/CSS.
   - For a single-file playable, three.js must be CDN-loaded or inlined via minified code (CDN is easier and acceptable per constraints).

3. **Asset Constraints / Representation**
   - No predefined images; entire experience must be code-driven visuals or small inline assets.
   - Best approach:
     - **3D (three.js)**: fisherman, boat, hook, fish (simple meshes).
     - **2D Canvas**: HUD, gauge, counters, UI texts, effects (coin bursts, titles).
     - **Base64 placeholders**: Only if absolutely needed (e.g., store icon or a small logo). Otherwise skip images entirely.

4. **State Machine Requirement**
   - Clear requirement: Loading → Tutorial → Gameplay → EndCard.
   - PRD also contains sub-states inside Gameplay (Upgrades, Gauge, Descent, Ascent, Surface Summary, Round Transition).
   - We’ll use a primary finite state machine + internal substates for the gameplay phase.

5. **Mobile First**
   - Portrait and landscape. Needs:
     - Flexible scaling of the 3D viewport area.
     - HUD safe zones (top, bottom; away from thumb areas and notch).
     - Touch input: low-latency (passive event listeners, avoid heavy layouts on move).

6. **Missing Details / Assumptions to Clarify (but we will decide defaults)**
   - Fish types, rarity thresholds, and coin values → we’ll define a simple config table.
   - Actual depth scale vs pixels → we define a normalized depth and map to screen y.
   - Round length and maximum hook speed → we’ll choose values that feel snappy.

---

## 1. Core Loop Analysis

### Hook

- **Meta Hook:** Upgrade your gear and learn to time the cast to catch more valuable and rarer fish.
- **Moment-to-moment Hook:** The tension of stopping the gauge pointer close to “MAX” depth and then skillfully weaving through fish while ascending.

### Interaction

1. **Upgrade Phase**
   - Tap upgrade buttons (Max Fish / Max Depth) to purchase using coins.
2. **Gauge Phase**
   - Tap and hold not needed; single tap to “stop” the moving pointer and start the cast.
3. **Fishing Phase**
   - Drag horizontally to move the hook left/right as it ascends.
   - Collision with fish triggers catch animations and updates counters.

### CTA

- **Primary CTA in EndCard State:**
  - Prominent “Install” button at bottom-center in safe zone.
- **Secondary / soft CTA:**
  - Small “Install” or brand button consistently visible at top-right during gameplay, but non-blocking.
- After 3rd round finishes and summary is shown, we transition to a full-screen end card showcasing “Install”.

---

## 2. High-Level Architecture & Core Systems

### Tech Stack

- **Base:** Single HTML file.
- **Rendering:**
  - **three.js via CDN** for 3D fisherman/boat/hook/fish.
  - **Canvas 2D API** overlay for HUD, gauge, text, and effects.
- **Language:** Vanilla JS (no bundler).
- **Game Loop:** `requestAnimationFrame` driving update & render for both 3D and 2D.

### Main Modules / Systems

1. **State Machine**
   - Global `GameState` enum and a manager:
     - `LOADING`
     - `TUTORIAL` (first descent pause & message)
     - `GAMEPLAY` (with substates)
     - `ENDCARD`

2. **Gameplay Substate Machine**
   - Within `GAMEPLAY`:
     - `UPGRADE_MENU`
     - `GAUGE_SELECT`
     - `DESCENT`
     - `PAUSE_AT_DEPTH`
     - `ASCENT`
     - `SURFACE_SUMMARY`
     - `ROUND_TRANSITION` (between rounds or to ENDCARD)

3. **3D Scene System**
   - Handles three.js initialization:
     - `scene, camera, renderer, lights`.
   - Entities:
     - **Fisherman + Boat**: static at top, maybe a cube on a rectangle.
     - **Hook**: small object attached to an invisible vertical line.
     - **Fish**: a pool of colored low-poly meshes placed at varying depths and x-positions.
   - Camera:
     - Follows hook’s y-position during DESCENT and ASCENT, clamped to a range.
   - Lightweight shading & no textures to keep fast.

4. **2D HUD/UI System (Canvas Overlay)**
   - Renders dynamic UI on top of 3D:
     - Coin counter.
     - Fish counter + fill bar.
     - Gauge bar and moving pointer during GAUGE_SELECT.
     - Upgrade buttons (Max Fish & Max Depth).
     - Tutorial text overlays.
     - Floating text (coin amounts, “Rare!”, “Legendary!”).
     - Summary + coin tally animation.
   - UI layout is computed based on a virtual design space and scaled to device.

5. **Input System**
   - Pointer/touch abstraction:
     - `pointerDown`, `pointerMove`, `pointerUp` events.
   - Contextual behavior:
     - If in `GAUGE_SELECT`: `pointerDown`/`pointerUp` stops gauge.
     - If in `ASCENT`: `pointerMove` + `pointerDown` or simply pointer position to control hook’s x within bounds.
     - If over upgrade buttons in `UPGRADE_MENU`: tap to purchase.
     - End card CTA: tap to trigger click-out.

6. **Physics / Movement System**
   - Hook vertical movement with constant speed; acceleration when max fish reached.
   - Horizontal movement:
     - Direct mapping of pointer X to hook X or eased interpolation for smooth motion.
   - Collision detection:
     - Simple 2D approximation in screen or world space: check distance between hook and fish centers.

7. **Economy & Progression System**
   - Player data:
     - `coins`
     - `maxFishCapacity`
     - `maxDepth`
     - `currentRound` (1–3)
   - Upgrade configs:
     - Max Fish levels & costs.
     - Max Depth levels & costs.
   - Fish value / rarity tables.

8. **Effects / Animation System**
   - Time-based tweens for:
     - Gauge pointer movement (pendulum).
     - Hook speed-up to surface when full.
     - Coin bursts (small circles or sprites radiating from fish).
     - Text popups (scale & alpha).
     - Summary counting up coins and coins “flying” to counter (lerping positions).

---

## 3. Entities and Data Structures

### Global Game State Structure

```js
const GameStates = {
  LOADING: 'loading',
  TUTORIAL: 'tutorial',
  GAMEPLAY: 'gameplay',
  ENDCARD: 'endcard',
};

const GameplaySubStates = {
  UPGRADE_MENU: 'upgrade_menu',
  GAUGE_SELECT: 'gauge_select',
  DESCENT: 'descent',
  PAUSE_AT_DEPTH: 'pause_at_depth',
  ASCENT: 'ascent',
  SURFACE_SUMMARY: 'surface_summary',
  ROUND_TRANSITION: 'round_transition'
};

const game = {
  state: GameStates.LOADING,
  subState: null,
  round: 1,
  maxRounds: 3,
  time: 0,
  deltaTime: 0,
  lastTimestamp: 0,
  // progression
  coins: 100,
  maxFishCapacity: 6,
  maxDepthLevelIndex: 0,
  maxFishLevelIndex: 0,
  selectedDepth: 0,
  currentCatch: [], // array of Fish
  caughtCount: 0,
  tutorialShown: false,
};
```

### Upgrades Data

```js
const maxFishLevels = [
  { capacity: 6, cost: null },
  { capacity: 7, cost: 50 },
  { capacity: 8, cost: 100 },
  { capacity: 9, cost: 200 },
  { capacity: 10, cost: 400 }
];

const depthLevels = [
  { depth: 5, cost: null },
  { depth: 10, cost: 50 },
  { depth: 15, cost: 75 },
  { depth: 20, cost: 150 },
  { depth: 30, cost: 300 }
];
```

### Fish Entity

```js
class Fish {
  constructor(opts) {
    this.id = opts.id;
    this.type = opts.type; // 'common', 'rare', 'legendary', etc.
    this.value = opts.value;
    this.depth = opts.depth; // world units
    this.position = { x: opts.x, y: opts.y, z: opts.z };
    this.mesh = opts.mesh; // three.js Mesh
    this.caught = false;
    this.shownLabel = false; // to show "Rare!" etc only once
  }
}
```

### Hook Entity

```js
const hook = {
  mesh: null,          // three.js Mesh
  line: null,          // optional visual line
  worldY: 0,
  worldX: 0,
  speedY: 0,
  targetDepth: 0,
  direction: 1,        // 1 down, -1 up
  maxSpeedUp: 0.25,
  normalSpeed: 0.12,
  fastSpeed: 0.4,      // when full
};
```

### UI / Gauge Data

```js
const gauge = {
  active: false,
  pointerPos: 0,   // 0..1
  direction: 1,    // 1 forward, -1 backward
  speed: 0.8,      // oscillation speed (units / second)
  easing: 0.0,     // used at edges
  minDepthFraction: 0.0,
  maxDepthFraction: 1.0
};

const counters = {
  coinsDisplay: 100,
  fishDisplay: 0,
  fishBarFill: 0, // 0..1
};
```

### Effects / UI Elements

```js
const floatingTexts = []; // { text, x, y, life, maxLife, color, scale, alpha }
const coinBursts = []; // { x, y, particles: [...] }
const uiButtons = {
  upgradeMaxFish: { x:0, y:0, w:0, h:0 },
  upgradeMaxDepth: { x:0, y:0, w:0, h:0 },
  playGaugeButton: { x:0, y:0, w:0, h:0 },
  installCTA: { x:0, y:0, w:0, h:0 },
};
```

---

## 4. Assets Strategy (2D vs 3D)

### 3D Elements (three.js)

- **Fisherman + Boat**
  - Simple geometric shapes:
    - Boat: stretched box.
    - Fisherman: a few stacked boxes (body, head).
  - Static at top of world (y=0).
- **Hook**
  - A small elongated box or cylinder.
  - Vertical line (thin cylinder or line segment).
- **Fish**
  - Simple 3D shapes:
    - Capsule or elongated box with a small triangle tail (two meshes merged or grouped).
  - Different colors per rarity.
- **World “Depth”**
  - Simple gradient background color (via clear color) and maybe a few spheres/planes as “bubbles” or “plants” for depth perception.

### 2D Canvas-Drawn Assets

- **HUD Bars and Panels:**
  - Coin counter at top-left (rounded rect + coin icon via simple circle + “C” letter).
  - Fish counter bar (replaces coin counter during descent/ ascent) with filling rectangle.
- **Gauge:**
  - Horizontal bar with ticks and pointer triangle or vertical line.
- **Buttons:**
  - Rounded rects with text for Max Fish / Max Depth / Play.
- **Text Overlays:**
  - Tutorial text, fish rarity labels, coin amounts, summary.

### Base64 Placeholders (Optional)

- **Optional small logo / store icon**:
  - A tiny 32x32 PNG encoded as base64 and drawn with `drawImage`. Only if branding is needed; not required by PRD.

---

## 5. State Management and Transitions

### Primary State Transitions

1. `LOADING → TUTORIAL`
   - Once three.js and canvas are initialized and first frame is ready.
   - Actually, tutorial is tied to first descent pause, but global state can be set to `GAMEPLAY` with `tutorialShown=false`; or we can treat `TUTORIAL` as a one-frame gating state that transitions immediately to `GAMEPLAY/UPGRADE_MENU`.
   - Recommended:
     - `LOADING → GAMEPLAY (subState=UPGRADE_MENU)` and treat tutorial as a flag during first `PAUSE_AT_DEPTH`.

2. `GAMEPLAY → ENDCARD`
   - After 3rd round summary is finished and coin transfer animation completes.

3. `ENDCARD`
   - Stable, with only CTA interactions (and maybe restart for debug).

### Gameplay Substate Flow per Round

1. `UPGRADE_MENU`
   - Show upgrades and current coins.
   - Actions:
     - Tap upgrade buttons → attempt purchase.
     - Tap “Play” → `GAUGE_SELECT`.

2. `GAUGE_SELECT`
   - Gauge pointer oscillates min-max-min.
   - On tap:
     - Compute `selectedDepth` from pointer position within [maxDepth-2, maxDepth].
     - `subState = DESCENT`.

3. `DESCENT`
   - Replace coin counter with fish counter UI.
   - Hook moves down:
     - `hook.direction = 1; speedY = normalSpeed;`
     - Camera follows hook’s y.
   - When hook reaches target depth (or clamped by maxDepth):
     - `subState = PAUSE_AT_DEPTH`.

4. `PAUSE_AT_DEPTH`
   - Hook holds position for 0.5–1s.
   - If first round and tutorial not shown:
     - Show tutorial message “Move the hook to catch fish” for ~2s.
     - After that, `tutorialShown = true`.
   - Then `subState = ASCENT`.

5. `ASCENT`
   - Hook moves up: `direction = -1; speedY = normalSpeed`.
   - Player drag controls hook.x.
   - Collision checks:
     - If hook intersects with uncaught fish and capacity not full:
       - Mark fish as caught, parent it under hook (or update y together).
       - Show floating text with coin value & rarity label.
       - Update fish counter / fill bar.
       - If capacity reached:
         - Increase speed to `fastSpeed`.
         - Disable further catches (ignore collisions).
   - Once hook reaches surface (y≈0):
     - Swap fish counter → coin counter UI.
     - `subState = SURFACE_SUMMARY`.

6. `SURFACE_SUMMARY`
   - Hook & fish stop at surface.
   - Animate:
     - Each fish in `currentCatch` gets a “jump” animation.
     - Display their individual coin values and rarity texts.
     - Coin bursts from each fish to a temporary total.
   - Sum total coins → animate count up.
   - Animate “coins flying” to global coin counter.
   - At completion:
     - `game.coins += roundTotal;`
     - `subState = ROUND_TRANSITION`.

7. `ROUND_TRANSITION`
   - Increment round.
   - If `round <= maxRounds`:
     - Reset hook and fish states for new round.
     - `subState = UPGRADE_MENU`.
   - Else:
     - `state = ENDCARD`.

---

## 6. Responsive Grid & Layout

### Virtual Coordinate System

- Define a virtual viewport, e.g. `VIRTUAL_WIDTH = 720`, `VIRTUAL_HEIGHT = 1280`.
- For any actual screen size:
  - Compute scale factor:
    ```js
    const scale = Math.min(window.innerWidth / VIRTUAL_WIDTH,
                           window.innerHeight / VIRTUAL_HEIGHT);
    const offsetX = (window.innerWidth - VIRTUAL_WIDTH * scale) / 2;
    const offsetY = (window.innerHeight - VIRTUAL_HEIGHT * scale) / 2;
    ```
  - All UI coordinates defined in virtual space; convert to real screen for drawing and hit-testing.

### Layout Regions

- **Top Safe Zone (HUD)**
  - Height: ~15% of VIRTUAL_HEIGHT.
  - Contains:
    - Left: Coins indicator.
    - Center: (when active) Fish counter/fill bar.
    - Right: optional small CTA icon or settings (if any).
- **Middle Region (3D Viewport)**
  - ~70% height.
  - three.js canvas will be scaled to fill this region.
  - Hook, fish, etc., visible here.
- **Bottom Region (Controls)**
  - ~15% height.
  - Contains:
    - Gauge bar and play button (during GAUGE_SELECT).
    - Upgrade buttons (during UPGRADE_MENU).
    - Install CTA in ENDCARD (but abiding by safe zones).

### Portrait vs Landscape

- **Portrait:**
  - Default as above.
- **Landscape:**
  - 3D viewport left ~60% width.
  - UI / gauge / upgrades & counters stacked on right ~40%.
  - Keep CTA at bottom-right region in a thumb-accessible area.

---

## 7. UI/UX & CTA Positioning

### CTA Button (EndCard)

- Position near bottom center:
  - Virtual coordinates, e.g.:
    ```js
    installCTA = {
      x: VIRTUAL_WIDTH * 0.5 - 160,
      y: VIRTUAL_HEIGHT * 0.8,
      w: 320,
      h: 90
    };
    ```
  - This is above the OS gesture bars & home indicator (~safe 44px from bottom).
- Visual style:
  - Large rounded rect, high-contrast color, bold label “Install”.

### In-Game CTA / Branding

- Smaller nonintrusive CTA:
  - Top-right, inside safe zone, 48x48 or 64x64 button, could display an icon or text.

---

## 8. Step-by-Step Code Structure

We follow a Phaser-like lifecycle with our own functions.

### 1. `init()`

- Called once on DOM `load`.
- Responsibilities:
  - Create `<canvas>` for 2D UI.
  - Initialize 2D context.
  - Initialize 3D renderer (three.js), scene, camera, lights.
  - Setup resize listener.
  - Setup input listeners:
    - `mousedown` / `touchstart`
    - `mousemove` / `touchmove`
    - `mouseup` / `touchend`
  - Initialize data structures (game, hook, fish arrays, upgrades).
  - Start `requestAnimationFrame(gameLoop)`.

### 2. `preload()`

- For this project, minimal use:
  - If we use any base64 images, create `Image` objects and mark loaded.
  - Otherwise, just immediately set `game.state = GameStates.GAMEPLAY; game.subState = GameplaySubStates.UPGRADE_MENU;`.

### 3. `create()`

- Build initial entities:
  - Add boat + fisherman mesh to scene.
  - Create hook mesh & line.
  - Generate fish for first round:
    - Spread them at various depths up to current `maxDepth`.
  - Initialize UI button bounds based on current layout.

*(This can be merged into `init` if we want minimal overhead.)*

### 4. `update(deltaTime)`

Main per-frame logic:

```js
function update(dt) {
  game.time += dt;
  // Update sub-state machine
  switch (game.state) {
    case GameStates.GAMEPLAY:
      updateGameplay(dt);
      break;
    case GameStates.ENDCARD:
      updateEndcard(dt);
      break;
  }

  updateEffects(dt); // floating texts, coin bursts, etc.

  // three.js animations & camera
  update3D(dt);
}
```

#### `updateGameplay(dt)`

```js
function updateGameplay(dt) {
  switch (game.subState) {
    case GameplaySubStates.UPGRADE_MENU:
      // idle: wait for input events
      break;
    case GameplaySubStates.GAUGE_SELECT:
      updateGauge(dt);
      break;
    case GameplaySubStates.DESCENT:
      updateDescent(dt);
      break;
    case GameplaySubStates.PAUSE_AT_DEPTH:
      updatePauseAtDepth(dt);
      break;
    case GameplaySubStates.ASCENT:
      updateAscent(dt);
      break;
    case GameplaySubStates.SURFACE_SUMMARY:
      updateSurfaceSummary(dt);
      break;
    case GameplaySubStates.ROUND_TRANSITION:
      updateRoundTransition(dt);
      break;
  }
}
```

#### Gauge Update

```js
function updateGauge(dt) {
  if (!gauge.active) return;
  let p = gauge.pointerPos;
  p += gauge.direction * gauge.speed * dt;
  if (p > 1) { p = 1; gauge.direction = -1; }
  if (p < 0) { p = 0; gauge.direction = 1; }
  gauge.pointerPos = p;
}
```

#### Descent Update

```js
function updateDescent(dt) {
  hook.worldY += hook.normalSpeed * dt;
  if (hook.worldY >= hook.targetDepth) {
    hook.worldY = hook.targetDepth;
    game.subState = GameplaySubStates.PAUSE_AT_DEPTH;
    game.pauseTimer = 0;
  }
}
```

#### Pause Update & Tutorial

```js
function updatePauseAtDepth(dt) {
  game.pauseTimer += dt;
  const tutorialDuration = game.tutorialShown ? 0.8 : 2.0;

  if (!game.tutorialShown) {
    // Show tutorial overlay
    if (game.pauseTimer > tutorialDuration) {
      game.tutorialShown = true;
      game.subState = GameplaySubStates.ASCENT;
      hook.direction = -1;
    }
  } else {
    if (game.pauseTimer > 0.8) {
      game.subState = GameplaySubStates.ASCENT;
      hook.direction = -1;
    }
  }
}
```

#### Ascent & Collision

```js
function updateAscent(dt) {
  const speed = (game.caughtCount >= game.maxFishCapacity)
    ? hook.fastSpeed
    : hook.normalSpeed;

  hook.worldY -= speed * dt;
  if (hook.worldY <= 0) {
    hook.worldY = 0;
    game.subState = GameplaySubStates.SURFACE_SUMMARY;
    prepareSurfaceSummary();
    return;
  }

  // Horizontal control handled in input; hook.worldX updated by pointer.

  // Collision detection
  if (game.caughtCount < game.maxFishCapacity) {
    for (const fish of fishList) {
      if (fish.caught) continue;
      if (checkHookFishCollision(hook, fish)) {
        catchFish(fish);
        if (game.caughtCount >= game.maxFishCapacity) {
          // Immediately accelerate; no more catches
          break;
        }
      }
    }
  }

  // Update fish counter fill
  counters.fishDisplay = game.caughtCount;
  counters.fishBarFill = game.caughtCount / game.maxFishCapacity;
}
```

### 5. `render()`

- Clear 3D and render scene:
  ```js
  renderer.render(scene, camera);
  ```
- Clear 2D overlay with transparent clear.
- Draw UI:
  - `drawHUD(ctx)`
  - `drawGauge(ctx)` when in GAUGE_SELECT.
  - `drawUpgrades(ctx)` when in UPGRADE_MENU.
  - `drawTutorial(ctx)` if needed.
  - `drawSummary(ctx)` in SURFACE_SUMMARY / ENDCARD.

### 6. `gameLoop(timestamp)`

```js
function gameLoop(timestamp) {
  if (!game.lastTimestamp) game.lastTimestamp = timestamp;
  const dt = (timestamp - game.lastTimestamp) / 1000;
  game.lastTimestamp = timestamp;

  update(dt);
  render();

  requestAnimationFrame(gameLoop);
}
```

---

## 9. Input Handling and Hooks

### Pointer Events Setup

- Use passive listeners where appropriate for scroll performance, but for full-screen canvas, we can prevent default on touch to avoid scrolling.

```js
canvas2d.addEventListener('mousedown', onPointerDown);
canvas2d.addEventListener('mousemove', onPointerMove);
canvas2d.addEventListener('mouseup', onPointerUp);
canvas2d.addEventListener('touchstart', onPointerDown, { passive: false });
canvas2d.addEventListener('touchmove', onPointerMove, { passive: false });
canvas2d.addEventListener('touchend', onPointerUp);
```

### Contextual Behavior

- **In `UPGRADE_MENU`:**
  - Detect if the pointer down is inside `upgradeMaxFish` or `upgradeMaxDepth` button bounds → try to purchase.
  - Detect if inside `playGaugeButton` → set `subState = GAUGE_SELECT; gauge.active = true;`.

- **In `GAUGE_SELECT`:**
  - On pointer down or up:
    - Freeze gauge pointer.
    - Compute target depth:
      ```js
      const level = depthLevels[game.maxDepthLevelIndex];
      const maxDepth = level.depth;
      const minDepth = Math.max(0, maxDepth - 2);
      const t = gauge.pointerPos; // 0..1
      game.selectedDepth = minDepth + t * (maxDepth - minDepth);
      hook.targetDepth = game.selectedDepth;
      hook.worldY = 0;
      hook.direction = 1;
      game.subState = GameplaySubStates.DESCENT;
      gauge.active = false;
      // switch coin->fish counter display flags
      ```

- **In `ASCENT`:**
  - On pointer move:
    - Convert screen X to virtual X, then to world X within limits:
      ```js
      const virtualX = (screenX - offsetX) / scale;
      const normalized = clamp((virtualX - marginLeft) / availableWidth, 0, 1);
      hook.worldX = worldMinX + normalized * (worldMaxX - worldMinX);
      ```

- **In `SURFACE_SUMMARY` and `ROUND_TRANSITION`:**
  - Optionally allow tap to skip animations and move faster to next state.

- **In `ENDCARD`:**
  - If tap on `installCTA` button → call `window.open(storeURL, '_blank')` or post message to host.

---

## 10. Animations Detail per Entity

### Hook

- Descent / ascent:
  - Linear in time, but we can add slight easing near end of ascent to feel snappy.
- Speed boost:
  - When max fish reached, quickly ramp speed from normal to fast using a short tween (0.2s).

### Fish

- Idle:
  - Gentle side-to-side or up-down swivel by oscillating rotation or x-position (`Math.sin(game.time + offset)`).
- When caught:
  - Attach to hook (set parent group).
  - Slight bounce on initial catch.
  - For reward sequence:
    - Each fish jumps upward slightly and falls back (just y oscillation over 0.4–0.6s).

### Gauge Pointer

- Pendulum-like oscillation:
  - Already using reversed direction at edges; to add ease-in-out visually:
    - Multiply `speed` by a cosine factor near edges:
      ```js
      const edgeFactor = Math.sin(gauge.pointerPos * Math.PI); // 0 at edges, 1 in middle
      effectiveSpeed = baseSpeed * (0.3 + 0.7 * edgeFactor);
      ```

### Counters

- Coin counter:
  - `coinsDisplay` interpolates toward `game.coins` when updated.
- Fish counter:
  - Bar fill smoothly interpolates to target fill.

### Floating Text & Coin Bursts

- Floating text:
  - Each frame: `y -= speed * dt; alpha -= fade * dt; scale += grow * dt;`
  - Remove when `life > maxLife`.
- Coin bursts:
  - For each particle: radial motion with decaying speed and fading alpha.

### Camera

- Follows hook with smoothing:
  ```js
  const targetY = hook.worldY;
  camera.position.y += (targetY - camera.position.y) * 0.1;
  camera.lookAt(new THREE.Vector3(0, camera.position.y, 0));
  ```

---

## 11. 2D vs 3D Summary per Visual Element

- **3D (three.js)**
  - Fisherman: basic boxes.
  - Boat: box.
  - Hook & line: cylinder or box.
  - Fish: colored boxes/capsules with small fin/tail shape.
  - Underwater environment hints: simple geometric shapes.

- **2D Canvas**
  - HUD: coin counter, fish counter, fill bar.
  - Gauge: bar + pointer.
  - Upgrade buttons & Play button.
  - Tutorial messages and rarity labels (“Rare!”, “Amazing!”, “Legendary!”).
  - Coin bursts & floating text.
  - EndCard UI and Install CTA.

- **Base64 (optional, not necessary)**
  - Any logo/store icon if required by marketing; otherwise skip.

---

This blueprint defines how to translate the PRD into a performant, single-file HTML5 playable ad with a clear state machine, responsive layout, 3D fisherman and fish, and fully code-driven visuals and animations.